<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018-06月至07月的一些总结</title>
    <url>/2018/07/16/2018-06and07-conclusion/</url>
    <content><![CDATA[<h1 id="2018-06月至07月的一些总结"><a href="#2018-06月至07月的一些总结" class="headerlink" title="2018-06月至07月的一些总结"></a>2018-06月至07月的一些总结</h1><p>最近好久都没有写博客了。其实最近做的事情都比较单调，就是迁移环境，不过再迁移环境中，我还是收获了很多我缺少的。单从非技术方面，我缺少勉才的那股韧劲（问题不会过夜），缺少华哥那种细致（仔细的做过一遍，还会仔细的检查一遍，不是那种大致检查，是那种一条一条的比对），当然我也看到有些同事的缺点也是我的缺点，有则改之。</p>
<p>在搬迁中，华哥是我们部的总负责人，他对所有的事情都会有把控，搞不定的事情都会找他。而且他总能找到合适的方法解决。最重要的是，我犯错他却从来没有指责过，只是说怎样弥补，然后跟我们说正确的方法，而后我觉得挺对不住他的。总会想着把事情再做好点。勉才是小组的执行人，执行人真的超级强，问题基本没过夜，总是在12点的时候或者第二天一早问他，他就说问题解决了。。简直了。</p>
<p>这次搬迁我们是轮值的，也就是一开始将所有任务分配好，然后各自自己实验一次，写下步骤，下一轮再给另一个人按照写的步骤实行一次，这样来回3轮。最后基本上，步骤文档就没啥问题了。任何人都可以按照文档完整的搭出系统。</p>
<span id="more"></span>
<p>这个过程会遇到一些问题，有些已经遗忘，有些所幸有所备份。</p>
<p>Q: Docker 新镜像里面脚本无权限<br>A: 这个问题是脚本在windows传递到linux系统里面可能会出现，如果看ls，那么X的权限都没有了。这个时候解决拌饭就是<code>chmod a+x xxx.sh</code></p>
<p>Q: Docker 导入导出镜像<br>A：镜像保存：<code>docker save -o image-name.tar image-name:latest</code>，镜像导入：<code>docker load &lt; image-name.tar</code></p>
<p>Q: Docker 运行一个容器，执行完之后就退出<br>A: <code>docker run --rm image:latest bash/sh</code></p>
<p>Q: 从运行中的容器拷贝文件/文件夹到宿主机<br>A: docker cp container-id:/path/to/file /path/to/file</p>
<p>Q: 修改Docker的docker.service<br>A：<code>sudo cat /lib/systemd/system/docker.service</code>,可以使用<code>find / -name docker.service</code>来找到相应文件。修改这个文件之后需要重启daemon。<code>systemctl daemon-reload</code>。在这个文件里面可以增加docker的http,https的代理。</p>
<p>Q: 遇到Docker push镜像的时候出现https的问题<br>A: 在/etc/docker/daemon.json文件中增加：[“insecure-registries”:[“registry.chenzhijun.com:5000”]</p>
<p>Q: “can’t create unix socket /var/run/docker.sock: is a directory”<br>A: rm -fr  /var/run/docker.sock/</p>
<p>Q: 容器内部无法访问外网：<br>A:  1：检查容器内部的dns，cat /etc/resolv.conf<br>    2：检查宿主机的dns，</p>
<p>Q: ubuntu18 重启无法进入桌面<br>A: 选择联网，让其然后下载显卡厂商的驱动。</p>
<p>Q: Linux统计一个文件夹下某类文件的数量<br>A: ls ./* | wc -l</p>
<p>Q: 查找当前目录使用情况：<br>A: du -h</p>
<p>Q: 查看磁盘使用情况：<br>A: df -h</p>
<p>Q: 修改文件所有者<br>A: chown -R user:group xxFile/xxDir</p>
<p>Q: shell 文件分割字符串<br>A:如下面的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line">name=$(hostname -i)</span><br><span class="line">file=$&#123;name%% *&#125; //分割空格</span><br><span class="line">df -h &gt;/home/rhlog/$file.log</span><br></pre></td></tr></table></figure>

<p>Q: find 使用</p>
<p>Q: AWK 使用，grep 使用</p>
<p>Q: haproxy 使用</p>
<p>Q: Ansible 直接使用命令</p>
<p>A: ansible-playbook -i host  -m shell -a “docker ps”</p>
<p>Q: Dockerfile 制作镜像</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>基础脚本</title>
    <url>/2018/05/10/a-easy-script/</url>
    <content><![CDATA[<h1 id="基础脚本"><a href="#基础脚本" class="headerlink" title="基础脚本"></a>基础脚本</h1><p>最近在同事那里学到一个小脚本，感觉要是之前我也会这样写，那我省去多少时间啊，技多不压身啊。</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;ok&quot;</span><br><span class="line"></span><br><span class="line">buildProcess()&#123;</span><br><span class="line">	echo &quot;build image&quot;;</span><br><span class="line">	docker build -t promethues-agent:v0.1.test .</span><br><span class="line">	echo &quot;start contianer..&quot;;</span><br><span class="line">	docker run -dit -P --name pro-agent-test promethues-agent:v0.1.test --spring.profiles.active=test</span><br><span class="line">	echo &quot;finished&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">privilege()&#123;</span><br><span class="line">	if [ &quot;$(whoami)&quot; != &quot;root&quot; ]</span><br><span class="line">	then</span><br><span class="line">        echo &quot;should be root to execute this script&quot;;</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopProecess()&#123;</span><br><span class="line"></span><br><span class="line">    echo &quot;delete container..&quot;;</span><br><span class="line">    docker rm -f pro-agent-test</span><br><span class="line">    echo &quot;delete image...&quot;;</span><br><span class="line">    docker rmi promethues-agent:v0.1.test</span><br><span class="line">    echo &quot;finished&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showUsage()&#123;</span><br><span class="line">	cat &lt;&lt;END</span><br><span class="line">Usage: $0 &lt;build|stop&gt;</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">	command=$1</span><br><span class="line">	</span><br><span class="line"><span class="meta">	#</span><span class="bash"> check privilege</span></span><br><span class="line"><span class="meta">#</span><span class="bash">	privilege</span></span><br><span class="line"></span><br><span class="line">	case $command in</span><br><span class="line">    		&quot;build&quot;) buildProcess;;</span><br><span class="line">    		&quot;stop&quot;) stopProecess;;</span><br><span class="line">    		*) showUsage;;</span><br><span class="line">	esac</span><br><span class="line">&#125;</span><br><span class="line">main $@</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面是一个docker镜像的制作脚本，命名为<code>dockerimg.sh</code>。使用方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">./dockerimg.sh build</span><br><span class="line"></span><br><span class="line">./dockerimg.sh stop</span><br><span class="line"></span><br><span class="line">./dockerimg.sh *</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Alertmanager 配置邮件模板</title>
    <url>/2019/01/08/alertmanager-email/</url>
    <content><![CDATA[<h1 id="Alertmanager-配置邮件模板"><a href="#Alertmanager-配置邮件模板" class="headerlink" title="Alertmanager 配置邮件模板"></a>Alertmanager 配置邮件模板</h1><h2 id="Alertmanager-配置"><a href="#Alertmanager-配置" class="headerlink" title="Alertmanager 配置"></a>Alertmanager 配置</h2><p>alertmanager 的配置主要是要配置邮箱（通知方式）和模板地址；文档地址：<a href="https://prometheusaio/docs/alerting/configuration/#email_config">Alertmanager 地址</a>，配置完之后就只需要在模板中定义就好了。</p>
<span id="more"></span>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">....</span></span><br><span class="line"><span class="comment"># Whether or not to notify about resolved alerts.</span></span><br><span class="line">[ <span class="attr">send_resolved:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="literal">false</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The email address to send notifications to.</span></span><br><span class="line"><span class="attr">to:</span> <span class="string">&lt;tmpl_string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The sender address.</span></span><br><span class="line">[ <span class="attr">from:</span> <span class="string">&lt;tmpl_string&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">global.smtp_from</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The SMTP host through which emails are sent.</span></span><br><span class="line">[ <span class="attr">smarthost:</span> <span class="string">&lt;string&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">global.smtp_smarthost</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The hostname to identify to the SMTP server.</span></span><br><span class="line">[ <span class="attr">hello:</span> <span class="string">&lt;string&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">global.smtp_hello</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># SMTP authentication information.</span></span><br><span class="line">[ <span class="attr">auth_username:</span> <span class="string">&lt;string&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">global.smtp_auth_username</span> ]</span><br><span class="line">[ <span class="attr">auth_password:</span> <span class="string">&lt;secret&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">global.smtp_auth_password</span> ]</span><br><span class="line">[ <span class="attr">auth_secret:</span> <span class="string">&lt;secret&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">global.smtp_auth_secret</span> ]</span><br><span class="line">[ <span class="attr">auth_identity:</span> <span class="string">&lt;string&gt;</span> <span class="string">|</span> <span class="string">default</span> <span class="string">=</span> <span class="string">global.smtp_auth_identity</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">templates:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&#x27;/etc/alertmanager/templates/xxx.tmpl&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="模板配置"><a href="#模板配置" class="headerlink" title="模板配置"></a>模板配置</h2><p>下面给出一份模板配置的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;&#123; define &quot;email.common.html&quot; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;this is test....&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">            &#123;&#123; .Alerts | len &#125;&#125; alert&#123;&#123; if gt (len .Alerts) 1 &#125;&#125;s&#123;&#123; end &#125;&#125; for &#123;&#123; range .GroupLabels.SortedPairs &#125;&#125;</span><br><span class="line">                &#123;&#123; .Name &#125;&#125;&#x3D;&#123;&#123; .Value &#125;&#125;</span><br><span class="line">              &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在Alertmanager中查看 ：&lt;a href&#x3D;&quot;&#123;&#123; template &quot;__alertmanagerURL&quot; . &#125;&#125;&quot;&gt;View in &#123;&#123; template &quot;__alertmanager&quot; . &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#123;&#123; if gt (len .Alerts.Firing) 0 &#125;&#125;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;strong&gt;[&#123;&#123; .Alerts.Firing | len &#125;&#125;] Firing&lt;&#x2F;strong&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">                &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                 &#123;&#123; range .Alerts.Firing &#125;&#125;</span><br><span class="line">                &lt;tr style&#x3D;&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; box-sizing: border-box; font-size: 14px; margin: 0;&quot;&gt;</span><br><span class="line">                  &lt;td style&#x3D;&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; box-sizing: border-box; font-size: 14px; vertical-align: top; margin: 0; padding: 0 0 20px;&quot; valign&#x3D;&quot;top&quot;&gt;</span><br><span class="line">                    &lt;strong&gt;Labels&lt;&#x2F;strong&gt;</span><br><span class="line"></span><br><span class="line">                    &#123;&#123; range .Labels.SortedPairs &#125;&#125;&#123;&#123; .Name &#125;&#125; &#x3D; &#123;&#123; .Value &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">                    &#123;&#123; if gt (len .Annotations) 0 &#125;&#125;</span><br><span class="line">                        &lt;strong&gt;Annotations&lt;&#x2F;strong&gt;</span><br><span class="line">                        &lt;br&gt;</span><br><span class="line">                    &#123;&#123; end &#125;&#125;</span><br><span class="line">                    </span><br><span class="line">                    &#123;&#123; range .Annotations.SortedPairs &#125;&#125;</span><br><span class="line">                        &#123;&#123; .Name &#125;&#125; &#x3D; &#123;&#123; .Value &#125;&#125;</span><br><span class="line">                    &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">                    &lt;a href&#x3D;&quot;&#123;&#123; .GeneratorURL &#125;&#125;&quot; style&#x3D;&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; box-sizing: border-box; font-size: 14px; color: #348eda; text-decoration: underline; margin: 0;&quot;&gt;</span><br><span class="line">                        Source</span><br><span class="line">                    &lt;&#x2F;a&gt;</span><br><span class="line">                        </span><br><span class="line">                    &lt;br style&#x3D;&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; box-sizing: border-box; font-size: 14px; margin: 0;&quot; &#x2F;&gt;</span><br><span class="line">                  &lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">                &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#123;&#123; if gt (len .Alerts.Resolved) 0 &#125;&#125;</span><br><span class="line">                  &#123;&#123; if gt (len .Alerts.Firing) 0 &#125;&#125;</span><br><span class="line">                  &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">                  &lt;td&gt;</span><br><span class="line">                    &lt;strong&gt;[&#123;&#123; .Alerts.Resolved | len &#125;&#125;] Resolved&lt;&#x2F;strong&gt;</span><br><span class="line">                  &lt;&#x2F;td&gt;</span><br><span class="line">                &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#123;&#123; range .Alerts.Resolved &#125;&#125;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                  &lt;td&gt;</span><br><span class="line">                    &lt;strong&gt;Labels&lt;&#x2F;strong&gt;</span><br><span class="line">                    &lt;br&#x2F;&gt;</span><br><span class="line">                    &#123;&#123; range .Labels.SortedPairs &#125;&#125;</span><br><span class="line">                        &#123;&#123; .Name &#125;&#125; &#x3D; &#123;&#123; .Value &#125;&#125;</span><br><span class="line">                    &#123;&#123; end &#125;&#125;</span><br><span class="line">                    </span><br><span class="line">                    &#123;&#123; if gt (len .Annotations) 0 &#125;&#125;</span><br><span class="line">                        &lt;strong&gt;Annotations&lt;&#x2F;strong&gt;</span><br><span class="line">                    &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">                    &#123;&#123; range .Annotations.SortedPairs &#125;&#125;</span><br><span class="line">                        &#123;&#123; .Name &#125;&#125; &#x3D; &#123;&#123; .Value &#125;&#125;</span><br><span class="line">                    &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">                    &lt;a href&#x3D;&quot;&#123;&#123; .GeneratorURL &#125;&#125;&quot; style&#x3D;&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; box-sizing: border-box; font-size: 14px; color: #348eda; text-decoration: underline; margin: 0;&quot;&gt;</span><br><span class="line">                        Source</span><br><span class="line">                    &lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;br style&#x3D;&quot;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; box-sizing: border-box; font-size: 14px; margin: 0;&quot; &#x2F;&gt;</span><br><span class="line">                  &lt;&#x2F;td&gt;</span><br><span class="line">                &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里要注意的是第一行:<code>define &quot;email.common.html&quot;</code>记住结尾一定要有 <code>end</code> 与之对应，因为 golang 的 template 模板限制。<br>其实这个 tmpl 文件就是 golang 的 template 模板。以前看到还有点懵，用过一次 golang 中 template 功能之后，会有很多明白的地方。</p>
<p>在一个文件中也是可以定义多个模板的只需要有多个<code>define &quot;xxx&quot;</code>即可。记住在 alertmanager 的配置文件<code>alertmanager.yml</code>中一定要有</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">html:</span>  &#123;&#123;<span class="string">template</span> <span class="string">&quot;email.common.html&quot;</span> &#125;&#125; <span class="string">.</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>email.common.html</code>要与tmpl文件中定义的相同。</p>
<p>源码中有示例: <a href="https://github.com/prometheus/alertmanager/blob/master/template/default.tmpl">alertmanager template</a></p>
<p>而tmpl文件里面的内容都在这个go文件中 <a href="https://github.com/prometheus/alertmanager/blob/master/template/template.go">template.go</a> 可以看到里面有个<code>Data</code>struct。这里就是它的详细信息了。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://godoc.org/text/template">package text/template</a></p>
<p><a href="https://golang.org/pkg/html/template/">package html/template</a></p>
<p><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/zh/07.4.html">模板处理</a></p>
<p><a href="https://www.kancloud.cn/cserli/golang/531904">golang 模板(template)的常用基本语法</a></p>
]]></content>
      <categories>
        <category>Alertmanager</category>
      </categories>
      <tags>
        <tag>Alertmanager</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-冒泡排序</title>
    <url>/2017/03/16/algorithm-bubble/</url>
    <content><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="排序原理"><a href="#排序原理" class="headerlink" title="排序原理"></a>排序原理</h3><p>冒泡排序是将最大或者最小的值先挑出来，然后依次类推，最终使得整个数组有序。比如我们在学校操场排队的时候，老师先叫你站好，站好之后，根据你们的身高找到一个最矮的，排到第一个，然后是第二个，然后这样依次类推…到最后就是一个身高顺序的队伍了。</p>
<p><img src="/images/bubblesort.png"></p>
<span id="more"></span>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">12</span>, <span class="number">35</span>, <span class="number">99</span>, <span class="number">18</span>, <span class="number">76</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - i - <span class="number">1</span>; j++) &#123; <span class="comment">// 如果已经冒泡出来了i个数，则已经有i个数排好序，就无需再比较了 </span></span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j + <span class="number">1</span>]) &#123;<span class="comment">//相邻两个位置交换</span></span><br><span class="line">                    <span class="keyword">int</span> t = a[j];</span><br><span class="line">                    a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                    a[j + <span class="number">1</span>] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个是冒泡排序的代码，第一个for循环，指的是有多少个数需要进行排序；第二个for循环开始交换位置，将小(大)的数一个一个交换到结尾的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123; <span class="comment">// 先确定位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123; <span class="comment">//确定位置的大小</span></span><br><span class="line">                <span class="keyword">if</span> (a[i] &lt; a[j]) &#123; <span class="comment">// 找到第i个位置，然后再第i个位置找到最优值</span></span><br><span class="line">                    <span class="keyword">int</span> t = a[i];</span><br><span class="line">                    a[i] = a[j];</span><br><span class="line">                    a[j] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个代码是我自己写的，也是可以排序，只是这里将a[i]也用作交换基数（上面代码，a[i]没有参与运算），我这个算法貌似也算冒泡吧？</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>冒泡代码实现里面可以看到有两个for循环，时间复杂度为$O(N^2)$，空间复杂度为N。这个意思是什么？假设计算机每秒运行1亿次，对1亿个数排序，冒泡排序需要1亿秒(现代计算机肯定比这个快)。一天是多少秒了？86400秒。排序时间约等于1150天~，因此冒泡排序虽然易懂，很形象，但是一般公司都不会用到它。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-队列</title>
    <url>/2017/03/23/algorithm-queue/</url>
    <content><![CDATA[<h2 id="数据结构-队列"><a href="#数据结构-队列" class="headerlink" title="数据结构-队列"></a>数据结构-队列</h2><blockquote>
<p>程序的开发越来越发现，重要的其实是一些基础的东西。程序=数据结构+算法；这个等式真的越来越让人有感悟。</p>
</blockquote>
<p>今天遇到一个问题，有个妹子告诉了你一串加密后的qq号，解密的规则是第一个数删除第二个数排最后，第三个数删除，第四个数排最后，依次类推到没有一个数可以删除，按照删除的数的顺序就是解密后的qq号码。请问，如果你对妹子有想法的情况下，你该如何解决这个问题了？</p>
<span id="more"></span>
<p>这个问题的解决方式可以用到队列，队列是一个先进先出的数据结构。实现队列的方式有很多，在Java里面可以用数组，或者用list，这种线性结构存储。下面看Java代码实现</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解密qq号</span></span><br><span class="line"><span class="comment"> * 首先将第1个数删除，紧接着将第2个数放到这串数的末尾，</span></span><br><span class="line"><span class="comment"> * 再将第3个数删除并将第4个数再放到这串数的末尾，</span></span><br><span class="line"><span class="comment"> * 再将第5个数删除……直到剩下最后一个数，将最后一个数也删除。</span></span><br><span class="line"><span class="comment"> * 按照刚才删除的顺序，把这些删除的数连在一起就是QQ号了</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Created by alvin on 3/23/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] qqNumber = <span class="keyword">new</span> Integer[]&#123;<span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>&#125;; <span class="comment">//6 1 5 94 7 2 8 3</span></span><br><span class="line">        ArrayList&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : qqNumber) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;加密后qq:&quot;</span> + Arrays.toString(queue.toArray()));</span><br><span class="line">        String qq = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                qq += queue.get(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(queue.get(i));</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;解密后qq:&quot;</span> + qq);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现的不是很优雅，但是应该算是很明了的。ArrayList就是我们要用来做破译的队列。每经过一个数，确认是删除，还是往后面继续排队。在第一个位子设置标记，每往list中增加一个元素，size就会+1，但是标记会一直移动，所以移动到两者相等的时候，即达到终点，这个时候我们就能得到正确的qq号了。</p>
<blockquote>
<p>ps: ArrayList的源码中，实现的方式是一个空的数组{},默认大小为10,ArrayList中有一个ensureCapacity方法来保证容量得到保证。在这个机制下很多人都习惯不设默认值，其实如果你的数据量是均衡的，既你能大概平均预计到最大值的情况下，最好是初始化list的容量，ensureCapacity 这种机制是通过直接将原list拷贝到新list，容量变为(原大小+原大小*2)，然后让引用指向新的list，而之前的旧list就没有用只能等待gc回收。想想看如果你平凡的去这种扩容(想想都浪费啊，程序员都是很抠的，尤其是压榨性能方面~~~)</p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-快速排序</title>
    <url>/2017/03/16/algorithm-quick-sort/</url>
    <content><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>快速排序，听名字就能感觉到主要讲究的就是快速。它其实主要采用分治法，选取基准元，然后把小的放左边，大的放右边，遍历一遍之后就能确定基准元的位置。之后以确定后的基准元位置做左右分割，就是分治了。<br>不说啥，直接上图：<br><img src="/images/Sorting_quicksort.gif" alt="快速排序动态图-wiki"></p>
<span id="more"></span>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chenzhijun on 3/16/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) &#123;   <span class="comment">// 递归程序要有终止条件</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> basic = a[i];  <span class="comment">//设置基准元</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = i;  <span class="comment">// 左右位置</span></span><br><span class="line">        <span class="keyword">int</span> end = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[end] &gt;= basic &amp;&amp; end &gt; start) &#123; <span class="comment">// 必须先从右边先开始，即基数对面</span></span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (basic &gt;= a[start] &amp;&amp; start &lt; end) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (start &lt; end) &#123;   <span class="comment">//交换位置</span></span><br><span class="line">                <span class="keyword">int</span> temp = a[start];</span><br><span class="line">                a[start] = a[end];</span><br><span class="line">                a[end] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a[i] = a[start]; <span class="comment">// 确定基准元的位置</span></span><br><span class="line">        a[start] = basic;</span><br><span class="line">        sort(a, i, start - <span class="number">1</span>);  <span class="comment">// 分割基准元左右两边，找出下一个排序组。   java 非基本类型传递，都是传递的引用传递。地址。</span></span><br><span class="line">        sort(a, end + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/quick-sort.png" alt="啊哈算法的一幅图"></p>
<p>我们在程序的中设置的哨兵就是start和end，这里一定要注意，如果你的基准元是选取的第一个位置或者最后一个位置，那么循坏时候一定的是对面开始。</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>快速排序的空间占用是$O(n)$,最坏情况下时间复杂度为$O(n^2)$,平均情况下是$O(nlogn)$。最坏情况下是怎么出来的呢？当每次分完之后一边是1个元素，一边是n-1个元素，这种情况下，时间复杂度就是最坏的了。至于$O(nlogn)$,这个可以计算出来的，也可以看这篇链接：<a href="http://www.cnblogs.com/pugang/archive/2012/07/02/2573075.html">快速排序算法的时间复杂度分析</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>问题总结</title>
    <url>/2017/07/24/apec-724-problem/</url>
    <content><![CDATA[<h2 id="Java问题总结"><a href="#Java问题总结" class="headerlink" title="Java问题总结"></a>Java问题总结</h2><h3 id="7-14"><a href="#7-14" class="headerlink" title="7-14"></a>7-14</h3><ol>
<li>idea编码不一致</li>
</ol>
<p> A: FileEncoding –&gt;globalEncode&amp;&amp;projectEncoding–&gt;Default encoding for properties UTF-8<br> <em><strong>所有项目尽量一开始就设置UTF-8再导入项目</strong></em></p>
<ol start="2">
<li>idea vim插件冲突的问题，</li>
</ol>
<p>A:直接设置vim emulation。 将handler全部改为ide</p>
<ol start="3">
<li>redis.clients.jedis.exceptions.JedisConnectionException: no reachable node in cluster</li>
</ol>
<p>A: 没有找到可以用的redis集群</p>
<ol start="4">
<li>idea 查看当前类的信息</li>
</ol>
<p>A: <code>alt+Q</code> 可以快速查看当前是哪个类</p>
<ol start="5">
<li>idea ctrl+o 重写某个方法</li>
</ol>
<h3 id="7-15"><a href="#7-15" class="headerlink" title="7-15"></a>7-15</h3><ol>
<li>spring定时任务， CRON表达式  <code>*/5 * * * * ?</code></li>
</ol>
<p> A:<code>CRON</code>的格式是固定的，如果需要在spring中开启定时任务，给类加上<code>@Service</code>注入，然后在方法上加入<code>@Scheduled(cron = &quot;*/5 * * * * ?&quot;)</code>就可以了开启一个定时任务了。</p>
<ol start="2">
<li> java list排序自定义</li>
</ol>
<p> A:如果有需求需要自己给list里面的对象设置排序。可以重写方法。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collections.sort(pushData, (AppTips o1, AppTips o2) -&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               if(o1.getCreateDate().before(o2.getCreateDate()))</span><br><span class="line">               &#123;</span><br><span class="line">                   return 1;</span><br><span class="line">               &#125;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>java传入引用，没有修改值,传入一个list到方法里面，在方法里面修改了list，之后list的值没有改变，引起误解为啥传入对象，修改了对象的值而没有改变对象内容。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class ListTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; a &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        a.add(&quot;adf&quot;);</span><br><span class="line">        a.add(&quot;werwerwe&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; b &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        setB(b);</span><br><span class="line">        System.out.println(b.isEmpty()); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">        setB2(a,b);</span><br><span class="line">        System.out.println(b.isEmpty()); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static void setB(List&lt;String&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        b&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        b.add(&quot;test1&quot;);</span><br><span class="line">        b.add(&quot;tet2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void setB2(List&lt;String&gt; a,List&lt;String&gt; b)&#123;</span><br><span class="line">        b.addAll(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> A: 其实Java除基本类型之外，其他的都为引用传递。这是对的，在上面的例子中，因为在<code>setB</code>中，我们将引用b重新指定到了一个对象<code>new ArrayLsit&lt;&gt;()</code>所以b此时已经不再指向原来的空间了。</p>
<ol start="4">
<li>redis有一个database</li>
</ol>
<p> A: 一开始直接用<code>redis-cli</code>,用<code>keys *</code>发现没有值可以获取，但是代码里面可以获取到值，后来发现其实springboot做了设置<code>redis.database=4</code>。其实在redis客户端里面使用<code>select 4</code>就可以了。</p>
<h3 id="7-21"><a href="#7-21" class="headerlink" title="7-21"></a>7-21</h3><p> 1)requestParam 参数可以放在body里面</p>
<p> 2)nested exception is java.lang.IllegalArgumentException: Not enough variable values available to expand</p>
<p> A: 这个异常耽误了我半天的时间，后来发现其实是restTemplate使用的时候url不要拼接json串，因为它遇到<code>&#123;&#125;</code>会认为是一个变量，然后去解析值。<a href="https://w3stacks.com/questions/spring/70373/using-resttemplate-in-spring-exception-not-enough-variables-available-to-expand">详情</a></p>
]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>Question</tag>
      </tags>
  </entry>
  <entry>
    <title>apec-804-problem</title>
    <url>/2017/08/04/apec-804-problem/</url>
    <content><![CDATA[<h2 id="7月25日问题"><a href="#7月25日问题" class="headerlink" title="7月25日问题"></a>7月25日问题</h2><h3 id="Persistable-QModel生成。"><a href="#Persistable-QModel生成。" class="headerlink" title="Persistable QModel生成。?"></a>Persistable QModel生成。?</h3><p>A: 其实这是一个QSL框架生成的，所有Entity都会生成一个QEntity类。</p>
<h2 id="8月1日问题"><a href="#8月1日问题" class="headerlink" title="8月1日问题"></a>8月1日问题</h2><h3 id="maven-complier-install-package-的区别？"><a href="#maven-complier-install-package-的区别？" class="headerlink" title="maven complier install package 的区别？"></a>maven complier install package 的区别？</h3><p>A:complier只是编译，不会生成jar包，package生成jar包，但是不会将包发布到仓库，只在项目下，install会将jar包发布到仓库让别人也可以用</p>
<h3 id="maven-install-跳过测试"><a href="#maven-install-跳过测试" class="headerlink" title="maven install 跳过测试?"></a>maven install 跳过测试?</h3><p>A: 执行的时候加上 -Dmaven.test.skip=true</p>
<h3 id="jpa-插入枚举值得时候默认为1？"><a href="#jpa-插入枚举值得时候默认为1？" class="headerlink" title="jpa 插入枚举值得时候默认为1？"></a>jpa 插入枚举值得时候默认为1？</h3><p>A:默认使用 ordinal 值，其实应该为string</p>
<h3 id="maven-设置java版本？"><a href="#maven-设置java版本？" class="headerlink" title="maven 设置java版本？"></a>maven 设置java版本？</h3><p>A: pom文件中加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="springboot-使用jrebel热加载？"><a href="#springboot-使用jrebel热加载？" class="headerlink" title="springboot 使用jrebel热加载？"></a>springboot 使用jrebel热加载？</h3><p>A: 现在pom文件里面加入<code>devtools</code>: 之后使用<code>ctrl+alt+shift+/</code>  选中<code>Registry</code>   勾上<code>app.running</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8月3日问题"><a href="#8月3日问题" class="headerlink" title="8月3日问题"></a>8月3日问题</h2><h3 id="SimpleDateFormate-日期格式类使用注意？"><a href="#SimpleDateFormate-日期格式类使用注意？" class="headerlink" title="SimpleDateFormate 日期格式类使用注意？"></a>SimpleDateFormate 日期格式类使用注意？</h3><p>A:日期工具类里面使用了SimpleDataFormate=&gt; format方法里面有个<code>calendar.setTime(date);</code>.<br>如果是多线程中，这个方法没有做同步Thread-A，有一个date，然后Thread-B有一个date，那么造成出现预料之外的结果，当然这种情况出现在共享一个SimpleDateFormate当中，既设置一个全局的simpleDateformat。如果在方法中设置局部变量的simpledateformate，那么局部变量是线程安全的。<br>当然追求效率可以使用ThreadLocal,设置局部缓存</p>
<h3 id="Java-反射获取属性？"><a href="#Java-反射获取属性？" class="headerlink" title="Java 反射获取属性？"></a>Java 反射获取属性？</h3><p>A:注解是分为执行状态（运行，编译），执行位置（类，方法，属性），如果用<code>declared</code>， 包括所有非父类属性。如果不用<code>declared</code>，获取所有为public的属性<br><code>getFields()</code>===&gt; 获取所有属性为public的<br><code>getDeclaredFields()</code>===&gt; 获取所有非继承的数据(public,protect,default….)</p>
]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>Question</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab 安装与配置（一）</title>
    <url>/2018/03/30/code-in-gitlab/</url>
    <content><![CDATA[<p>很多公司都是使用的 svn 来管理代码，其实我感觉 git 肯定是未来的潮流。最近闲暇时间，在公司搭建了一个 GitLab ，正好可以记录一下。</p>
<blockquote>
<p>gitlab 的搭建环境推荐使用 &gt;=4G 内存</p>
</blockquote>
<h2 id="使用-Docker-部署-gitlab"><a href="#使用-Docker-部署-gitlab" class="headerlink" title="使用 Docker 部署 gitlab"></a>使用 Docker 部署 gitlab</h2><p>首先需要安装 Docker。推荐使用docker官网的安装方式：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">Centos 安装docker</a>，如果访问docker官网过于太慢，可以使用DaoCloud下载docker：<a href="https://download.daocloud.io/Docker_Mirror/Docker">daocloud 安装docker</a>。有时候下载镜像，有一些比较显而易见的原因，所以可以使用<a href="https://www.daocloud.io/mirror#accelerator-doc">docker镜像加速器</a>。</p>
<p>安装docker之后，下载镜像<code>gitlab/gitlab-ce:latest</code>，之后参照<a href="https://docs.gitlab.com/omnibus/docker/README.html#run-the-image">安装文档</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">    --hostname gitlab.example.com \</span><br><span class="line">    --publish 443:443 --publish 80:80 --publish 22:22 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart always \</span><br><span class="line">    --volume /srv/gitlab/config:/etc/gitlab \</span><br><span class="line">    --volume /srv/gitlab/logs:/var/log/gitlab \</span><br><span class="line">    --volume /srv/gitlab/data:/var/opt/gitlab \</span><br><span class="line">    gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<p>一个gitlab就搭建好了。**默认的帐号为<code>root</code>**。</p>
<span id="more"></span>

<h3 id="配置邮件服务"><a href="#配置邮件服务" class="headerlink" title="配置邮件服务"></a>配置邮件服务</h3><p>在gitlab的配置目录有个文件：<code>/etc/gitlab/gitlab.rb</code>，编辑这个文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it gitlab vi /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure>

<p>如果你是用的docker方式，看上面的命令，可以编辑本地目录<code>/srv/gitlab/config/gitlab.rb</code>也是可以的，不过需要在docker容器里面进行配置重加载。</p>
<p>安装邮件的文档：<a href="https://docs.gitlab.com/omnibus/settings/smtp.html#doc-nav">配置smtp</a></p>
<p>贴一份在实际中使用的邮件配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab_rails[&#39;gitlab_email_enabled&#39;] &#x3D; true</span><br><span class="line">gitlab_rails[&#39;gitlab_email_from&#39;] &#x3D; &#39;name-gitlab@company.com&#39;</span><br><span class="line">gitlab_rails[&#39;gitlab_email_display_name&#39;] &#x3D; &#39;gitlab邮件通知&#39;</span><br><span class="line">gitlab_rails[&#39;smtp_enable&#39;] &#x3D; true</span><br><span class="line">gitlab_rails[&#39;smtp_address&#39;] &#x3D; &quot;smtp.mxhichina.com&quot;</span><br><span class="line">gitlab_rails[&#39;smtp_port&#39;] &#x3D; 465</span><br><span class="line">gitlab_rails[&#39;smtp_user_name&#39;] &#x3D; &quot;name-gitlab@company.com&quot;</span><br><span class="line">gitlab_rails[&#39;smtp_password&#39;] &#x3D; &quot;email-password&quot;</span><br><span class="line">#gitlab_rails[&#39;smtp_domain&#39;] &#x3D; &quot;ap-ec.cn&quot;</span><br><span class="line">gitlab_rails[&#39;smtp_authentication&#39;] &#x3D; &quot;login&quot; # 认证的方式</span><br><span class="line">gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] &#x3D; true</span><br><span class="line">gitlab_rails[&#39;smtp_tls&#39;] &#x3D; true</span><br><span class="line"></span><br><span class="line">user[&#39;git_user_email&#39;] &#x3D; &quot;name-gitlab@company.com&quot;</span><br></pre></td></tr></table></figure>

<p>安装完邮件后进入到容器中：<code>docker exec -ti gitlab bash</code>，之后使用<code>gitlab-ctl reconfigure</code>进行配置重加载，加载完成后需要进行测试：<code>gitlab-rails console</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Notify.test_email(&#x27;test-email-name@company.com&#x27;, &#x27;Message Subject&#x27;, &#x27;Message Body&#x27;).deliver_now</span><br></pre></td></tr></table></figure>

<p>输入上面的命令如果有新邮件收到，那么邮箱smtp就配置成功。</p>
<blockquote>
<p>如果smtp配置成功，但是注册的时候还是没有邮件发送通知，那么重启一下容器。</p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>迟到的总结</title>
    <url>/2018/01/18/conclusion-2017/</url>
    <content><![CDATA[<p>转眼2017已经过去了，甚至2018也已经过去了18天。如果说今天来做一个2017的总结，我想这是扯的。最近需求已经完了，等资金账户在app的ui弄完，今年到年底过年的需求就只剩下维护了。这些天感触挺多，最大的一个感触就是2018，今年注定不是一个平静的简单的一年。</p>
<span id="more"></span>

<p>去年的一年时间，我从2月份过完年提交辞职信，其实我心里是没谱的。很大的情况是我不知道我该怎样去做。那个时候的我一部分是因为冲冠一怒为红颜，年少的时候，总是有哪股冲动。就这样我辞职了第一份工作，其实我在易宝的日子还是很平凡吧。没有太多的压力，也没有太大的动力。如果说一个人的成长只能应该跟自己有关，我觉得是扯的。它还跟周边所处的环境有关。在易宝，我很感谢很多人。李旦恒，我的技术总监，他的知识面无论是广度和深度都让我对自己有一些重新的认识，相对于他，我简直就是小学在完过家家。邓昌坤，从京东走出来的我们teamleader。他是一个很棒的人，在他的眼里，从来没有办不到的事。这也在以后告诉我，我也能行。真的，那段时间天天跟他坐一辆车回去，很多问题，心里的想法都是他给我解惑。有时候我想想，我真的是“傻”人有“傻”福。邓辉，我在易宝的第一个导师。当我们大家都拿着mac的时候他用着几年前的thinkpad，总让我觉得有股大神的范，其实实际上就是一个逗逼，但是又活得很真实。我觉得逗逼的人，其实心里有时候也会有很多的委屈。笑对也许是最好的方式。汪阳，汪大师。我的第二个导师，我现在有时候看不进书的时候总会回想起他那句话，从前我在新浪的时候，那群哥们就是变态，只有有时间就是啃书，妈的。而且在我一次次遇到问题，搞不定的时候，他总是那么轻轻一瞥，然后说了个这还不简单，巴拉巴拉就弄完了。还有产品天阳，薛雨婷，很多时候一些冷段子就是从他们哪里来的～～。还记得在北京，易大师，胡根深，还有测试bug的曾英姐。很多时候想想如果最舒服的时候，应该就是那段时间了，我来深圳了，离开了大家，联系也少了，但我不会忘记，曾经，我们是朋友，战友，亲爱的人。祝福大家。</p>
<p>2月辞职，3月进klook，刚进客路的第一个月吧，公司拿到了红杉B轮投资，3000万$。现在听说有拿了C轮了，一个很不错的公司。在这里我体会到的是国外的开放式的工作方式和环境。只不过很可惜，如果是用java我想我会一直待下去。但是公司用go当然它也很好，只是目前的我不合适，因为我刚毕业，根基未稳。这可能就是农村孩子的尿性，无法，也没有胆量和后路去拼一把。在客路我学知识的能力感觉是以前的几倍，为什么了？因为啥也不懂。从java转向go，我根本就是一头蒙，所以只要是非工作时间，非吃饭时间，我基本都在看go。现在想想那段时间竟然也是我最充实的时间。因为实在是没有时间和精力去忙其它的了。在客路我学了go，docker。另外还有部分mysql调优。还维护着一个老的ssh项目。这里的人很棒。我长到这么大，这次算是第一次从家里走出省。对，是真正意义上一个人走出省。在客路，我也见识到了自己的渺小，真的是那么渺小。这里很多人都是留学毕业回来，你无法想象，一个一本大学毕业的学生，竟然第一次有了一种不好意思将大学名字说出来的感觉。在长沙我是很自豪的说出来的。不出来见世面，不知道自己的渺小。心中的舞台竟然是那样的小。在客路我经历了开放式办公，所谓的弹性时间办公。其实我也觉得这是一种变相的压力。因为老大不走，底下开发人员就算没有开发任务也不能走(毕竟你也不好意思走)。然后有一次，我走的比较早，在路上遇到同事，他们调侃了一句，xx工作是不是太饱和了，这么早下班。那会我真的是挺尴尬的。因为我回家其实也是看书，或者做一些其它的事。就是想换个环境提高自己。。所以针对这种情况我还是无法理解～～真的。不过这里的扁平话是真的，我们从来没有叫过老大xx总，而且叫他的英文名。甚至遇到公司C位的人，你都可以很直接的跟他们开玩笑，当然，在没有外人的情况下，总之内部是真的扁平，你可以反驳老大，也可以和leader开玩笑，他可能就是你的朋友，而不是说上下级。作为“艺术家”的我，真的很讨厌国企风格的那种上下级关系。当然，这一切都得有个开明的leader。很幸运，客路是的。所以他们成功我觉得是很正常的，火车头好，火车自然能齐心往下越开越远。当然在这里还是有很多的开发压力，不过对于我来说，很享受，有压力的我，我才感觉到我还活着。</p>
<p>后来因为一些私事兜兜转转回长沙，但是后来又一次来深圳。这其中自己的经历算是丰富了。</p>
<p>来深圳后，进入了现在的公司，半扁平化管理，也是一家正在转型的农业行业公司。中农网。当初选它，一方面，是因为自己想为农业行业做点事。作为农民出生，我知道，被农民贱卖的很多大自然的礼物在城市是有多值钱甚至城市的人还求之不来，而且农村的人太穷了。能让他们多一些收入，我感觉那也是一个值得的牛逼的事情。另外选择中农网，其实就是觉得这名字好，中农啊，中国农业～～～我靠，那会感觉瞬间高大上～～～。不犹豫就来了。现在的感受，说好也好，说不完善的地方也有，毕竟在转型中。很多东西都无法完全的实实在在的落地。但是今年年会，明显感觉到了ceo的压力。也感觉到了，今年公司战略的压力，技术中心，今年注定不会是风平浪静。</p>
<p>2018,不管怎样，我陈志军从来不会退缩。我压抑自己，不是不想爆发，而是我知道，现在的我还不足，太多的不足。3年不鸣，一鸣惊人；3年不飞，一飞冲天。但是蜕变注定不会顺利，前路还很漫长，也很坎坷。加油。</p>
]]></content>
  </entry>
  <entry>
    <title>最近总结-2018-07-16</title>
    <url>/2018/07/16/conclusion-2018-07-16/</url>
    <content><![CDATA[<h1 id="最近总结-2018-07-16"><a href="#最近总结-2018-07-16" class="headerlink" title="最近总结-2018-07-16"></a>最近总结-2018-07-16</h1><p>最近公司机房搬迁，大大小小演练，解决问题搞了差不多一个月。在以前的公司其实从来没有遇到过应用搬迁的事情。那个时候还是个开发写代码的。可能有搬迁也不需要我来帮忙，但是这次公司搬迁，从前到后。基本上全程参与。只有一个感受，那就是真的是严谨的要命。</p>
<h2 id="1：演练"><a href="#1：演练" class="headerlink" title="1：演练"></a>1：演练</h2><p>搬迁之前，我们内部就演练了3次，之后申请搬迁后的资源又演练一次，每一次都做了详尽的记录，细微到每一条命令是怎么敲，可以说，拿到文档，就算你啥也不会，你也可以完成。为啥这么细微了，因为有一部分是我的写的文档，写了之后，在下一轮测试演练，拿给别的同事做我的部分。发现他尽然无法完成。这个时候发现，原来我认为的简单，在别人那里是那么复杂。</p>
<span id="more"></span>
<h2 id="2：记录"><a href="#2：记录" class="headerlink" title="2：记录"></a>2：记录</h2><p>在演练的时候会有各种异常，所有人都必须将遇到的异常以及所有异常的原因，解决方法，一一列出。这种情况保证了在异常出现，如果当事人不在，应该怎么处理。</p>
<h2 id="3：协调"><a href="#3：协调" class="headerlink" title="3：协调"></a>3：协调</h2><p>协调指的是协调人员，协调机器。由统一的人负责协调资源，什么时候资源会出来，哪些资源先出来，资源出来后，哪些应用可以先启动。在统筹人员那里都有。甚至连后勤都来了。谁来保证住房，哪些人去订餐。相当于大事小事全都准备好了。</p>
<h2 id="4：时间"><a href="#4：时间" class="headerlink" title="4：时间"></a>4：时间</h2><p>在开始切换前，先做一次正式环境测试，跑通所有应用。这个时候拿的都是一期的环境和配置，二期只是再重新部署一遍。第一次跑通之后开始切换，提前在官网发出声明，通知相应的切换人员，网络组，主机组，容器组等。之后再将所有的人员统一在办公环境办公，有问题及时解决，然后按照预定好的时间1——3点主机切换，2-4点网络切换，3点应用停掉一期，DB断开所有连接，。。。切换DB，启动应用…一步一步。基本上不会出错。</p>
<h2 id="5：复查验证"><a href="#5：复查验证" class="headerlink" title="5：复查验证"></a>5：复查验证</h2><p>保证所有切换的应用都是可用的。必须是所有应用，然后才是所有人完成搬迁。</p>
<p>总体来说，每一个细节都会照顾到，而且在正式搬迁之前需要进行多次验证，多次演练，之后在正式搬迁的时候才能将风险降到最低。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>conclusion-201809</title>
    <url>/2018/09/08/conclusion-201809/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>1: linux命令行替换文本中的字符串。<code>sed -i &quot;s/100.69.224.18:10099/100.69.224.27:9999/g&quot; /file.xml</code></p>
<p>2: rancher平台的相关监控。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql:</span><br><span class="line"></span><br><span class="line">获取mysql用户是否可以远程登陆</span><br><span class="line">CREATE USER &#39;exporter&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;exporter&#39;;</span><br><span class="line">GRANT PROCESS, REPLICATION CLIENT ON *.* TO &#39;exporter&#39;@&#39;localhost&#39;;</span><br><span class="line">GRANT SELECT ON cattle.* TO &#39;exporter&#39;@&#39;%&#39; with MAX_USER_CONNECTIONS 3;</span><br><span class="line">help flush;</span><br><span class="line">show grants for &#39;exporter&#39;@&#39;localhost&#39;;</span><br><span class="line">flush PRIVILEGES;</span><br><span class="line"></span><br><span class="line">docker run -d -p 9104:9104 -e DATA_SOURCE_NAME&#x3D;&quot;exporter:exporter@(127.0.0.1:3306)&#x2F;&quot; prom&#x2F;mysqld-exporter:latest</span><br><span class="line"></span><br><span class="line">haproxy:</span><br><span class="line"></span><br><span class="line">docker run -d -p 9101:9101 prom&#x2F;haproxy-exporter:latest --haproxy.scrape-uri&#x3D;&quot;http:&#x2F;&#x2F;www.haproxy.com&#x2F;haproxy?stats;csv&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3: sort 根据低三列排序</p>
<p>docker stats -a –no-stream |awk ‘{print $1,$8,$3,$4}’|sort -k 2,4n</p>
<p>sort -k a,bn<br>a为第几列，b为几个字符，n为数字比较，1234，1222，从第一个字符开始，到第四个字符都会比较</p>
<p>4: 给基础镜像安装常用工具：ping,curl,wget,netstat。一般源里面就已经包含了，ping的源为：<code>apt install inetutils-ping或者 apt install net-tools</code></p>
<p>5：某次给rancher平台扩容，直接将主机加上之后，将原来的应用直接*2启动，平台爆掉了。server不到。</p>
]]></content>
  </entry>
  <entry>
    <title>修改 Linux Core 文件目录</title>
    <url>/2019/05/08/core-file/</url>
    <content><![CDATA[<h1 id="Linux-Core-文件"><a href="#Linux-Core-文件" class="headerlink" title="Linux Core 文件"></a>Linux Core 文件</h1><p>一次线上的经历，一台现在主机突然磁盘根目录占到98%。我们其实是挂了数据盘的，不知道为啥突然会<br>在根目录下磁盘空空间不足报警。上到主机一看，原来是某个应用打了dump了个core文件。文件如：core.xxxx</p>
<p>用gdb调试了一下：</p>
<p><code>gdb core.14321</code></p>
<p>显示出是哪个进程dump的core文件。</p>
<p>之后我们就开始分析core文件怎么避免让根目录占满。</p>
<p>首先用<code>ulimit -a</code>查看到core文件的大小。然后用<code>ulimit -c</code>设置大小，单位是block，<br>1block=512bytes</p>
<p>然后修改core文件到数据盘的目录：</p>
<p><code>echo /data/coredump/core.%e.%p&gt; /proc/sys/kernel/core_pattern</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 文件处理接口</title>
    <url>/2019/05/24/create-springboot-file-download-api/</url>
    <content><![CDATA[<h1 id="Spingboot-下载文件"><a href="#Spingboot-下载文件" class="headerlink" title="Spingboot 下载文件"></a>Spingboot 下载文件</h1><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p>有时候会遇到一些需求，需要给前端提供下载文件的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@GetMapping(&quot;/export&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Resource&gt; <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HSSFWorkbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">        ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream()</span><br><span class="line">        workbook.write(outputStream);</span><br><span class="line">        Resource file = <span class="keyword">new</span> ByteArrayResource(outputStream.toByteArray());</span><br><span class="line">        String filename=<span class="string">&quot;app.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION,</span><br><span class="line">                <span class="string">&quot;attachment; filename=&quot;</span>+filename).body(file);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>可以看到我创建了一个 Resource 然后返回了这个 resource。感觉是不是超级简单。确实比较简单，不过如果这个接口在外层还有一个应用参数拦截层（输入参数和返回参数都json打印）的话，需要注意将参数序列化成json数据的时候，这里是会出异常。</p>
<p>上面的代码中就是流的转换了，让我想起了java中的io流装饰器模式。</p>
<p>在上面的代码中主要注意在返回的head里面需要加入<code>header(HttpHeaders.CONTENT_DISPOSITION,&quot;attachment; filename=&quot;+filename)</code>;这里的filename就是下载后的文件名。</p>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/file&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleFileUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String originalFilename = file.getOriginalFilename();</span><br><span class="line">    System.out.println(originalFilename);</span><br><span class="line">    System.out.println(file.getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String string = Base64.getEncoder().encodeToString(file.getBytes());</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;emmmmmmm. error&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有下载当然有上传了， 上面就是将文件上传的操作。</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构单链表的一些简单操作</title>
    <url>/2019/09/09/datastruct-list-normal-action/</url>
    <content><![CDATA[<h1 id="数据结构单链表的一些简单操作"><a href="#数据结构单链表的一些简单操作" class="headerlink" title="数据结构单链表的一些简单操作"></a>数据结构单链表的一些简单操作</h1><p>Node的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node nextNode;</span><br><span class="line">    <span class="keyword">private</span> T v;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node nextNode, T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextNode = nextNode;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextNode</span><span class="params">(Node nextNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setV</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllNode</span><span class="params">()</span> </span>&#123;<span class="comment">//我这里是有一个headNode不做数据存储</span></span><br><span class="line">        Node tmpN = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmpN.getNextNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(tmpN.getNextNode().getV());</span><br><span class="line">            System.out.print((tmpN.getNextNode().getNextNode() == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;,&quot;</span>));</span><br><span class="line">            tmpN = tmpN.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>平常一条链表大多是<code>a-&gt;b-&gt;c-&gt;d</code>;链表反转后为:<code>a&lt;-b&lt;-c&lt;-d</code>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.gk_time_datastruct.chapter7;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node();</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node();</span><br><span class="line">            newNode.setV(i);</span><br><span class="line">            tmp.setNextNode(newNode);</span><br><span class="line">            tmp = tmp.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">        head.printAllNode();</span><br><span class="line">        System.out.println();</span><br><span class="line">        Node node = reverseNode(head);</span><br><span class="line">        node.printAllNode();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表实际的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">reverseNode</span><span class="params">(Node pHead)</span> </span>&#123;</span><br><span class="line">        Node prev = <span class="keyword">null</span>;</span><br><span class="line">        Node pNode = pHead.getNextNode();</span><br><span class="line">        <span class="keyword">while</span> (pNode!= <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = pNode.getNextNode();</span><br><span class="line">            pNode.setNextNode(prev);</span><br><span class="line">            prev = pNode;</span><br><span class="line">            pNode = next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node reverseNode = <span class="keyword">new</span> Node();</span><br><span class="line">        reverseNode.setNextNode(prev);</span><br><span class="line">        <span class="keyword">return</span> reverseNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先用<code>prev</code>，<code>pNode</code>作两个指针，prev 指的是前一个node，pNode 是指当前node。可以这样理解，pNode指向链表遍历时的当前node，prev指向pNode的链条中前一个节点。</p>
<p>我们先用一个临时变量<code>next</code>存储当前pNode的下一个节点位置，然后将当前pNode的位置反转，设置为prev的位置，然后prev移动到pNode的位置上，这样pNode的这个位置就存在了prev，所以pNode可以继续向下遍历节点，而我们之前刚好将pNode的下一个节点存储在了next临时变量中，所以有 pNode=next ；一直遍历到pNode为null，说明链表已经遍历完了。这时如果不喜欢头节点就可以直接返回prev，如果喜欢设置头节点，就可以new一个新节点，然后将nextNode设置为prev。这样一条新的链就完成了，链表就被反转了。</p>
<p>一开始初始化，普通链表：</p>
<p><img src="/images/qiniu/2019-09-09-20-04-33.png" alt="2019-09-09-20-04-33"></p>
<p>之后我们开始做操作，先获取0-next节点位置，然后将1-nextNode指向prev所指向的位置，之后2-prev指向pNode所指向的位置，之后3-pNode指向next。</p>
<p><img src="/images/qiniu/2019-09-09-20-15-02.png" alt="2019-09-09-20-15-02"></p>
<p>这样一直循环后，我们就可以实际得到一个反转如下的链表：</p>
<p><img src="/images/qiniu/2019-09-09-20-20-10.png" alt="2019-09-09-20-20-10"></p>
<p>可以看到，其实如果直接返回prev就已经是一个反转链表了。</p>
<p>复杂度分析：</p>
<p>时间复杂度：O(n)，取决与链表长度；</p>
<p>空间复杂度：O(1)，只新建了pNode,next,prev指针变量,没有额外空间的；</p>
<h2 id="两个排序链表的合并"><a href="#两个排序链表的合并" class="headerlink" title="两个排序链表的合并"></a>两个排序链表的合并</h2><p>链表的操作中还有一个是假设两个有序链表的合并，如果[1,3,5],[2,4,6,7]合并为[1,2,3,4,5,6,7]，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">mergeNode1AndNode2</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node();</span><br><span class="line">        Node head = node;</span><br><span class="line">        Node tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>) head1.getV() &lt; (<span class="keyword">int</span>) head2.getV()) &#123;</span><br><span class="line">                tmp = head1;</span><br><span class="line">                head1 = head1.getNextNode();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp = head2;</span><br><span class="line">                head2 = head2.getNextNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node.setNextNode(tmp);</span><br><span class="line">            node = node.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        if (head1 != null) &#123;</span></span><br><span class="line"><span class="comment">//            node.setNextNode(head1);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (head2 != null) &#123;</span></span><br><span class="line"><span class="comment">//            node.setNextNode(head2);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        node.setNextNode(head1 != <span class="keyword">null</span> ? head1 : head2);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们肯定都是要循环链表的，那么循环到一个链表为空的时候，将另一个链表的值加进来即可。</p>
<p>如<code>while (head1 != null &amp;&amp; head2 != null)</code>这里就是判断链表1和链表2两者看是否为空。如果有一个为空的条件，就退出循环。</p>
<p>你可能看到<code>node.setNextNode(head1 != null ? head1 : head2);</code>这句话的作用其实就是说，如果head1不为空，那我们就将head1加入到设置为nextNode，反之就是head2。</p>
<p>合并两个列表的关键点在于，一个要判断两个链表是否为空，这是退出链表循环的条件。（当然如果是个循环链表，这里可能就得改一下了）。另外就是，当链表退出后，要记得将另一个非空链表的剩余值加入到新链中，保证不丢值。</p>
<h2 id="删除链表倒数第-n-个结点"><a href="#删除链表倒数第-n-个结点" class="headerlink" title="删除链表倒数第 n 个结点"></a>删除链表倒数第 n 个结点</h2><p>有一个链表，然后需要删除链表的倒数第n个位置的节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除倒数第n个位置的node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">removeNode</span><span class="params">(Node node, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || node.getNextNode() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i为0或者node为空，不改动，i从1开始&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node tmp = node;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = tmp.getNextNode();</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//长度不够</span></span><br><span class="line">            System.out.println(<span class="string">&quot;node长度不够,不改动&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    Node n0 = node;</span><br><span class="line">    Node n1 = node;</span><br><span class="line">    <span class="comment">//两个指针，一个先走i步，另一个再开始走</span></span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp = tmp.getNextNode();</span><br><span class="line">        n0 = n1;</span><br><span class="line">        n1 = n1.getNextNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n0.setNextNode(n1.getNextNode());</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="链表中间节点"><a href="#链表中间节点" class="headerlink" title="链表中间节点"></a>链表中间节点</h2><p>计算链表中间节点位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">computeNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node quick = head.getNextNode();</span><br><span class="line">    Node slow = head.getNextNode();</span><br><span class="line">    <span class="keyword">while</span> (quick != <span class="keyword">null</span> &amp;&amp; quick.getNextNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.getNextNode();</span><br><span class="line">        quick = quick.getNextNode().getNextNode();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(slow.getV());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="是否为循环链表"><a href="#是否为循环链表" class="headerlink" title="是否为循环链表"></a>是否为循环链表</h2><p>判断一个链表是否为循环链表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCycleList2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(head);</span><br><span class="line">            head = head.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCycleList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node n1 = head;</span><br><span class="line">    Node n2 = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="keyword">null</span> &amp;&amp; n2.getNextNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n1 = n1.getNextNode();</span><br><span class="line">        n2 = n2.getNextNode().getNextNode();</span><br><span class="line">        <span class="keyword">if</span> (n1 == n2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序算法</title>
    <url>/2019/09/10/datastruct-normal-sort-algorithm/</url>
    <content><![CDATA[<h1 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h1><p>每次一看算法就是，嗯，看懂了，每次自己写代码就是，嗯？这怎么写？？ 本文将自己理解的冒泡排序，插入排序，选择排序三种做一个总结。</p>
<span id="more"></span>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序其实很形象，就是每次选最大，或者最小的值，与第一个值交换，逐次冒泡。就像水里面的泡泡，轻的泡泡总会浮起来一样。</p>
<p>实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubblingSort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> an : a) &#123;</span><br><span class="line">            System.err.print(an + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设有原始数组a,每次冒泡的结果就如下，我们这里选的是从大到小冒泡：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第0次:</span><br><span class="line">12	1	5	7	9	3	5	</span><br><span class="line">第1次:</span><br><span class="line">12	9	1	5	7	3	5	</span><br><span class="line">第2次:</span><br><span class="line">12	9	7	1	5	3	5	</span><br><span class="line">第3次:</span><br><span class="line">12	9	7	5	1	3	5	</span><br><span class="line">第4次:</span><br><span class="line">12	9	7	5	5	1	3	</span><br><span class="line">第5次:</span><br><span class="line">12	9	7	5	5	3	1	</span><br><span class="line">第6次:</span><br><span class="line">12	9	7	5	5	3	1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>冒泡排序的时间复杂度为O(n^2) ; 空间复杂度为O(1);是一个稳定算法。</p>
<blockquote>
<p>稳定的意义是指，两个相同的数据，它们排序完之后相对位置不变，比如上面数组的5[a],5[b],排序完之后不会出现5[b],5[a]; a,b为他们的相对位置。</p>
</blockquote>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的意思就是有一个数组，你可以假定左边的部分是有序的，这个时候你从右边无序的数据中，找出一个，然后将其插入到有序数据的数组中。<br>有点类似打扑克，如果一次性将牌发完，你总得给牌排个序吧，比如从左到右，左边第一张你可以假设这一张是有序的，从第二张开始，你就比较一下第二张和第一张谁大，小的就往前面移动，大的就往后面移动。如果是第三张，依次与第二张比，比完再与第一张比。所以第n张就是与n-1比，再与n-2,n-3，…比较，一直比到有一张比它小的，那么这个时候，就位置就对了。看起来就像是我们将第n张牌，插入到了之前有序的一个数组中。</p>
<p>算法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] b = insertSort(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次,&quot;</span> + <span class="string">&quot;arr[i]为:&quot;</span> + arr[i] + <span class="string">&quot; :&quot;</span>);</span><br><span class="line">        printArr(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printArr(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1次,arr[i]为:7 :</span><br><span class="line">1	7	5	9	12	3	5</span><br><span class="line">1	7	5	9	12	3	5</span><br><span class="line">第2次,arr[i]为:5 :</span><br><span class="line">1	7	5	9	12	3	5</span><br><span class="line">1	5	7	9	12	3	5</span><br><span class="line">第3次,arr[i]为:9 :</span><br><span class="line">1	5	7	9	12	3	5</span><br><span class="line">1	5	7	9	12	3	5</span><br><span class="line">第4次,arr[i]为:12 :</span><br><span class="line">1	5	7	9	12	3	5</span><br><span class="line">1	5	7	9	12	3	5</span><br><span class="line">第5次,arr[i]为:3 :</span><br><span class="line">1	5	7	9	12	3	5</span><br><span class="line">1	3	5	7	9	12	5</span><br><span class="line">第6次,arr[i]为:5 :</span><br><span class="line">1	3	5	7	9	12	5</span><br><span class="line">1	3	5	5	7	9	12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>插入牌的时间复杂度为：O(n^2), 空间复杂度为O(1), 是一个稳定排序算法。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序其实就是你拿了一手牌，每次你扫描一遍，拿到最小的那张，把它跟第一张交换下位置。第一次交换第一张位置的，第二次交换第二张位置的，之后依次交换到最后一张。这个咋一看挺像冒泡的，但是远离不相同，冒泡是每次都会有顺移的操作，比如<code>2,3,4,5,1</code>；如果你选了1，它要跟5做比较，交换：<code>2,3,4,1,5</code>；跟4做比较，交换<code>2,3,1,4,5</code>。而选择排序则是：<code>2,3,4,5,1</code>；你先选最小的1，然后跟第一个位置的2做交换变成了<code>1,3,4,5,2</code>,有没有发现，其实只做了一次交换。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] b = selectSort(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;<span class="comment">//初始化j的位置</span></span><br><span class="line">        <span class="keyword">int</span> k = j;<span class="comment">//数组中值最小的数的位置</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];<span class="comment">//用来存储每次遍历的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (; j &lt; arr.length; j++) &#123;<span class="comment">//遍历数组从i开始，0-i之间的数据可以当做是已经选择了最小的有序数组</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; tmp) &#123;</span><br><span class="line">                tmp = arr[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[k] = arr[i];<span class="comment">//交换当前i的位置和最小值的位置k两个数据</span></span><br><span class="line">        arr[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序算法的时间复杂度为：O(n^2);空间复杂度为：O(1); 稳定性为：不稳定。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序算法</title>
    <url>/2019/09/13/datastruct-normal-sort-algorithm2/</url>
    <content><![CDATA[<h1 id="基础排序算法2"><a href="#基础排序算法2" class="headerlink" title="基础排序算法2"></a>基础排序算法2</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的意义是将利用递归的思想，将一个大问题解决为可重复求解的小问题，最后合并这些小问题得出结果。<br>归并是直接数组对半分，分成两个子数组。然后对两个子数组再进行排序求解。</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序：对半分成两个子数组，然后子数组再向下分，之后合并数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="number">1</span> / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        mergeSort2(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//        mergeSort(a, 0, a.length - 1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> middle = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        mergeSort2(arr, start, middle);</span><br><span class="line">        mergeSort2(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">        merge2(arr, start, middle, end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> middle, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用来存储的临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//p q 两个指针，遍历arr</span></span><br><span class="line">        <span class="keyword">int</span> p = start;</span><br><span class="line">        <span class="keyword">int</span> q = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//[0 , middle] 和 [middle+1 , end] 的数据分别赋值给新数组</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt;= middle &amp;&amp; q &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[p] &lt;= arr[q]) &#123;</span><br><span class="line">                newArr[i++] = arr[p++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newArr[i++] = arr[q++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两边谁还有剩余的数</span></span><br><span class="line">        <span class="comment">//1 假设左边有剩余的数</span></span><br><span class="line">        <span class="keyword">int</span> p1 = p;</span><br><span class="line">        <span class="keyword">int</span> q1 = middle;</span><br><span class="line">        <span class="comment">//2 判断是不是左边真的有剩余，下面的if可以判断出右边是不是有剩余，while中只会有一边清空时才会退出while</span></span><br><span class="line">        <span class="keyword">if</span> (q &lt;= end) &#123;</span><br><span class="line">            p1 = q;</span><br><span class="line">            q1 = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将剩余的数填满新数组</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= q1) &#123;</span><br><span class="line">            newArr[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将新数组（已排序）的值替换老数组的位置</span></span><br><span class="line">        <span class="comment">//这里要注意start-end之间的个数其实就是newArr数组的个数为end-start , 所以这里只能让idx最大为end-start 也相当于为循环end-start次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt;= end - start; idx++) &#123;</span><br><span class="line">            arr[idx + start] = newArr[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, start, q);</span><br><span class="line">        mergeSort(arr, q + <span class="number">1</span>, end);</span><br><span class="line">        merge(arr, start, q, end);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> middle, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmps = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = start;</span><br><span class="line">        <span class="keyword">int</span> q = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= middle &amp;&amp; q &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[p] &lt;= arr[q]) &#123;</span><br><span class="line">                tmps[i] = arr[p];</span><br><span class="line">                p++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmps[i] = arr[q];</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i1 = p;</span><br><span class="line">        <span class="keyword">int</span> j1 = middle;</span><br><span class="line">        <span class="keyword">if</span> (q &lt;= end) &#123;</span><br><span class="line">            i1 = q;</span><br><span class="line">            j1 = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i1 &lt;= j1) &#123;</span><br><span class="line">            tmps[i] = arr[i1];</span><br><span class="line">            i1++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= end - start; ++j) &#123;</span><br><span class="line">            arr[start + j] = tmps[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>也是归并排序的一种，不过快排采用的是先分区，再归并。快排采用的是找一个基准点，然后比较数组中数据的基准点找出分割点，以分割点来割分子数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快排序的思想就是,同一个数组,不需要额外的空间,</span></span><br><span class="line"><span class="comment"> * 最重要的部分是找出每个数据的应该放置的位置，这个位置的左边全小于它，右边全大于它，</span></span><br><span class="line"><span class="comment"> * 它是一个分割点，然后依次类推，每个数据都放到一个这样的位置，数组就拍好顺序了。</span></span><br><span class="line"><span class="comment"> * 快排序：O(nlogn)</span></span><br><span class="line"><span class="comment"> * 空间：O(1)</span></span><br><span class="line"><span class="comment"> * 稳定性：不稳定，因为两两交换嘛。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="number">1</span> / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = quickSortN2(arr, start, end);</span><br><span class="line"><span class="comment">//        int n = quickSortN3(arr, start, end);</span></span><br><span class="line">        quickSort(arr, start, n - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, n + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取末尾为参考值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickSortN2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[end];<span class="comment">//要从尾部取这个参照点</span></span><br><span class="line">        <span class="keyword">int</span> p = start;<span class="comment">//定一个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = start; q &lt;= end - <span class="number">1</span>; q++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[q] &lt; pivot) &#123;<span class="comment">//将p留在永远大于参考点的第一个位置</span></span><br><span class="line">                swap(arr, p, q);</span><br><span class="line">                p++;<span class="comment">//顺着左移，保持第一个位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**已经遍历完了p的位置，左边是小于参考点的数据，</span></span><br><span class="line"><span class="comment">         右边是大于参考点的数据，p的位置存放参考点，</span></span><br><span class="line"><span class="comment">         该位置就刚好变成了一个分割点。将一个大的分解了两个子问题，</span></span><br><span class="line"><span class="comment">         而子问题也可以重复刚刚的步骤，最后所有的数据都会待在那个最</span></span><br><span class="line"><span class="comment">         合适的位置，最后的顺序也就排列好了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        swap(arr, p, end);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[p];</span><br><span class="line">        arr[p] = arr[q];</span><br><span class="line">        arr[q] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选第一个为参考值。注意返回的p-1的值</span></span><br><span class="line"><span class="comment">     * 比选最后一个值为参考值多了几次+,-的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickSortN3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">        <span class="keyword">int</span> p = start + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = start + <span class="number">1</span>; q &lt;= end; q++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[q] &lt; pivot) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[q];</span><br><span class="line">                arr[q] = arr[p];</span><br><span class="line">                arr[p] = temp;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p的位置是大于参考点的,因此要交换p-1的位置</span></span><br><span class="line">        swap(arr, start, p - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> p - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一版本（错误方法）</span></span><br><span class="line"><span class="comment">     * 有bug，当出现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * [8,1,9,12,6,0]  p=0;q=0</span></span><br><span class="line"><span class="comment">     * a: 1,8,9,12,6,0   p=1;q=1</span></span><br><span class="line"><span class="comment">     * b: 1,6,9,12,8,0   p=2;q=4</span></span><br><span class="line"><span class="comment">     * c: 1,6,0,12,8,9   p=3;q=5</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个时候返回p=3,最终的结果肯定不正确。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickSortN</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">        <span class="keyword">int</span> p = start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = start; q &lt;= end; q++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[q] &lt; pivot) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[q];</span><br><span class="line">                arr[q] = arr[p];</span><br><span class="line">                arr[p] = temp;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        arr[p] = pivot;</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>桶排序的一种特殊方式，数据必须是非负整数。桶排序的方式是将数据最小值和最大值均分为多个桶，把数据放到桶里面，然后依次取出桶中的数据。计数排序的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        countSort(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数排序就是遍历原始数组A找到最大值，然后以（最大值+1）的长度建立一个新数组B</span></span><br><span class="line"><span class="comment">     * 遍历数组A,每遍历A的一个数据a，在B中a的位置就+1；B[a]=B[a]+1</span></span><br><span class="line"><span class="comment">     * 遍历数组B获取B[a]之前[0-a]的所有数据个数，目前A中已经遍历过一次了，A中的数</span></span><br><span class="line"><span class="comment">     * 据在B中对应的下标中都会有值，统计B中a之前的所有个数，这样我们就能知道A中的数</span></span><br><span class="line"><span class="comment">     * 据a在A数组中应该在哪个位置。B遍历完之后，就相当于知道了a和小于a的所有数据的</span></span><br><span class="line"><span class="comment">     * 个数之和。</span></span><br><span class="line"><span class="comment">     * 新建一个数组C,长度和A一致，我们遍历一下A，取出数据A[i],数据A[i]在C中的位置</span></span><br><span class="line"><span class="comment">     * 应该为在数组B[A[i]]的值，即小于或等于数据A[i]的个数，之后将C[B[A[i]]-1]赋值为A[i]；</span></span><br><span class="line"><span class="comment">     * B[A[i]]为个数</span></span><br><span class="line"><span class="comment">     * B[A[i]]-1为数组实际下边，数组从0开始</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrA</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arrA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = arrA[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrA.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrA[i] &gt; max) &#123;</span><br><span class="line">                max = arrA[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arrB = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//第一步是找出相同值的个数，比如数组里面5的数据，有2个，那么newA中第5个位置为2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrA.length; i++) &#123;</span><br><span class="line">            arrB[arrA[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算数组中当前位置的数据有几个，比如数组中5的数据，那么从0-5，总共有多少个数字了？</span></span><br><span class="line">        <span class="comment">// 这个for循环就是计算总共的数字。计算出数字了之后，我们就知道，5在数组中顺序的位置了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arrB.length; i++) &#123;</span><br><span class="line">            arrB[i] = arrB[i] + arrB[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个新数组，长度跟要排序的数组一样，当我们遍历一下要排序数组，取出里面的数据</span></span><br><span class="line">        <span class="comment">//根据取出的值，在newA中下表为值的位置取出个数,就是这个新数组的位置。</span></span><br><span class="line">        <span class="keyword">int</span>[] arrC = <span class="keyword">new</span> <span class="keyword">int</span>[arrA.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrC.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> position = arrB[arrA[i]] - <span class="number">1</span>;<span class="comment">//arrB 里面存储的是个数，在新数组就是位置，减1是因为从0计算嘛，所以减1</span></span><br><span class="line">            arrC[position] = arrA[i];<span class="comment">// position 位置要等于arr[i]，取出了一个值所以就</span></span><br><span class="line">            arrB[arrA[i]]--;<span class="comment">//取出一个数据了，个数就少一个了。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrA.length; i++) &#123;</span><br><span class="line">            arrA[i] = arrC[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="几种基础排序算法比较"><a href="#几种基础排序算法比较" class="headerlink" title="几种基础排序算法比较"></a>几种基础排序算法比较</h2><p><img src="/images/qiniu/2019-09-13-19-14-25.png" alt="几种基础排序算法比较"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>dev-ops</title>
    <url>/2019/03/31/dev-ops/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Docker 容器</title>
    <url>/2017/05/13/docker-container/</url>
    <content><![CDATA[<h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>容器是 Docker 的另一个核心概念</p>
<blockquote>
<p>容器是镜像的一个运行实例，所不同的是，它带有额外的可写文件层</p>
</blockquote>
<h3 id="1-创建容器"><a href="#1-创建容器" class="headerlink" title="1,创建容器"></a>1,创建容器</h3><p><code>docker create -it centos:latest</code> 新建的容器处于停止状态，可以用 <code>docker start</code> 命令来启动它。</p>
<h3 id="2-新建并启动容器"><a href="#2-新建并启动容器" class="headerlink" title="2,新建并启动容器"></a>2,新建并启动容器</h3><p><code>docker run centos /bin/echo &#39;Hello world&#39;</code> ，输出了Hello world,之后就没了,使用 <code>docker ps</code> 看不到容器运行。</p>
<span id="more"></span>
<p>Docker 后台的操作分解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 检查本地是否存在指定的镜像，不存在就从共有仓库下载</span><br><span class="line">* 利用镜像创建并启动一个容器</span><br><span class="line">* 分配一个文件系统，并在只读的及各项层外面挂载一层可读写层</span><br><span class="line">* 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</span><br><span class="line">* 从地址池配置一个IP地址给容器</span><br><span class="line">* 执行用户指定的应用程序</span><br><span class="line">* 执行完毕后容器被终止</span><br></pre></td></tr></table></figure>

<p><code>docker run -ti ubuntu:latest /bin/bash</code>  ，在容器内部运行ps命令，可以看到只有bash应用 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-t 让Docker分配一个伪终端并绑定到容器的标准输入上</span><br><span class="line">-i 则让让其的标准输入保持打开</span><br></pre></td></tr></table></figure>
<p>用exit退出后，容器也停止运行，处于终止状态。</p>
<h4 id="2-1-守护态运行"><a href="#2-1-守护态运行" class="headerlink" title="2.1,守护态运行"></a>2.1,守护态运行</h4><p>很多时候需要让Docker容器在后台以守护态形式运行，用户可以通过添加<code>-d</code>参数来实现。<br><code>docker run -d ubuntu /bin/sh -c &quot;while true;do echo hello world;sleep 1;done&quot;</code>,会生成一个id。<br>之后用<code>docker logs id</code>就能看到记录日志。</p>
<h3 id="2-2-重启容器"><a href="#2-2-重启容器" class="headerlink" title="2.2,重启容器"></a>2.2,重启容器</h3><p><code>docker restart container</code>，会将一个运行态的容器终止，然后重新启动它。</p>
<h3 id="3-终止容器"><a href="#3-终止容器" class="headerlink" title="3,终止容器"></a>3,终止容器</h3><p><code>docker stop [-t|--time[=10]] container</code>，它会先向容器发送SIGTERM信号，等待-t秒后（默认10秒），再发送SIGKILL信号</p>
<h3 id="4-进入容器"><a href="#4-进入容器" class="headerlink" title="4,进入容器"></a>4,进入容器</h3><p>使用<code>-d</code>参数后，容器进入后台运行。有时候需要计入到容器里面进行操作，可以使用<code>docker attach </code> ,<code>docker exec </code>等命令。</p>
<p>a) attach 进入到容器<br><code>docker attach 65bde56eaf56-容器id</code>,<code>attach</code> 命令进入到容器里面，不过要首先启动容器，另外当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时，其它窗口也无法执行操作。</p>
<p>b) exec 进入到容器<br>docker 1.3之后，提供了一个更方便的工具exec，可以直接在容器内运行命令。<br><code>docker exec -ti 65bde56eaf56[|container-name] /bin/bash[|bash|other-command]</code>可以很方便的进入到容器里面</p>
<h3 id="5-删除容器"><a href="#5-删除容器" class="headerlink" title="5,删除容器"></a>5,删除容器</h3><p><code>docker rm [OPTIONS] container-id1[|container-name1] container-id2[|container-name2]</code> ,删除处于停止运行的容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* -f, --force&#x3D;false 强行终止并删除一个运行中的容器</span><br><span class="line">* -l, --link&#x3D;false 删除容器的连接，但保留容器</span><br><span class="line">* -v, --volumes&#x3D;fasle 删除容器挂载的数据卷</span><br></pre></td></tr></table></figure>

<h3 id="6，导入和导出容器"><a href="#6，导入和导出容器" class="headerlink" title="6，导入和导出容器"></a>6，导入和导出容器</h3><p>a) 导出容器<br>导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export 命令<code>dcoker export container</code>.<br><code>docker export container-id[|container-name] &gt; test_export.tar</code>;<br>可以将导出的文件传输到其它机器上，在其它机器上通过导入命令实现容器的迁移。</p>
<p>b) 导入容器<br>可以将导出的文件又导入，成为镜像<br><code>cat test_export.tar | docker import - test/ubuntu:v1.0</code></p>
<blockquote>
<p>之前的导入镜像和这个有点类似。实际上，既可以使用docker load 命令来导入镜像存储文件到本地的镜像库，也可以使用docker import 命令来导入一个容器快照到本地镜像库。两者的却别在于容器快照文件将丢弃所有的历史记录和元数据（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新制定标签等元数据信息。docker load是在之前save的时候镜像信息是什么，load之后也是同样的。</p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 数据管理</title>
    <url>/2017/05/13/docker-data/</url>
    <content><![CDATA[<blockquote>
<p>Docker 的数据管理应该核心中的核心。因为不管哪个公司，数据应该永远是第一位。</p>
</blockquote>
<h3 id="1-Docker-数据卷简介"><a href="#1-Docker-数据卷简介" class="headerlink" title="1,Docker 数据卷简介"></a>1,Docker 数据卷简介</h3><p>Docker 的数据卷是一个可供容器使用的特殊目录，它绕过文件系统，提供很多的特性:</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>卷会一直存在，直到没有容器使用<br>数据卷的使用，类似于Linux下对目录或文件进行mount操作。<span id="more"></span>
<h3 id="2-容器内建数据卷"><a href="#2-容器内建数据卷" class="headerlink" title="2,容器内建数据卷"></a>2,容器内建数据卷</h3>使用<code>docker run</code>命令的时候，使用<code>-v</code>标记可以在容器内创建一个数据卷，多次使用-v标记可以创建多个数据卷。<br><code>docker run -d -P --name web -v /webdata centos /bin/bash</code>，这条命令成功的创建了一个名为web的容器(-P 是指允许外部访问容器需要暴露的端口)，但是我们用<code>docker exec -ti web bash</code> 或者<code>docker attach web</code>想进入到容器内部时，都会提示我们，容器未启动。之后运行<code>docker start web</code>,这在我们的理解中应该是启动了一个容器，但是但我们再想进入到容器时，发现还是提示我们容器未启动。用<code>docker ps</code>查看后台运行的docker容器，返现确实web没有运行。后来想了一下容器创建的步骤，容器确实创建了。但是我们想进入到容器里面却缺少交互界面。所以用了另一个命令<code>docker run -ti -d -P --name web -v /webdata centos /bin/bash</code>,加上<code>-ti</code>之后再用命令进入到容器就可以了。进入之后会发现在容器中根目录多了一个webdata目录。</li>
</ul>
<h4 id="2-1-挂载宿主机的一个目录到容器"><a href="#2-1-挂载宿主机的一个目录到容器" class="headerlink" title="2.1,挂载宿主机的一个目录到容器"></a>2.1,挂载宿主机的一个目录到容器</h4><p><code>-v</code> 标记也可以挂在一个本地的目录到容器里面作为数据卷。<br><code>docker run -ti -d -P --name webdata -v /Users/alvin/test/docker/webdata:/share/webdata centos /bin/bash</code>，这条命令是指将本地<code>/Users/alvin/test/docker/webdata</code>目录挂载到webdata容器里面的<code>/share/webdata</code>目录。<br>如果要挂载多个目录，多次用<code>-v</code>标记就可以了。<code>docker run -ti -d -P --name webdata1 -v /Users/alvin/test/docker/webdata:/share/webdata -v /Users/alvin/test/docker/webdata:/share/webdata1 -v /Users/alvin/test/docker/webdata:/share/webdata2 centos /bin/bash</code> 将webdata,webdata1,webdata2都挂载到docker容器里面相应的位置。<br>如果想要对容器的数据卷目录进行权限控制的话，docker也是允许的，默认是rw权限。如果只想要可读权限。<br><code>docker run -d -P -ti --name webdata -v /Users/alvin/test/docker/webdata:/share/webdata:ro centos bash</code>,目录到容器里面就只有读的权限了。<br><strong>这种方式特别适合挂载单个文件到容器里面</strong>。<br><em><code>--volumes-from</code>参数所挂载的数据卷的容器自身并不需要保持在运行状态。</em><br>如果要删除挂载了数据卷的容器，数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时，显示的是使用<code>docker rm -v</code>命令来指定同时删除关联关联的容器。</p>
<h4 id="2-2-利用数据卷容器迁移数据"><a href="#2-2-利用数据卷容器迁移数据" class="headerlink" title="2.2,利用数据卷容器迁移数据"></a>2.2,利用数据卷容器迁移数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -ti --volumes-from dbdata --name db4 -v &#x2F;Users&#x2F;alvin&#x2F;test&#x2F;docker:&#x2F;backup centos &#x2F;bin&#x2F;bash</span><br><span class="line">tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;dbdata</span><br></pre></td></tr></table></figure>
<p>首先将dbdata容器内的数据卷和db4容器想关联，之后在宿主机和db4容器做数据卷共享，之后将数据卷容器的数据打包到和宿主机共享的位置。这样就做到了数据的备份了。</p>
<h4 id="2-3-恢复数据"><a href="#2-3-恢复数据" class="headerlink" title="2.3,恢复数据"></a>2.3,恢复数据</h4><p> 可以使用本地宿主机和docker文件夹共享。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker修改默认存储空间</title>
    <url>/2019/05/24/docker-default-storage/</url>
    <content><![CDATA[<h1 id="Docker-修改默认存储空间"><a href="#Docker-修改默认存储空间" class="headerlink" title="Docker 修改默认存储空间"></a>Docker 修改默认存储空间</h1><p>最近碰到一个问题，由于需要下载很多的镜像文件，如果使用docker安装时候的默认存储空间，那肯定是不行的。默认的存储空间可以使用：<code>docker info</code>看到：在输出的信息里面会发现:<code>Docker Root Dir: /var/lib/docker</code>；这个目录其实就是在根目录下吗，如果下载的镜像数量过大并且又大，那么肯定是的完蛋的~~~</p>
<p>所以就需要修改docker的存储空间。</p>
<span id="more"></span>
<p>我们的版本是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker -v</span><br><span class="line">Docker version 1.13.1, build 07f3374/1.13.1</span><br></pre></td></tr></table></figure>

<p>所以对于1.13+以上的版本应该都是没问题的，1.13以下的你可以自己尝试下，不一定能行，也不一定说不能行。</p>
<p>在前面：<font color="red">修改有风险，操作需谨慎</font>，在我修改了目录之后，容器和镜像文件都不能使用<code>docker ps/image</code>看到了，所以操作前一点要备份好。当然你把存储路径改回去当然也是可以看到的。</p>
<h2 id="方式一：修改-etc-docker-daemon-json"><a href="#方式一：修改-etc-docker-daemon-json" class="headerlink" title="方式一：修改/etc/docker/daemon.json"></a>方式一：修改/etc/docker/daemon.json</h2><p>修改这个json文件是最简单也是最方便的，没有之一。修改如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;registry.xxx.com&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;graph&quot;</span>: <span class="string">&quot;/docker-data/docker&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最重要的就是<code>&quot;graph&quot;: &quot;/docker-data/docker&quot;</code>，这个就是指定存储位置。</p>
<h2 id="方式二：修改-usr-lib-systemd-system-docker-service"><a href="#方式二：修改-usr-lib-systemd-system-docker-service" class="headerlink" title="方式二：修改/usr/lib/systemd/system/docker.service"></a>方式二：修改/usr/lib/systemd/system/docker.service</h2><p>修改docker的启动命令也能做到将存储默认位置修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Docker Application Container Engine</span><br><span class="line">Documentation&#x3D;http:&#x2F;&#x2F;docs.docker.com</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">Wants&#x3D;docker-storage-setup.service</span><br><span class="line">Requires&#x3D;docker-cleanup.timer</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;notify</span><br><span class="line">NotifyAccess&#x3D;main</span><br><span class="line">EnvironmentFile&#x3D;-&#x2F;run&#x2F;containers&#x2F;registries.conf</span><br><span class="line">EnvironmentFile&#x3D;-&#x2F;etc&#x2F;sysconfig&#x2F;docker</span><br><span class="line">EnvironmentFile&#x3D;-&#x2F;etc&#x2F;sysconfig&#x2F;docker-storage</span><br><span class="line">EnvironmentFile&#x3D;-&#x2F;etc&#x2F;sysconfig&#x2F;docker-network</span><br><span class="line">Environment&#x3D;GOTRACEBACK&#x3D;crash</span><br><span class="line">Environment&#x3D;DOCKER_HTTP_HOST_COMPAT&#x3D;1</span><br><span class="line">Environment&#x3D;PATH&#x3D;&#x2F;usr&#x2F;libexec&#x2F;docker:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbin</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd-current \</span><br><span class="line">          --add-runtime docker-runc&#x3D;&#x2F;usr&#x2F;libexec&#x2F;docker&#x2F;docker-runc-current \</span><br><span class="line">          --default-runtime&#x3D;docker-runc \</span><br><span class="line">          --exec-opt native.cgroupdriver&#x3D;systemd \</span><br><span class="line">          --userland-proxy-path&#x3D;&#x2F;usr&#x2F;libexec&#x2F;docker&#x2F;docker-proxy-current \</span><br><span class="line">          --init-path&#x3D;&#x2F;usr&#x2F;libexec&#x2F;docker&#x2F;docker-init-current \</span><br><span class="line">          --seccomp-profile&#x3D;&#x2F;etc&#x2F;docker&#x2F;seccomp.json \</span><br><span class="line">          $OPTIONS \</span><br><span class="line">          $DOCKER_STORAGE_OPTIONS \</span><br><span class="line">          $DOCKER_NETWORK_OPTIONS \</span><br><span class="line">          $ADD_REGISTRY \</span><br><span class="line">          $BLOCK_REGISTRY \</span><br><span class="line">          $INSECURE_REGISTRY \</span><br><span class="line">          $REGISTRIES</span><br><span class="line">ExecReload&#x3D;&#x2F;bin&#x2F;kill -s HUP $MAINPID</span><br><span class="line">LimitNOFILE&#x3D;1048576</span><br><span class="line">LimitNPROC&#x3D;1048576</span><br><span class="line">LimitCORE&#x3D;infinity</span><br><span class="line">TimeoutStartSec&#x3D;0</span><br><span class="line">Restart&#x3D;on-abnormal</span><br><span class="line">KillMode&#x3D;process</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以看到<code>DOCKER_STORAGE_OPTIONS</code>,然后查看文件:<code>/etc/sysconfig/docker-storage</code>。在<code>DOCKER_STORAGE_OPTIONS=&quot;--storage-driver overlay2 &quot;</code>上加上<code>DOCKER_STORAGE_OPTIONS=&quot;--storage-driver overlay2 --graph /docker-data/docker</code> 然后使用<code>systemctl daemon-reload</code>,<code>systemctl restart docker</code>就可以了。</p>
<p>当然如果你直接在<code>docker.service</code>文件里面改也是可以的，放到配置文件里面也行，都ok。想怎样就怎样~~</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile 编写</title>
    <url>/2017/09/19/docker-dockerfile/</url>
    <content><![CDATA[<h2 id="Dockerfile-文件导读"><a href="#Dockerfile-文件导读" class="headerlink" title="Dockerfile 文件导读"></a>Dockerfile 文件导读</h2><p>Dockerfile 是一个包含了很多指令的文本文件，基于这些指令我们可以使用build创建一个image。</p>
<p>docker build创建image是从dockerfile和context。构建中的上下文(context)是PATH和URL的文件集合，PATH是指本地的文件系统，URL是一个Git仓库地址。一个上下文通常是递归的，对于PATH包含了子目录，URL包含了它的子模块。<code>docker build .</code></p>
<p>build是有Docker 守护进程执行的，执行的第一件事就是将完整的上下文路径（包括递归的子目录）都会发送给守护进程，在大多场景下，最好的方式是用一个空目录作为上下文路径，然后里面放一个Dockerfile.然后在构建(build)将需要的文件加入到目录里面来。</p>
<p>千万注意不要使用根路径”/“作为PATH，它会导致将整个硬盘的文件都会发送给Docker的守护进程</p>
<p>如果要在构建上下文中使用一个文件，Dockerfile 引用了一些特殊的指令，比如COPY指令，为了优化构建，不需要的文件和目录可以加入到上下文目录的.dockerignore文件中。<a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">dockerignore file</a></p>
<p>一般地，Dockerfile被称作Dockerfile，并且放在上下文目录的根目录。你也可以在构建的时候使用 -f 标记来指定一个你文件系统任何地方中的Dockerfile。<br><code>docker build -f /path/to/a/Dockerfile .</code></p>
<p>你也可以在构建成功后保存image时指定远端源仓库(repositories)和标签。</p>
<p><code>docker build -t shykes/myapp .</code></p>
<p>如果要在构建之后给多个仓库(repositories) 打tag，使用多个-t参数就可以了：<br><code>docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</code></p>
<p>在Docker守护进程执行Dockerfile中的指令之前，它都会进行一下预编译来校验语法是否准确，如果有错误的话会返回error。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build -t test&#x2F;myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>Docker守护进程在最终生成image输出imageID前都会一条一条执行Dockerfile中的指令并且确认每条指令的结果。最后守护进程会自动清理你发送的上下文。</p>
<p>注意到每一条指定都是独立执行然后创建一个image。因此 RUN cd /tmp 不会对下一个指令有任何影响。<br>只要允许的话，Docker会重复使用生成的image中的缓存，来加速docker build 执行成功效率。下面的输出中可以明显的看到使用了缓存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build -t svendowideit&#x2F;ambassador .</span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1&#x2F;4 : FROM alpine:3.2</span><br><span class="line"> ---&gt; 31f630c65071</span><br><span class="line">Step 2&#x2F;4 : MAINTAINER SvenDowideit@home.org.au</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 2a1c91448f5f</span><br><span class="line">Step 3&#x2F;4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r &#x2F;var&#x2F;cache&#x2F;</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 21ed6e7fbb73</span><br><span class="line">Step 4&#x2F;4 : CMD env | grep _TCP&#x3D; | (sed &#39;s&#x2F;.*_PORT_\([0-9]*\)_TCP&#x3D;tcp:\&#x2F;\&#x2F;\(.*\):\(.*\)&#x2F;socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;&#x2F;&#39; &amp;&amp; echo wait) | sh</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ea8aef582cc</span><br><span class="line">Successfully built 7ea8aef582cc</span><br></pre></td></tr></table></figure>

<p>镜像构建完就可以尝试将它推送到远程repo;</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#comment</span><br><span class="line">INSTRUCTION argumets</span><br><span class="line"></span><br><span class="line">指令 命令 参数</span><br></pre></td></tr></table></figure>

<p>指令(INSTRUCTION)是大小写无关的，不过大家约定习俗般将它总是大写来区分指令和命令</p>
<p>Docker 执行Instruction是有顺序的。一个Dockerfile文件必须用<code>FROM</code>指令开始。FROM指令制定了构建的基础镜像。FROM只能在在最前面。</p>
<p># 是docker的注释符。</p>
<h3 id="指令解析"><a href="#指令解析" class="headerlink" title="指令解析"></a>指令解析</h3><h3 id="环境变量替换"><a href="#环境变量替换" class="headerlink" title="环境变量替换"></a>环境变量替换</h3><p>环境变量由ENV语句声明也可以用在Dockerfile中；在dockerfile中使用ENV定义的变量可以使用<code>$variable_name</code> 和 <code>$&#123;variable_name&#125;</code>,当然也有转义字符：’&#39;,如果<code>\$variablename</code> ,指代的就是<code>$variable_name</code>;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ENV foo &#x2F;bar</span><br><span class="line">WORKDIR $&#123;foo&#125;     # WORKDIR &#x2F;bar</span><br><span class="line">ADD . $&#123;foo&#125;       # ADD . &#x2F;bar</span><br><span class="line">COPY \$foo &#x2F;quux   # COPY $foo &#x2F;quux</span><br></pre></td></tr></table></figure>

<p>环境变量在Dockerfile中可以被以下的执行指令支持：<br><code>ADD, COPY, ENV, EXPOSE, FROM, LABEL, STOPSIGNAL, USER, VOLUME, WORKDIR, ONBUILD</code>,1.4版本之前的ONBUILD不支持。</p>
<p>在一整条的指令中，环境变量是同一个值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV abc&#x3D;hello</span><br><span class="line">ENV abc&#x3D;bye def&#x3D;$abc</span><br><span class="line">ENV ghi&#x3D;$abc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上文中def会返回hello，而不是bye，ghi会返回bye，因为在第二条指令中，set abc=bye 和def=$abc 并不是同一条指令。</p>
<h3 id="dockerignore-文件"><a href="#dockerignore-文件" class="headerlink" title=".dockerignore 文件"></a>.dockerignore 文件</h3><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><ol>
<li>FROM <image> [AS <name>]</li>
<li>FROM <image>[:<tag>] [AS <name>]</li>
<li>FROM <image>[@<digest>] [AS <name>]</li>
</ol>
<p>FROM指令初始化了一个构建的舞台，并且为接下的操作设置了基础image。一个有效的Dockerfile必须由FROM开始。</p>
<p>默认FROM会有一个<code>latest</code> tag。</p>
<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><ol>
<li>RUN <command>  # shell 形式执行，默认shell执行器，如/bin/sh -c</li>
<li>RUN [“executable”,”param1”,”param2”] # exec 形式执行</li>
</ol>
<p>如果使用shell方式可以使用反斜杠来连接语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN &#x2F;bin&#x2F;bash -c &#39;source $HOME&#x2F;.bashrc; \</span><br><span class="line">echo $HOME&#39;</span><br></pre></td></tr></table></figure>
<p>上面相当于一句话：<code>RUN /bin/bash -c &#39;source $HOME/.bashrc; echo $HOME&#39;</code></p>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>一个Dockerfile里面只能有执行一个CMD指令,如果有多个CMD，只有最后一个会执行。</p>
<p>CMD的三种写法</p>
<ol>
<li>CMD [“executable”,”param1”,”param2”]</li>
<li>CMD [“param1”,”param2”]</li>
<li>CMD command param1 param2</li>
</ol>
<p>shell版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">CMD echo &quot;This is a test.&quot; | wc -</span><br></pre></td></tr></table></figure>

<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>LABEL是给镜像加源数据，通常是键值对的形式。</p>
<p><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></p>
<p>实例：</p>
<p>1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL &quot;com.example.vendor&quot;&#x3D;&quot;ACME Incorporated&quot;</span><br><span class="line">LABEL com.example.label-with-value&#x3D;&quot;foo&quot;</span><br><span class="line">LABEL version&#x3D;&quot;1.0&quot;</span><br><span class="line">LABEL description&#x3D;&quot;This text illustrates \</span><br><span class="line">that label-values can span multiple lines.&quot;</span><br></pre></td></tr></table></figure>

<p>2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL multi.label1&#x3D;&quot;value1&quot; multi.label2&#x3D;&quot;value2&quot; other&#x3D;&quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p>3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL multi.label1&#x3D;&quot;value1&quot; \</span><br><span class="line">      multi.label2&#x3D;&quot;value2&quot; \</span><br><span class="line">      other&#x3D;&quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p>使用<code>docker inspect</code>查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Labels&quot;: &#123;</span><br><span class="line">    &quot;com.example.vendor&quot;: &quot;ACME Incorporated&quot;</span><br><span class="line">    &quot;com.example.label-with-value&quot;: &quot;foo&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;This text illustrates that label-values can span multiple lines.&quot;,</span><br><span class="line">    &quot;multi.label1&quot;: &quot;value1&quot;,</span><br><span class="line">    &quot;multi.label2&quot;: &quot;value2&quot;,</span><br><span class="line">    &quot;other&quot;: &quot;value3&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="MAINTAINER-deprecated"><a href="#MAINTAINER-deprecated" class="headerlink" title="MAINTAINER [deprecated]"></a>MAINTAINER [deprecated]</h4><p><code>MAINTAINER &lt;name&gt;</code> 作者信息</p>
<p>使用LABEL更加灵活：LABEL maintainer=”<a href="mailto:&#83;&#118;&#101;&#x6e;&#x44;&#x6f;&#119;&#x69;&#x64;&#x65;&#x69;&#x74;&#64;&#x68;&#x6f;&#x6d;&#x65;&#x2e;&#111;&#114;&#x67;&#46;&#x61;&#117;">&#83;&#118;&#101;&#x6e;&#x44;&#x6f;&#119;&#x69;&#x64;&#x65;&#x69;&#x74;&#64;&#x68;&#x6f;&#x6d;&#x65;&#x2e;&#111;&#114;&#x67;&#46;&#x61;&#117;</a>“</p>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></p>
<p>在容器运行的时候暴露端口，不会自己和宿主机绑定。如果要和宿主机绑定需要-p，制定端口。或者-P随机系统端口。</p>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;&#x3D;&lt;value&gt; ...</span><br></pre></td></tr></table></figure>

<p>注意第一种没有=号，第二个有等号。<br>实例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV myName&#x3D;&quot;John Doe&quot; myDog&#x3D;Rex\ The\ Dog \</span><br><span class="line">    myCat&#x3D;fluffy</span><br></pre></td></tr></table></figure>

<p>实例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV myName John Doe</span><br><span class="line">ENV myDog Rex The Dog</span><br><span class="line">ENV myCat fluffy</span><br></pre></td></tr></table></figure>

<p>推荐使用实例1的写法，因为这样只会生成一个单缓存层(single cache layer);</p>
<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] # 如果有空格必须采取这种方式。</span><br></pre></td></tr></table></figure>

<p>ADD的作用就是将src目录，文件，或者url的内容加入到镜像文件系统的dest目录下。</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD hom* &#x2F;mydir&#x2F;        # adds all files starting with &quot;hom&quot;</span><br><span class="line">ADD hom?.txt &#x2F;mydir&#x2F;    # ? is replaced with any single character, e.g., &quot;home.txt&quot;</span><br></pre></td></tr></table></figure>

<p>ADD的匹配规则和golang语言的filepath.Match匹配规则一样。</p>
<p>dest 是一个绝对路径，或者<code>WORKDIR</code>的相对路径。</p>
<p>ADD 遵守下面的规则：</p>
<ol>
<li>src 目录必须在构建上下文之内。不可以使用<code>ADD ../something /something</code>,因为在第一步使用docker build的时候就已经发送了上下文路径包括子目录给了docker守护进程</li>
<li>如果src是一个url，而这个url没有斜杠结尾，那么它就以为是一个文件，会下载这个文件然后拷贝到dest目录中。</li>
<li>如果src是url，dest没有用斜杠结尾，那么就会生成dest/filename.比如<code>ADD http://abc.com/foobar /</code> 会创建成<code>/foobar</code></li>
<li>如果src是一个目录，目录下的所有文件都会被拷贝，包括文件系统的metadata。本身的文件夹不拷贝。</li>
</ol>
<h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] #如果路径有空格，采用这种方式</span><br></pre></td></tr></table></figure>

<p>用法和ADD基本类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;        # adds all files starting with &quot;hom&quot;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;    # ? is replaced with any single character, e.g., &quot;home.txt&quot;</span><br></pre></td></tr></table></figure>

<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form, preferred)</span><br><span class="line">ENTRYPOINT command param1 param2 (shell form)</span><br></pre></td></tr></table></figure>


<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p><code>VOLUME [&quot;/data&quot;]</code> 也可以用<code>VOLUME /var/log /var/db</code> <code>VOLUME /var/log</code> 来作为分享的数据卷。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN mkdir &#x2F;myvol</span><br><span class="line">RUN echo &quot;hello world&quot; &gt; &#x2F;myvol&#x2F;greeting</span><br><span class="line">VOLUME &#x2F;myvol</span><br></pre></td></tr></table></figure>
<p>上面的意思就是挂载一个/myvol，然后在执行的时候用<code>docker run -v test:/myvol</code></p>
<p>使用docker inspect可以看到“Mounts”,”Volumes”.如果dockerfile指定Volume而没有<code>docker run -v</code> 那么就可以看到Mounts中会出现一个宿主机随机挂载了一个目录到VOLUME里面的指定位置。</p>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER &lt;user&gt;[:&lt;group&gt;] or</span><br><span class="line">USER &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR &#x2F;path&#x2F;to&#x2F;workdir</span><br></pre></td></tr></table></figure>

<p>WORKDIR 指令会建立一个RUN，CMD，ENTRYPOINT，COPY，ADD这些指令的工作目录。如果没有WORKDIR，它会被接下来的任何一个Dockerfile中的指令创建，就算创建之后不会使用，它还是会存在。</p>
<p>WORKDIR可以在一个Dockerf中出现多次，如果提供的是相对路径，那么接下来的所有路径都会跟前一个WORKDIR相对关联。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR &#x2F;a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>

<p>最后执行的pwd路径为/a/b/c。WORKDIR指令也可以有环境变量使用ENV来设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV DIRPATH &#x2F;path</span><br><span class="line">WORKDIR $DIRPATH&#x2F;$DIRNAME</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>
<p>最后的路径会是/path/$DIRNAME</p>
<h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><h4 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h4><h4 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h4><h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h4><p>Dockerfile实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ tree</span><br><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── jar</span><br><span class="line">│   └── jar_test_file</span><br><span class="line">└── jar_outer_file</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ENV foo &#x2F;bar</span><br><span class="line">LABEL author&#x3D;chenzhijun</span><br><span class="line">RUN mkdir &#x2F;myvol</span><br><span class="line">RUN echo &quot;hello world$foo&quot;$foo &gt; &#x2F;myvol&#x2F;greeting</span><br><span class="line">VOLUME &#x2F;myvol</span><br><span class="line">ADD jar* &#x2F;mydir&#x2F;</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ docker build -t test:1.1 .</span><br><span class="line">Sending build context to Docker daemon  3.584kB</span><br><span class="line">Step 1&#x2F;8 : FROM busybox</span><br><span class="line"> ---&gt; efe10ee6727f</span><br><span class="line">Step 2&#x2F;8 : ENV foo &#x2F;bar</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; d3b8b9eeff78</span><br><span class="line">Step 3&#x2F;8 : LABEL author chenzhijun</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 050fc3d4d93d</span><br><span class="line">Step 4&#x2F;8 : RUN mkdir &#x2F;myvol</span><br><span class="line"> ---&gt; Running in 52850795da36</span><br><span class="line"> ---&gt; afd7fb49f8bf</span><br><span class="line">Removing intermediate container 52850795da36</span><br><span class="line">Step 5&#x2F;8 : RUN echo &quot;hello world$foo&quot;$foo &gt; &#x2F;myvol&#x2F;greeting</span><br><span class="line"> ---&gt; Running in 70b44e104f41</span><br><span class="line"> ---&gt; cbd977a40b6d</span><br><span class="line">Removing intermediate container 70b44e104f41</span><br><span class="line">Step 6&#x2F;8 : VOLUME &#x2F;myvol</span><br><span class="line"> ---&gt; Running in da2e28e0effa</span><br><span class="line"> ---&gt; 4edd7f3c690c</span><br><span class="line">Removing intermediate container da2e28e0effa</span><br><span class="line">Step 7&#x2F;8 : ADD jar* &#x2F;mydir&#x2F;</span><br><span class="line"> ---&gt; 13feb93f43f0</span><br><span class="line">Removing intermediate container 4bd1b0a08ef2</span><br><span class="line">Step 8&#x2F;8 : EXPOSE 8080</span><br><span class="line"> ---&gt; Running in 2185ad28d925</span><br><span class="line"> ---&gt; 62bfe542f989</span><br><span class="line">Removing intermediate container 2185ad28d925</span><br><span class="line">Successfully built 62bfe542f989</span><br><span class="line">Successfully tagged test:1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>docker inspect:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> docker inspect test:1.1</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:62bfe542f98957d45fada954dcbb8ced1a1d8a65e42657b98c40f88b559f690e&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;test:1.1&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RepoDigests&quot;: [],</span><br><span class="line">        &quot;Parent&quot;: &quot;sha256:13feb93f43f085b44a37f6272b55f4f9bcf1b899d441f0dec83561904c8cea40&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2017-09-19T15:23:52.690407548Z&quot;,</span><br><span class="line">        &quot;Container&quot;: &quot;2185ad28d9256023fdc96fad564c8c0eb699d4f6f9b09d4acabe73beeee6790c&quot;,</span><br><span class="line">        &quot;ContainerConfig&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;44c72a15738e&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;8080&#x2F;tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin&quot;,</span><br><span class="line">                &quot;foo&#x3D;&#x2F;bar&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;&#x2F;bin&#x2F;sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;#(nop) &quot;,</span><br><span class="line">                &quot;EXPOSE 8080&#x2F;tcp&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ArgsEscaped&quot;: true,</span><br><span class="line">            &quot;Image&quot;: &quot;sha256:13feb93f43f085b44a37f6272b55f4f9bcf1b899d441f0dec83561904c8cea40&quot;,</span><br><span class="line">            &quot;Volumes&quot;: &#123;</span><br><span class="line">                &quot;&#x2F;myvol&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: [],</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;author&quot;: &quot;chenzhijun&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;DockerVersion&quot;: &quot;17.06.2-ce&quot;,</span><br><span class="line">        &quot;Author&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;44c72a15738e&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;8080&#x2F;tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin&quot;,</span><br><span class="line">                &quot;foo&#x3D;&#x2F;bar&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;sh&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ArgsEscaped&quot;: true,</span><br><span class="line">            &quot;Image&quot;: &quot;sha256:13feb93f43f085b44a37f6272b55f4f9bcf1b899d441f0dec83561904c8cea40&quot;,</span><br><span class="line">            &quot;Volumes&quot;: &#123;</span><br><span class="line">                &quot;&#x2F;myvol&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: [],</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;author&quot;: &quot;chenzhijun&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">        &quot;Os&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;Size&quot;: 1129213,</span><br><span class="line">        &quot;VirtualSize&quot;: 1129213,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: null,</span><br><span class="line">            &quot;Name&quot;: &quot;aufs&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;RootFS&quot;: &#123;</span><br><span class="line">            &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">            &quot;Layers&quot;: [</span><br><span class="line">                &quot;sha256:08c2295a7fa5c220b0f60c994362d290429ad92f6e0235509db91582809442f3&quot;,</span><br><span class="line">                &quot;sha256:76229699c752a26051d4861c0e481d45e9353f66f181fd496a5ef39a8833fbff&quot;,</span><br><span class="line">                &quot;sha256:02a0230b59819ae96f49a8603d5b1630cd357e140f48bf1e03811c5f002d8b5f&quot;,</span><br><span class="line">                &quot;sha256:c916120dc28545b2869e046d28ababe83cfa76c2cb31c52e497450bfebb1aafa&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 镜像</title>
    <url>/2017/05/13/docker-image/</url>
    <content><![CDATA[<h2 id="镜像是Docker的三大核心概念之一。"><a href="#镜像是Docker的三大核心概念之一。" class="headerlink" title="镜像是Docker的三大核心概念之一。"></a>镜像是Docker的三大核心概念之一。</h2><blockquote>
<p>Docker运行容器前需要本地存在对应的镜像，Docker会尝试先从默认镜像仓库下载，可以自定义默认仓库位置。</p>
</blockquote>
<h3 id="1，获取镜像"><a href="#1，获取镜像" class="headerlink" title="1，获取镜像"></a>1，获取镜像</h3><p><code>docker pull name[:TAG]</code>,如果TAG没有的话，默认是latest。<br>获取到镜像后，就可以使用镜像创建容器，在其中运行bash应用。</p>
<h3 id="2，查看镜像信息"><a href="#2，查看镜像信息" class="headerlink" title="2，查看镜像信息"></a>2，查看镜像信息</h3><p><code>docker images</code>,列出本地主机上已有的镜像。<br><code>docker tag dl.dockerpull.com:5000/ubuntu:latest ubuntu:latest</code>,给本地镜像添加新标签,新标签的镜像id是一样的。<br><code>docker inspect image-id</code>,获取image-id的详细信息，json串。如果只想要某个信息的话，可以用<br><code>docker inspect -f &#123;&#123;".RootFS"&#125;&#125; 48b5</code>,<code>RootFS</code>是json的某一项内容的详情。<code>48b5</code>,是镜像id。</p>
<span id="more"></span>
<h3 id="3，搜寻镜像"><a href="#3，搜寻镜像" class="headerlink" title="3，搜寻镜像"></a>3，搜寻镜像</h3><p><code>docker search image-name</code>,搜索远端仓库中共享的镜像。</p>
<ul>
<li>–automated=false 仅显示自动创建的镜像</li>
<li>–no-trunc=false 输出信息不截断显示</li>
<li>-s, –start=0 指定仅显示评价为指定星级以上的镜像</li>
</ul>
<h3 id="4，删除镜像"><a href="#4，删除镜像" class="headerlink" title="4，删除镜像"></a>4，删除镜像</h3><p>使用镜像的标签删除镜像<br><code>docker rmi image [image...]</code>,其中的image可以为标签或ID;<br><code>docker rmi image:tag</code>,删除某个标签为tag的image;不带tag时默认为latest;<br>如果有容器是以要删除的镜像为基础创建的，那么镜像文件默认是无法被删除的。<br>如果要强行删除一个容器，可以用<code>docker rmi -f image:tag</code>,最好是先将基于镜像的容器删除掉<code>docker rm container-id</code>，之后再去删除镜像。</p>
<h3 id="5，创建镜像"><a href="#5，创建镜像" class="headerlink" title="5，创建镜像"></a>5，创建镜像</h3><p>创建镜像的方法有三种: 基于已有镜像的容器创建，基于本地模板导入，基于Dockerfile创建。</p>
<p>a)基于已有容器创建<br><code>docker commit [OPTIONS] container [REPOSITORY[:TAG]]</code>:</p>
<ul>
<li>-a, –author=”” 作者信息。</li>
<li>-m, –message=”” 提交信息。</li>
<li>-p, –pause=true 提交时暂停容器运行。</li>
</ul>
<p>eg:<code>docker commit -m &quot;added test images&quot; -a &quot;chenzhijun&quot; 7e036 newimage:1.0</code> 以容器id为7e036*的容器为基础创建一个image。image-name为newimage,image-tag为1.0，如果1.0为空，默认为latest。</p>
<p>b)基于本地模板导入<br>本地先下载了一个<code>apache-tomcat-7.0.75.tar.gz</code>,然后使用<code>cat apache-tomcat-7.0.75.tar.gz |docker import - my-tomcat:1.0</code>这样就可以创建一个本地<code>my-tomcat</code>镜像。</p>
<h3 id="6，存出和载入镜像"><a href="#6，存出和载入镜像" class="headerlink" title="6，存出和载入镜像"></a>6，存出和载入镜像</h3><p>使用docker save 和 docker load命令来存出和载入镜像<br>a)存出镜像<br><code>docker save -o my-name.tar image[:tag]</code><br>这样就能将image存出到一个my-name.tar的文件下了</p>
<p>b)载入镜像<br><code>docker load laod --input my-name.tar</code><br><code>dcoker load &lt; my-name.tar</code></p>
<h3 id="7，上传镜像"><a href="#7，上传镜像" class="headerlink" title="7，上传镜像"></a>7，上传镜像</h3><p><code>docker push NAME[:TAG]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag test:latest user&#x2F;test:latest</span><br><span class="line">docker push user&#x2F;test:latest</span><br><span class="line"></span><br><span class="line">-- 可能需要登录</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 与 Linux Namespace &amp;&amp; Cgroups</title>
    <url>/2019/06/30/docker-lxc-cgroup/</url>
    <content><![CDATA[<h1 id="Docker-与-Linux-Namespace-amp-amp-Cgroups"><a href="#Docker-与-Linux-Namespace-amp-amp-Cgroups" class="headerlink" title="Docker 与 Linux Namespace &amp;&amp; Cgroups"></a>Docker 与 Linux Namespace &amp;&amp; Cgroups</h1><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker?"></a>什么是Docker?</h2><p>不得不说这几年技术领域最火的就是“容器”这个词了。而谈到容器，大家的第一反应就是 Docker ,Docker 已经再很多人心中成了容器的代名词。那么Docker到底是什么？Docker能为我们带来什么？</p>
<p>官网上用来解释Docker的一句话:<code>Docker is a platform for developers and sysadmins to develop, deploy, and run applications with containers</code>。Docker 就是一个开源的工具，将我们的应用打包成标准的镜像格式，并且以容器的方式运行。容器化的越来越流行，带给我们的优势也是非常多：</p>
<ol>
<li>灵活性：再复杂的应用都可以被容器化；</li>
<li>轻量级：容器利用共享的是主机内核；</li>
<li>即时性：可以随时部署更新和升级；</li>
<li>通用性：一次构建，到处运行；</li>
<li>伸缩性：控制容器副本数量来任意伸缩；<span id="more"></span>
<h2 id="Docker-与虚拟机的比较"><a href="#Docker-与虚拟机的比较" class="headerlink" title="Docker 与虚拟机的比较"></a>Docker 与虚拟机的比较</h2></li>
</ol>
<p>容器与容器之间是共享Kernel的，各容器直接互相隔离。它只运行一个独立的进程，没有其它的执行进程，也不需要占用其它额外的资源。</p>
<p>虚拟机运行的是一个独立的完整的系统，占用的资源也要比独立的应用需要的多。他们两者区别在于虚拟机管理程序对整个设备进行抽象处理，而容器只是对操作系统内核进行抽象处理。下面这张图可以对两者有个认知了解：</p>
<p><img src="/images/qiniu/2019-06-30-15-12-00.png" alt="2019-06-30-15-12-00"></p>
<h2 id="Linux-Namespace"><a href="#Linux-Namespace" class="headerlink" title="Linux Namespace"></a>Linux Namespace</h2><p>我们经常听到，Docker其实并不是单独创造的一个技术，在早期，Docker其实就是基于Linux上的LXC(Linux Container)项目来创建单个应用程序的容器，目前Docker使用libcontainer来直接操作核心namespace和cgoup。这里我们了解下Linux Namesapce。Linux namespace是Kernel的功能，主要用来隔离一系列资源，目前Linux有6种不同类型的Namespace：</p>
<ol>
<li>Mount Namespace, CLONE_NEWNS, 用来隔离nodename和domainname;</li>
<li>UTS Namespace, CLONE_NEWUTS, 用来隔离 System V IPC 和 POSIX message queues;</li>
<li>IPC Namespace, CLONE_NEWIPC, 用来隔离进行ID;</li>
<li>PID Namespace, CLONE_NEWPID, 用来隔离各个进程看到的挂载点视图;</li>
<li>Network Namespace, CLONE_NEWNET, 用来隔离网络设备、IP 地址端口等网络栈的 Namespace;</li>
<li>User Namespace, CLONE_NEWUSER, 用来隔离用户的用户组ID;</li>
</ol>
<h2 id="Linux-Cgroups"><a href="#Linux-Cgroups" class="headerlink" title="Linux Cgroups"></a>Linux Cgroups</h2><p>Linux Cgroups (Control Groups) 提供了一组进程及将来子进程的资源限制、控制和统计的能力，资源包括CPU、内存、存储、网络等。通过Cgroups,可以方便地限制某个进程的资源占用，并且可以实时地监控进程的监控和统计信息。Cgroups的三个组件，</p>
<ol>
<li>cgroup</li>
<li>subsystem</li>
<li>hierarchy</li>
</ol>
<h2 id="libcontainer"><a href="#libcontainer" class="headerlink" title="libcontainer"></a>libcontainer</h2><p>libcontainer 是Docker开源的一个项目，目前runC的实现也已经有原来的LXC变为libcontainer。官网对libcontainer的解释：<a href="https://docs.docker.com/glossary/?term=libcontainer">libcontainer provides a native Go implementation for creating containers with namespaces, cgroups, capabilities, and filesystem access controls. It allows you to manage the lifecycle of the container performing additional operations after the container is created</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 快速搭建 MySQL 和 Redis</title>
    <url>/2018/12/16/docker-mysql-and-redis/</url>
    <content><![CDATA[<h1 id="Docker-快速搭建-MySQL-和-Redis"><a href="#Docker-快速搭建-MySQL-和-Redis" class="headerlink" title="Docker 快速搭建 MySQL 和 Redis"></a>Docker 快速搭建 MySQL 和 Redis</h1><h2 id="MySQL-环境搭建"><a href="#MySQL-环境搭建" class="headerlink" title="MySQL 环境搭建"></a>MySQL 环境搭建</h2><p>最近做开发的时候遇到一个比较有意思的事情，如何搭建一个数据库，还有相关的redis等。因为没有外网，不可能说直接yum安装，又不想到每个官网去找相应的安装包。自然的，就想到了用Docker。一开始用到docker安装一个mysql的时候确实也是非常方便，比如一个<code>docker run</code>命令就启动了一个mysql，但是开发到一部分的时候，发现。我去！怎么又乱码？？ 咦，怎么市区也不对了？GG，发现还有很多小问题。今天有空一并总结下，下次如果有这种事就可以直接用了。</p>
<h3 id="使用Docker启动启动Mysql容器"><a href="#使用Docker启动启动Mysql容器" class="headerlink" title="使用Docker启动启动Mysql容器"></a>使用Docker启动启动Mysql容器</h3><p>如果需要一个mysql数据库，直接使用docker来运行一个容器：<code>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root123456 mysql:5.7</code></p>
<p>这样你就可以在本地ip+3306端口来访问一个mysql数据库了，root密码是：<code>root123456</code>。第一次使用docker的时候就是因为这个原因被吸引了。想想如果本地安装需要做多少配置，而是用docker一条命令就帮你把那些复杂的操作都隐藏了。这种便利性，我想谁都不会说不想要。</p>
<p>不过虽然便利是便利了，但是还是需要注意一些问题：</p>
<span id="more"></span>

<h4 id="字符问题"><a href="#字符问题" class="headerlink" title="字符问题"></a>字符问题</h4><p>mysql默认其实是latin的字符集，docker 启动mysql的时候其实也是使用的默认字符。而我们做开发一般都是使用UTF-8的字符集，那出现这种情况该如何更改配置了？可以在启动的时候加上两个变量：<code>docker run -d -e MYSQL_ROOT_PASSWORD=root123456 mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</code></p>
<h4 id="数据磁盘问题"><a href="#数据磁盘问题" class="headerlink" title="数据磁盘问题"></a>数据磁盘问题</h4><p>一个容器，如果那天不小心删除了，然后你重建就会发现之前的数据没有了，这种情况当然是不行啦。那么怎么将数据盘挂载出来：加上 <code>-v</code>，让存储在容器里面的数据存储到本地自定义的盘中：<code>-v /data/mysql:/var/lib/mysql</code>。</p>
<h4 id="默认数据库，以及时区修改"><a href="#默认数据库，以及时区修改" class="headerlink" title="默认数据库，以及时区修改"></a>默认数据库，以及时区修改</h4><p>有的时候我们会需要导入一些表或者一些数据，这个时候该怎么操作? 其实也有一个环境变量：<code>MYSQL_DATABASE</code>;然后将数据库的初始化脚本放到<code>/docker-entrypoint-initdb.d/</code>目录下也就是将sql挂载到该目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root123456 -e MYSQL_DATABASE=DB_USER -e TZ=Asia/Shanghai -v $PWD/sql-scripts/:/docker-entrypoint-initdb.d/ -v /data/mysql:/var/lib/mysql mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>

<p>将数据库的sql放到当前目录的<code>sql-scripts/</code>目录下。</p>
<!--- docker run -d --name test -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root123456 -e MYSQL_DATABASE=DB_USER -e TZ=Asia/Shanghai -v $PWD/sql-scripts/:/docker-entrypoint-initdb.d/ -v /data/mysql:/var/lib/mysql -v /etc/localtime:/etc/localtime:ro mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci

docker run -d --name test -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root123456 -e MYSQL_DATABASE=DB_USER -e TZ=Asia/Shanghai -v /etc/localtime:/etc/localtime:ro -v $PWD/sql-scripts/:/docker-entrypoint-initdb.d/ -v /data/mysql:/var/lib/mysql -v /etc/localtime:/etc/localtime:ro mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
--->


<h2 id="Redis-环境搭建"><a href="#Redis-环境搭建" class="headerlink" title="Redis 环境搭建"></a>Redis 环境搭建</h2><p>redis的搭建其实要比mysql要简单些，毕竟redis我们一般都只是用来当作缓存，而不会将数据持久化，所以只需要将一个容器run起来就可以了。不过我们一般会有redis的密码需要，所以完整的命令如下：</p>
<p><code>docker run -d --name redis -p 6379:6379 redis:latest --requirepass &quot;123456&quot;</code></p>
<p>这样redis就启动了，如果需要开机启动，加上<code>--restart=always</code>。</p>
<p>好了，今天一篇搭建mysql和redis的过程就到这里了。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 网络</title>
    <url>/2017/05/14/docker-network/</url>
    <content><![CDATA[<blockquote>
<p>有了底层，有了数据，还差一个网络基础配置，那样就完美了</p>
</blockquote>
<h3 id="1-宿主机和Docker容器端口对应"><a href="#1-宿主机和Docker容器端口对应" class="headerlink" title="1,宿主机和Docker容器端口对应"></a>1,宿主机和Docker容器端口对应</h3><p><code>docker run -ti --name test-network -d -p 50001:8080 chenzhijun/javaweb:1.0</code> 或者用 <code>docker run -ti --name test-network -d -p 50001:8080 chenzhijun/javaweb:1.0 /root/run.sh</code></p>
<p>创建一个在chenzhijun/javaweb:1.0镜像上的test-network容器，并且将本地的50001端口映射到docker的8080端口。chenzhijun/javaweb:1.0 镜像可以在hub.docker.com上下载，进入到容器后，进入root文件夹下，启动run.sh。然后再本地就可以用localhost:50001端口访问了。</p>
<span id="more"></span>
<h3 id="2-映射所有接口地址"><a href="#2-映射所有接口地址" class="headerlink" title="2,映射所有接口地址"></a>2,映射所有接口地址</h3><p><code>docker run -ti --name network -d -p 127.0.0.1::8080 chenzhijun/javaweb:1.0</code><br>这样就是在本地随机分配了一个端口映射到docker的8080。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; docker port network</span><br><span class="line">&gt; 8080&#x2F;tcp -&gt; 127.0.0.1:32768</span><br><span class="line">&gt; docker inspect network</span><br></pre></td></tr></table></figure>

<h3 id="3-容器互联实现容器间通信"><a href="#3-容器互联实现容器间通信" class="headerlink" title="3,容器互联实现容器间通信"></a>3,容器互联实现容器间通信</h3><p>容器的连接系统是除了端口映射外另一种可以与容器中应用进行交互的方式。它会在源和接受容器之间创建一个隧道，接收容器可以看到源容器制定的信息。<br><code>docker run -d -P --name web --link name:alias images-name</code>,其中name是要链接的容器的名称，alias是这个链接的别名。<br><code>docker run -it -d --name web2 --link db:mydb centos bash</code>创建一个和db容器有关联,在web2容器/etc/hosts中文件内容为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a1307bd12135 &#x2F;]# cat &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">172.17.0.6	mydb d121bb075116 db</span><br><span class="line">172.17.0.5	a1307bd12135</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用Docker快速掌握新技术要点并完成适当的技术储备</p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Registry 磁盘空间清理</title>
    <url>/2019/05/09/docker-registry-clean-disk/</url>
    <content><![CDATA[<h1 id="Docker-Registry-磁盘空间清理"><a href="#Docker-Registry-磁盘空间清理" class="headerlink" title="Docker Registry 磁盘空间清理"></a>Docker Registry 磁盘空间清理</h1><p>使用 Docker 的时候用的是 Docker Registry 来存储镜像。一开始的时候给了500G数据盘，日积月累的累积的数据就开始变多了。<br>没办法只好想办法去清理。看了下官网的api文档：<a href="https://docs.docker.com/registry/spec/api/">Docker Registry API</a></p>
<p>其实还挺简单的，主要是用http接口先将镜像和层删除，然后使用镜像仓库的garbage-collect。</p>
<p>默认HTTP接口是不支持DELETE方法的，需要修改配置文件中<code>storage.delete.enabled: true</code>，配置文件的解释可以在这里看到地址<a href="https://docs.docker.com/registry/configuration/#delete">Registry 配置文件</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">delete:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>镜像仓库的<a href="https://docs.docker.com/registry/garbage-collection/">garbage-collection</a>可以看下官网文档。主要看懂一个图就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -----&gt; a &lt;----- B</span><br><span class="line">    \--&gt; b     |</span><br><span class="line">         c &lt;--&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -----&gt; a     B</span><br><span class="line">    \--&gt; b</span><br><span class="line">         c</span><br></pre></td></tr></table></figure>

<p>这样c就要回收了。</p>
<p>然后我们使用HTTP的API。查到repo，tags，然后就可以删除相应的镜像。</p>
<p>但是在删除的时候要注意下，首先我们要通过接口获取digest的值，但是这个digest的值获取方式比较特别，首先我们访问：<code>/v2/&lt;name&gt;/manifests/&lt;reference&gt;</code>这个接口的时候，需要使用GET获取HEAD方法，然而在请求的时候需要加入Header：<code>Accept: application/vnd.docker.distribution.manifest.v2+json</code>这样才可以在返回的HEAD中才能获取到正式的digest。</p>
<p>使用golang写了一个demo代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tag <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span>   <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Tags []<span class="keyword">string</span> <span class="string">`json:&quot;tags&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Repo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Repositories []<span class="keyword">string</span> <span class="string">`json:&quot;repositories&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//registry garbage-collect /etc/docker/registry/config.yml</span></span><br><span class="line"><span class="comment">//registry garbage-collect --dry-run /etc/docker/registry/config.yml &gt; test.log</span></span><br><span class="line"><span class="comment">//cat test.log | awk -F : &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -rn -k1 | head -10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	registryUrl := flag.String(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://registry.xxxxx.com:5000&quot;</span>, <span class="string">&quot;registry url&quot;</span>)</span><br><span class="line">	pattern := flag.String(<span class="string">&quot;pattern&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;删除镜像名中有pattern的镜像&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Println(<span class="string">&quot;registry url:&quot;</span>, *registryUrl, <span class="string">&quot;,pattern:&quot;</span>, *pattern)</span><br><span class="line">	resp, _ := http.Get(*registryUrl + <span class="string">&quot;/v2/_catalog?n=10000&quot;</span>)</span><br><span class="line">	bytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">	r := Repo&#123;&#125;</span><br><span class="line">	json.Unmarshal(bytes, &amp;r)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> r.Repositories &#123;</span><br><span class="line">		<span class="keyword">if</span> *pattern == <span class="string">&quot;&quot;</span> || <span class="built_in">len</span>(*pattern) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			*pattern = <span class="string">&quot;2017&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;pattern:&quot;</span>, *pattern)</span><br><span class="line">		<span class="keyword">if</span> strings.Contains(v, *pattern) &#123;</span><br><span class="line">			url := fmt.Sprintf(*registryUrl+<span class="string">&quot;/v2/%s/tags/list&quot;</span>, v)</span><br><span class="line">			fmt.Println(<span class="string">&quot;url&quot;</span> + url)</span><br><span class="line">			resp, _ := http.Get(url)</span><br><span class="line">			bytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> t = Tag&#123;&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;byteStr:&quot;</span>, <span class="keyword">string</span>(bytes))</span><br><span class="line">			json.Unmarshal(bytes, &amp;t)</span><br><span class="line">			fmt.Println(<span class="string">&quot;tag:&quot;</span>, t)</span><br><span class="line">			client := http.DefaultClient</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(t.Tags) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> _, ti := <span class="keyword">range</span> t.Tags &#123;</span><br><span class="line">					mainfests := *registryUrl + <span class="string">&quot;/v2/%s/manifests/%s&quot;</span></span><br><span class="line">					url = fmt.Sprintf(mainfests, t.Name, ti)</span><br><span class="line">					request, _ := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line">					request.Header.Set(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>)</span><br><span class="line">					response, _ := client.Do(request)</span><br><span class="line">					digest := response.Header.Get(<span class="string">&quot;docker-content-digest&quot;</span>)</span><br><span class="line">					fmt.Println(<span class="string">&quot;digest:&quot;</span>, digest)</span><br><span class="line">					fmt.Println(<span class="string">&quot;headers:&quot;</span>, response.Header)</span><br><span class="line">					deleteUrl := fmt.Sprintf(mainfests, t.Name, digest)</span><br><span class="line"></span><br><span class="line">					fmt.Println(<span class="string">&quot;deleteUrl:&quot;</span>, deleteUrl)</span><br><span class="line">					request, _ = http.NewRequest(http.MethodDelete, deleteUrl, <span class="literal">nil</span>)</span><br><span class="line">					response, _ = client.Do(request)</span><br><span class="line">					headers := response.Header</span><br><span class="line">					fmt.Println(response.Status, headers)</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就算这样执行完，别忘记了，进入到registry的容器中，然后使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">registry garbage-collect /etc/docker/registry/config.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>/etc/docker/registry/config.yml</code>文件要打开之前说的<code>storage.delete.enabled: true</code></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 镜像仓库清理</title>
    <url>/2019/06/30/docker-registry-clean/</url>
    <content><![CDATA[<h1 id="Docker-镜像仓库清理"><a href="#Docker-镜像仓库清理" class="headerlink" title="Docker 镜像仓库清理"></a>Docker 镜像仓库清理</h1><p>公司使用registry作为镜像仓库管理，由于只对内使用并且只暴露给jenkins，不对其它人公开，因此也就没有做registry的限制。不过由于我们在jenkins构建的时候使用docker 的一个插件，但是我们公司又系统在构建的时候不还tag，因此造成同一个名字有很多历史的layer都保存在了镜像仓库中，占用的空间随着时间越来越大。经过这次清理，由原来的占用1.9T清理空间到占用195G，效果还是非常的明显。</p>
<p>清理的步骤如下，下面的步骤适用于镜像名和tag都相同，然后重复push的情景下：</p>
<span id="more"></span>
<h2 id="清理多余的manifest"><a href="#清理多余的manifest" class="headerlink" title="清理多余的manifest"></a>清理多余的manifest</h2><p>适用命令：<br><code>docker run -d -v /data/registry:/registry -e REGISTRY_URL=http://&#123;&#123;registry-ip&#125;&#125;:5000 mortensrasmussen/docker-registry-manifest-cleanup:latest</code></p>
<p><code>mortensrasmussen/docker-registry-manifest-cleanup:latest</code>是一个开源的工具：<a href="https://github.com/mortensteenrasmussen/docker-registry-manifest-cleanup">docker-registry-manifest-cleanup</a>。其中<code>-v /data/registry:/registry</code> /data/registry 是镜像仓库registry使用的存储在主机上的目录。</p>
<blockquote>
<p>ps:你的registry 是用容器的方式跑的：<code>docker run -v /data/registry:/registry -p 5000:5000 xxxxx/registry:latest</code> 这个就是<code>/data/registry</code>在本地存储的位置。</p>
</blockquote>
<h2 id="registry-的清理"><a href="#registry-的清理" class="headerlink" title="registry 的清理"></a>registry 的清理</h2><p>执行完上面的步骤还不够，还需要调用registry的清理功能才能实际释放空间:<code>docker exec registry /bin/registry garbage-collect /etc/docker/registry/config.yml</code></p>
<p><code>config.yaml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">registry</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">blobdescriptor:</span> <span class="string">inmemory</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line">  <span class="attr">delete:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">:5000</span></span><br><span class="line">  <span class="attr">headers:</span></span><br><span class="line">    <span class="attr">X-Content-Type-Options:</span> [<span class="string">nosniff</span>]</span><br><span class="line"><span class="attr">health:</span></span><br><span class="line">  <span class="attr">storagedriver:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">threshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>执行完之后再使用<code>df -h</code>你就可以看到磁盘的空间被释放出来了。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker简单入门-搭建 JavaWeb Docker 运行环境</title>
    <url>/2017/04/12/docker-start/</url>
    <content><![CDATA[<h3 id="Docker-入门"><a href="#Docker-入门" class="headerlink" title="Docker 入门"></a>Docker 入门</h3><blockquote>
<p>容器技术已经越来越火爆，作为攻城狮有必要了解一下Docker</p>
</blockquote>
<h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h3><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。正如 Docker 的 Logo 所示。一条大鲸鱼载着各种集装箱。大鲸鱼就可以看成宿主机，集装箱就是在宿主机上的容器，容器之间是相互隔离的。</p>
<span id="more"></span>

<h3 id="怎么用Docker"><a href="#怎么用Docker" class="headerlink" title="怎么用Docker"></a>怎么用Docker</h3><p>Docker 最重要的的是 image ，也就是镜像。先有镜像，再建立容器。</p>
<p>Docker 的使用方式是很简单的，暂时我也只是刚刚学会一些简单的使用方式。暂时先介绍 Docker 几个命令的使用方式：</p>
<ul>
<li>docker –version    查看当前安装的 Docker 的版本</li>
<li>docker –info       查看 Docker 的信息</li>
<li>docker images       查看所有的镜像</li>
<li>docker ps -a        查看所有的容器</li>
<li>docker ps           查看正在运行的容器</li>
<li>docker rm <container name>  删除容器</li>
<li>docker rmi  <image name>    删除镜像    多加一个i，rmi。</li>
<li>docker stop <container name>    停止运行的容器</li>
<li>docker start <container name>   启动一个容器</li>
<li>docker run -ti [–name container-name] -v [宿主机地址]:[容器地址] &lt;镜像名&gt; /bin/bash   eg:docker run -ti –name web -v /Users/alvin/Devtools/docker/:/mnt/software/ centos /bin/bash    这条命令的意思在 centos 镜像上建立一个名为 web 容器。-v 的意思是在宿主机的/Users/alvin/Devtools/docker/ 挂载在 web 容器的/mnt/software/ 位置。</li>
<li>docker commit &lt;容器ID&gt; chenzhijun/javaweb:1.0  保存容器为一个镜像</li>
</ul>
<h3 id="怎么创建镜像"><a href="#怎么创建镜像" class="headerlink" title="怎么创建镜像"></a>怎么创建镜像</h3><p>一切从理论都是屁话，理论结合实践才是王道。</p>
<p>下面建立一个Javaweb运行环境的容器，生成image上传到hub.docker.com。</p>
<p>1:首先要下载Centos 镜像<br>    <code>docker pull centos</code></p>
<p>2:在Tomcat官网上下载Tomcat linux 版本；在 Oracle 官网下载 JDK 。解压后将tomcat和jdk存放在本地宿主机 [自定义目录:/User/alvin/Devtools/docker/] </p>
<p>3:在centos上建立一个新容器<br>    <code>docker run -ti --name chenzhijun -v /Users/alvin/Devtools/docker/:/mnt/software/ centos /bin/bash</code></p>
<p>4:进入容器里面，将software下的tomcat和jdk移动到/opt/下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vim ~&#x2F;.bashrc </span><br><span class="line"># 在.bashrc 最后面加入下面两行</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;opt&#x2F;jdk</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME</span><br></pre></td></tr></table></figure>

<p>5:进入容器后创建脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;root&#x2F;run.sh</span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">source ~&#x2F;.bashrc</span><br><span class="line">sh &#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F;catalina.sh run</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6:修改脚本文件权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u+x &#x2F;root&#x2F;run.sh</span><br></pre></td></tr></table></figure>

<p>7:保存容器到镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1:查看容器的id</span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line">2:保存容器为镜像</span><br><span class="line">docker commit (容器id) chenzhijun&#x2F;javaweb:0.1</span><br><span class="line"></span><br><span class="line">3:启动镜像</span><br><span class="line">docker run -d -p 58080:8080 --name javaweb chenzhijun&#x2F;javaweb:0.1 &#x2F;root&#x2F;run.sh</span><br><span class="line">启动一个容器，并且容器运行的时候运行脚本，绑定宿主机的端口58080到容器的端口8080，运行的容器名字为javaweb</span><br></pre></td></tr></table></figure>

<p>8:上传镜像到hub.docker.com,首先保证在hub上有一个相同名字的镜像地址，跟git类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login</span><br><span class="line">username:</span><br><span class="line">password:</span><br><span class="line"></span><br><span class="line">docker push chenzhijun&#x2F;javaweb</span><br></pre></td></tr></table></figure>
<p>好了，暂时照着这个操作就基本上可以了。 如果遇到问题可以给我留言，也可以联系我的邮箱：<a href="mailto:&#x76;&#98;&#x6f;&#111;&#107;&#99;&#x68;&#x65;&#x6e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;">&#x76;&#98;&#x6f;&#111;&#107;&#99;&#x68;&#x65;&#x6e;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Swarm 实践的一些经验总结</title>
    <url>/2018/01/08/docker-swarm-practice/</url>
    <content><![CDATA[<h1 id="Docker-Swarm-实践的一些经验总结"><a href="#Docker-Swarm-实践的一些经验总结" class="headerlink" title="Docker Swarm 实践的一些经验总结"></a>Docker Swarm 实践的一些经验总结</h1><p>最近弄了一下Docker Swarm。在公司已经把我拉入了黑名单，因为只要我已启动docker公司的mysql就得挂。我也是好奇，正想找问题原因。服务器的密码就已经改了，我是没有机会了。不过在改密码之前，我还是获得一些宝贵的经验，这个我觉得很重要，可以记录下来，自己以后再踩坑的时候可以自己参照下。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>ubuntu机器一台，centos一台，都安装了docker。docker的版本是Docker version 17.12.0-ce, build c97c6d6。4个spring boot项目：eureka，warehouse，web，booksrv。MySQL使用的是另外一台机器上的安装在hosts(非容器化)。eureka做为注册中心，启动了两个示例。部署方式使用的docker stack。 也有直接使用了docker service。使用了网络overlay，看了网上很多文章，对于网络不太了解就用了原生的，这样方式至少容易理解。创建了overlay网络springcloud-overlay。还是用了java:8-jre-alpine镜像</p>
<h2 id="做了些什么事情"><a href="#做了些什么事情" class="headerlink" title="做了些什么事情"></a>做了些什么事情</h2><p>实现了两台机器上的docker容器连通，U机器上的容器，能够访问C机器上的容器。这说明服务容器化是可以实现的。当然我说的是废话，google以及一系列大公司已经完成了k8s的线上实践了。不过我们还是比较小，经验不丰富，所以采用最简单的方式，先跑一下，看能否跑通，之后再说下一步。</p>
<h2 id="实际过程"><a href="#实际过程" class="headerlink" title="实际过程"></a>实际过程</h2><h3 id="1-踩的坑"><a href="#1-踩的坑" class="headerlink" title="1. 踩的坑"></a>1. 踩的坑</h3><p>一开始我是想通过在两台机器上各自暴露eureka端口，然后让eureka互相注册，而在每台机器上都启动容器服务并且注册到每台机器eureka上，这种方式理论模型如下图：</p>
<p><img src="/images/qiniu/2018-01-08-18-40-02.png" alt="2018-01-08-18-40-02"></p>
<p>我们在eureka上是看到了这些服务都有注册到了，而且可以明显看到服务的ip地址是：172.17.0.0/16 区间的。貌似一切很正常，然后我们尝试访问服务，在每个服务日志中基本都是<code>NO instance XXX Exception</code>,不是在eureka已经注册了么，为什么还没有了？eureka应该是根据ip地址加端口来找服务的，这种情况下，如果A服务找到D服务，发现注册中心有注册地址ip，找到了ip地址后（不清楚这里是eureka转发，还是eureka将地址发给A，A再请求），但是根据找到的ip去请求服务，也就是在A服务上去找D的ip地址，因为D在Centos服务器上，所以根本不可能到达。那么请求又怎么可能知道了。明显两者应该在不同的。(突然感觉不对劲，如果两个eureka不能相互注册，注册中心又怎么可能启动多个。。。这里待定，感觉有问题。)再回首想一下，嗯，没问题，我们使用bridge网络的时候，是内网。没错，是内网，我们一般使用eureka都是公网，至少也是两台hosts能够相互连通，在同一个网络下。但是使用docker默认的网络是内网，A机器是无法访问B机器的172.xxx的网络的。</p>
<h3 id="2-swarm方式"><a href="#2-swarm方式" class="headerlink" title="2. swarm方式"></a>2. swarm方式</h3><p>在网上找了一圈资料，有在阿里云找到的springcloud项目，并且使用eureka的注册方式，但是他们基于阿里云网络vpc，对于我们不合适，我们是自建机房，尽管没有运维人员去管理。阿里云的方式行不通之后，后来找到swarm，因为我想总有人有这方面（跨主机容器通信）的需求的。刚开始找到了一些是k8s,觉得学习成本有点大，我只是个小java开发，还没强大到那个地步。。。。后来发现swarm好像也可以。一想，swarm毕竟是docker自带的，学习成本应该不大，本且之前也有接触，果断就用swarm做测试。</p>
<h4 id="2-1-创建overlay网络"><a href="#2-1-创建overlay网络" class="headerlink" title="2.1 创建overlay网络"></a>2.1 创建overlay网络</h4><p>swarm 其实管理的就是docker容器，一开始我们使用docker swarm init.然后让它称为manager，其它的docker容器只要join就可以了。这点还是很方便。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker swarm init</span><br><span class="line"></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"></span><br><span class="line">docker swarm join-token worker</span><br></pre></td></tr></table></figure>

<p>这种方式就简单的构建了一个swarm了。然后我们首先创建网络。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create -d overlay springcloud-overlay</span><br></pre></td></tr></table></figure>

<h4 id="2-2-准备镜像"><a href="#2-2-准备镜像" class="headerlink" title="2.2 准备镜像"></a>2.2 准备镜像</h4><p>创建网络后，就开始准备相应的镜像和Dockerfile。根据每个人的环境不同可以准备相应的Dockerfile：</p>
<p>eureka.Dockerfile: 主要作为注册中心用</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./*.jar app.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sh -c <span class="string">&#x27;touch /app.jar&#x27;</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>booksrv.Dockerfile: 做一个无需连接数据库的服务提供者</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./*.jar app.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sh -c <span class="string">&#x27;touch /app.jar&#x27;</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>warehouse.Dockerfile：连接数据库的服务提供者</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./*.jar app.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sh -c <span class="string">&#x27;touch /app.jar&#x27;</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>,<span class="string">&quot;--cacheType=single&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>web.Dockerfile：客户端调用booksrv和warehouse服务的接口</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-jre-alpine</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./*.jar app.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sh -c <span class="string">&#x27;touch /app.jar&#x27;</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>在不同的文件夹下将dockerfile文件准备好之后，我们可以使用<code>docker build -t chenzhijun/imagename .</code>；（chenzhijun/iamgename可以自定义）</p>
<h4 id="2-3-准备yml文件"><a href="#2-3-准备yml文件" class="headerlink" title="2.3 准备yml文件"></a>2.3 准备yml文件</h4><p>我们准备好镜像文件之后，可以使用docker stack的方式部署服务。</p>
<p>eureka.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">eureka1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">chenzhijun/eureka</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">springcloud-overlay:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">eureka</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;1111:1111&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ADDITIONAL_EUREKA_SERVER_LIST=http://eureka2:1111/eureka/</span></span><br><span class="line">  <span class="attr">eureka2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">chenzhijun/eureka</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">springcloud-overlay:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">eureka</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;1112:1111&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ADDITIONAL_EUREKA_SERVER_LIST=http://eureka1:1111/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">springcloud-overlay:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">springcloud-overlay</span></span><br></pre></td></tr></table></figure>

<p>service.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">chenzhijun/web</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">springcloud-overlay</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">EUREKA_SERVER_ADDRESS=http://eureka1:1111/eureka/,http://eureka2:1111/eureka/</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8888&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">bookservice:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">chenzhijun/booksrv</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">springcloud-overlay</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">EUREKA_SERVER_ADDRESS=http://eureka1:1111/eureka/,http://eureka2:1111/eureka/</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">warehouse:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">chenzhijun/warehouse</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">springcloud-overlay</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">EUREKA_SERVER_ADDRESS=http://eureka1:1111/eureka/,http://eureka2:1111/eureka/</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">springcloud-overlay:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">springcloud-overlay</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>docker stack deploy -c eureka.yml(service.yml) eureka(service)</code>。<br>之后可以使用<code>docker stack ls</code>查看启动了哪些服务，使用<code>docker stack services eureka(service)</code>来查看具体的信息。</p>
<p>这个时候，你可以使用<code>docker ps </code>来看机器上启动了哪些服务，然后使用<code>docker logs -f containerid</code>来看输出的日志记录。</p>
<p>嗯基本上就可以看到相应的输出。。</p>
<p>docker swarm的另一种服务创建方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker service create --name warehouse1 \</span><br><span class="line">    --network springcloud-overlay \</span><br><span class="line">    --mount type=bind,source=/home/user/jar/notice/warehouse-server.jar,destination=/user/share/jar/app.jar \</span><br><span class="line">    --env EUREKA_SERVER_ADDRESS=http://eureka1:8761/eureka/,http://eureka2:8761/eureka/ \</span><br><span class="line">    --env MYSQL_SERVER_ADDRESS=mysql:3306 \</span><br><span class="line">    -p :30021 \</span><br><span class="line">    java:8-jre-alpine java -jar /user/share/jar/app.jar --cacheType=single</span><br></pre></td></tr></table></figure>

<p>一些常见的命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker stack --hlep;</span><br><span class="line">docker stack ls;</span><br><span class="line">docker stack deploy -c xxx.yml xx-name;</span><br><span class="line">docker stack services xx-name;</span><br><span class="line"></span><br><span class="line">docker service --help;</span><br><span class="line"></span><br><span class="line">docker network --help;</span><br><span class="line"></span><br><span class="line">docker run ;</span><br><span class="line"></span><br><span class="line">docker --help;</span><br><span class="line"></span><br><span class="line">       docker service create --name warehouse1     --network springcloud-overlay     </span><br><span class="line">       --mount type=bind,source=/home/user/jar/notice/warehouse-server.jar,destination=/user/share/jar/app.jar     </span><br><span class="line">       --env EUREKA_SERVER_ADDRESS=http://eureka1:8761/eureka/,http://eureka2:8761/eureka/     </span><br><span class="line">       --env MYSQL_SERVER_ADDRESS=mysql:3306     </span><br><span class="line">       -p :30021     java:8-jre-alpine java -jar /user/share/jar/app.jar --cacheType=single</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Swarm</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Java 0228</title>
    <url>/2018/02/28/effective-java-0228/</url>
    <content><![CDATA[<h1 id="Effective-Java-0228"><a href="#Effective-Java-0228" class="headerlink" title="Effective Java 0228"></a>Effective Java 0228</h1><h2 id="覆盖equals时候请遵守通用规定"><a href="#覆盖equals时候请遵守通用规定" class="headerlink" title="覆盖equals时候请遵守通用规定"></a>覆盖equals时候请遵守通用规定</h2><pre><code>翻开书，看到了书的第3章-对于所有对象都通用的方法。我们知道，java中一切类都继承自Object，在Object类里面有
两个非常重要的方法：`hashCode()`,`equals()`;

其实Object类里面很多方法的注释非常详细，有一些比较通用的约定。作为我们在重写的时候我们最好是遵守这些约定。
</code></pre>
<p>如果我们要覆盖equals方法，我们需要思考几个问题：</p>
<ol>
<li>我们为什么要覆盖？可不可以不覆盖？各自场景是什么？</li>
<li>怎么覆盖？</li>
<li>有什么需要特别注意的？</li>
</ol>
<p>覆盖equals看起来非常简单，其实坑有蛮多。最好的避免方式当然就是不覆盖了，这样我们可以看到在Object里面的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认equals比较的就是类只与它自身的相等。在何种情况下我们不需要覆盖呢？书上说有四点：</p>
<ol>
<li>类的每个实例本质上是唯一的。</li>
<li>不关心类是否提供“逻辑相等”的测试功能。</li>
<li>超类已经覆盖了equals，从超类继承过来的行为对于子类也合适。</li>
<li>类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用。</li>
</ol>
<p>什么时候需要覆盖，那么肯定就是上面四个的反例或者其它的情况了。一般我们需要比较逻辑上的关系时候，我们可能需要重写equals。这种被称为“值类”。值类也有不需要覆盖的场景:比如单例模式，每个值至多存在一个对象。那么比较值相等的意义就不大了;另一种就是枚举，枚举类型逻辑相同与对象等同是一个意义，因此这两个方式就算不覆盖Object的equals方法也可以。</p>
<p>覆盖equals时候最好也是必须遵守它的通用约定：</p>
<ol>
<li>自反性，x.equals(x) 返回true</li>
<li>对称性，x.eq(y),y.eq(x) 返回true</li>
<li>传递性，x.eq(y),y.eq(z),x.eq(z) 返回true</li>
<li>一致性，多次调用x.eq(y),都应该返回true</li>
<li>与null进行equals(null)的时候必须返回false</li>
</ol>
<p>高质量equals方法的建议：</p>
<ol>
<li>使用==操作符号，查看是否当前比较参数是本身这个对象的引用。如果是返回true。</li>
<li>使用instanceof操作符检查“参数是否是正确的类型”，这个可以帮助我们排序非当前类型的比较，也可以排除null值。</li>
<li>转换instanceof之后的类型为当前this指向的对象的类型。</li>
<li>检查参数中的每个域，是否和该对象中对应的域相等。</li>
</ol>
<p>对于不是float和double的基本类型可以用“==”比较，另两个调用他们的compare方法(为什么compare方法可以了？)。<br>另外可以将最有可能不一样的域提前比较。</p>
<p>覆盖equals的时候一定要一定要一定要覆盖**hashCode()**。</p>
<p>那么hashCode()该怎么覆盖了？下次分享。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch 集群主分片和副本分片</title>
    <url>/2017/12/18/elasaticearch-shard-replicas/</url>
    <content><![CDATA[<p>集群的健康状态查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -XGET &#x27;localhost:9200/_cluster/health?pretty&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;cluster_name&quot;</span>:          <span class="string">&quot;elasticsearch&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;status&quot;</span>:                <span class="string">&quot;green&quot;</span>, </span><br><span class="line">   <span class="attr">&quot;timed_out&quot;</span>:             <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">&quot;number_of_nodes&quot;</span>:       <span class="number">1</span>,</span><br><span class="line">   <span class="attr">&quot;number_of_data_nodes&quot;</span>:  <span class="number">1</span>,</span><br><span class="line">   <span class="attr">&quot;active_primary_shards&quot;</span>: <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;active_shards&quot;</span>:         <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;relocating_shards&quot;</span>:     <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;initializing_shards&quot;</span>:   <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;unassigned_shards&quot;</span>:     <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>status</code>字段是最为重要的，有三个值：green，yellow，red。三者的含义：</p>
<ol>
<li>green：所有主分片和副分片都能正常运行；</li>
<li>yellow: 所有主分片都能正常运行，但不是所有副分片都能正常运行；</li>
<li>red：有主分片没能正常运行。</li>
</ol>
<span id="more"></span>
<p>在es中存数据需要先建立索引，而索引实际上是一个或多个物理分片的逻辑命令空间。</p>
<p>一个分片是一个底层的工作单元，存储全部数据中的一部分。它是一个Lucene的实例，本身它就是完整的搜索引擎。</p>
<p>文档被存储和索引在分片中，应用程序直接与索引交互不是与分片交互。</p>
<blockquote>
<p>理论尚分片可以存储Integer.max_value-128个文档。实际最大值还需要参考你的使用场景：包括你使用的硬件， 文档的大小和复杂程度，索引和查询文档的方式以及你期望的响应时长。</p>
</blockquote>
<p>副本分片是主分片的拷贝，也就是指一个备份。索引在创建的时候就已经确定了确定的分片数量(默认为5个)，一旦索引创建成功，主分片数就不能再改变，但是副分片数可以被随时改变。<br>创建一个确定主分片的数的索引：<br>使用3个主分片和6个主分片分别创建<code>blogs</code>和<code>accounts</code>索引:</p>
<p>3个blogs主分片，1个备份分片</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl -XPUT &#x27;localhost:9200/blogs?pretty&#x27; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;settings&quot; : &#123;</span><br><span class="line">      &quot;number_of_shards&quot; : 3,</span><br><span class="line">      &quot;number_of_replicas&quot; : 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6个accounts主分片，1个备份分片：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl -XPUT &#x27;localhost:9200/accounts?pretty&#x27; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;settings&quot; : &#123;</span><br><span class="line">      &quot;number_of_shards&quot; : 6,</span><br><span class="line">      &quot;number_of_replicas&quot; : 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后结果如图：<br><img src="/images/qiniu/2017-12-18-16-48-44.png" alt="2017-12-18-16-48-44"></p>
<p>如果我们觉得备份分片不够，比如我想将accounts调整为2个备份分片：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl -XPUT &#x27;localhost:9200/accounts/_setting&#x27; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">      &quot;number_of_replicas&quot; : 2</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后结果如图:</p>
<p><img src="/images/qiniu/2017-12-18-16-52-35.png" alt="2017-12-18-16-52-35"></p>
<p>如果我们的备份分片没有分配到节点上，集群的健康值就会变成yellow：</p>
<p><img src="/images/qiniu/2017-12-18-16-56-13.png" alt="2017-12-18-16-56-13"></p>
<p>我们可以为每一个分片(包括主分片，副本分片)分配一个节点。这样会提高我们的搜索效率，节点数/主分片数。</p>
<p>上图的副本分片都没有分配到节点上，全部副本分片都是unassigned，在一个原始数据节点存储副本分片，想想也是知道没有任何意义。该节点挂掉之后，副本数据肯定也会挂掉。</p>
<p>还有一种就是集群健康状态为红：red。这种情况下指的是主分片中有一个或多个主分片为不可用状态。</p>
<p><img src="/images/qiniu/2017-12-18-16-22-15.png" alt="2017-12-18-16-22-15"></p>
]]></content>
  </entry>
  <entry>
    <title>ElasticSearch 简介与使用</title>
    <url>/2017/12/03/elastic-search-introduce/</url>
    <content><![CDATA[<h2 id="ElasticSearch-简介与使用"><a href="#ElasticSearch-简介与使用" class="headerlink" title="ElasticSearch 简介与使用"></a>ElasticSearch 简介与使用</h2><p>Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。Elastic 的底层用的是 Lucene。如果你想用 Lucene的话必须自己去写接口，而Elastic将这些进行了一层封装，并且提供restful接口，让使用者达到开箱即用。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Node-与-Cluster"><a href="#Node-与-Cluster" class="headerlink" title="Node 与 Cluster"></a>Node 与 Cluster</h4><p>Elastic 实际上是一个分布式数据库，它可以存储数据，能够让多台服务器协同工作，每个服务器可以运行多个Elastic服务。每一个Elastic服务实例都可以称作一个节点（Node），一组节点就构成了集群（Cluster）。</p>
<h4 id="Index，Type，Document"><a href="#Index，Type，Document" class="headerlink" title="Index，Type，Document"></a>Index，Type，Document</h4><p>Elastic中通过索引(Index)，类型（Type），文档（Document）三个值来定义了Elastic中存储的数据结构。索引相当于我们在数据库中的库名字，类型相当于表，文档就是实际存储的数据内容。比如一堆书，这个就是“书”索引（Index），按照“武侠”，“技术”等进行分类（Type),每一本书就是实际上存储的数据(Document)。在Elastic中多个文档组成了一个索引，而文档可以通过分类来方便查询。这里的Type实际上是逻辑上的分组。</p>
<h3 id="ES的增删改"><a href="#ES的增删改" class="headerlink" title="ES的增删改"></a>ES的增删改</h3><p>ES的增删改查遵循restful的风格，所以在使用在非常方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 增加</span></span><br><span class="line">POST localhost:<span class="number">9200</span>/accounts/person/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lastname&quot;</span>:<span class="string">&quot;Mic&quot;</span>,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>:<span class="string">&quot;A very handsome man&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line"></span><br><span class="line">DELETE localhost:<span class="number">9200</span>/accounts/person/<span class="number">1</span></span><br><span class="line"></span><br><span class="line">POST accounts/persion/<span class="number">1</span>/_update</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;description&quot;</span>:<span class="string">&quot;this is change description&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES的查询"><a href="#ES的查询" class="headerlink" title="ES的查询"></a>ES的查询</h3><p>为什么要单独讲讲查询？ElasticSearch，从名字中就可以直接看出，search占据了elastic的很大一部分。很多时候我们使用ES也是主要因为它方便的查询功能，在ES中查询的方式有以下几种：</p>
<ol>
<li>不带条件返回所有索引下的所有文档：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET localhost:<span class="number">9200</span>/_search?pretty <span class="comment">// pretty是将返回的json进行格式化</span></span><br><span class="line">GET /_search?size=<span class="number">5</span> <span class="comment">// size 是记录条数</span></span><br><span class="line">GET /_search?size=<span class="number">5</span>&amp;from=<span class="number">5</span> <span class="comment">// from是只从哪页开始，类似SQL分页查询</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据索引，类型，文档id获取到唯一值：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET localhost:<span class="number">9200</span>/accounts/person/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>不带body的查询，<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/search-lite.html">轻量搜索</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回所有文档中有‘jack’的数据</span></span><br><span class="line">GET localhost:<span class="number">9200</span>/accounts/person/_search?q=Jack</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回所有类型中为tweet的tweet字段带有‘elasticsearch’的数据</span></span><br><span class="line">GET /_all/tweet/_search?q=tweet:elasticsearch</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>带body的条件查询：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Query DSL</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GET localhost:<span class="number">9200</span>/accounts/person/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>:&#123;</span><br><span class="line">                <span class="string">&quot;value&quot;</span>:<span class="string">&quot;Jack&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>官方文档提供了一些实例：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/query-dsl-intro.html">查询表达式</a></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch - Java</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch-document-data</title>
    <url>/2017/12/19/elasticsearch-document-data/</url>
    <content><![CDATA[<h2 id="什么是文档"><a href="#什么是文档" class="headerlink" title="什么是文档"></a>什么是文档</h2><p>通常情况下，文档类似与对象。在es的术语中文档指的是根对象，或者称为最顶层对象。它被序列化成json存储在es中，并且有一个唯一ID。</p>
<blockquote>
<p>字段可以是任何字符，但不能包含时间段</p>
</blockquote>
<h3 id="文档的元数据"><a href="#文档的元数据" class="headerlink" title="文档的元数据"></a>文档的元数据</h3><h4 id="索引-index"><a href="#索引-index" class="headerlink" title="索引:_index"></a>索引:_index</h4><p>ES中文档有三个特定的属性：index,type,id;(type可能会在以后的版本中去掉，现在的版本6.0中依然存在)。在es分片中我们提到，数据是存储在索引中的，而索引指的是单个，或者多个分片的逻辑命名空间。索引广义上来说，有点类似我们的数据库database名称。一个库名就对应着一个索引。</p>
<blockquote>
<p>索引名字必须小写，不能以下划线开头，不能有逗号</p>
</blockquote>
<h4 id="类型-type"><a href="#类型-type" class="headerlink" title="类型:_type"></a>类型:_type</h4><p>type的含义是将具有相同属性或相似属性的文档集合在一起。它是索引中对数据的逻辑分区。有点类似于我们在数据库中的表。</p>
<blockquote>
<p>类型名可以是大小写，不能以下划线开头，不能包含逗号，长度限制在256字符。</p>
</blockquote>
<h4 id="唯一ID-id"><a href="#唯一ID-id" class="headerlink" title="唯一ID:_id"></a>唯一ID:_id</h4><p>如果说空间中的一个点由xyz三轴表示，那么es中的文档位置就由索引，类型，id来确定。Id是一个字符串，你可以自己生成，也可以让ES帮你生成。id类似与表中的主键。</p>
<p>文档还有其它的元数据，但是总的来说，最最重要的就是这三个。毕竟你最重要的还是数据(文档)。</p>
<blockquote>
<p>自动生成的 ID 是 URL-safe、 基于 Base64 编码且长度为20个字符的 GUID 字符串。 这些 GUID 字符串由可修改的 FlakeID 模式生成，这种模式允许多个节点并行生成唯一 ID ，且互相之间的冲突概率几乎为零。</p>
</blockquote>
<p>你可以这样理解，图书馆有各种书，管理员将书分成了很多类，每一个类下面有个唯一的书编号，知道这些，你就能找到那本特定的书。其中图书馆就是ElasticSearch，各种书就是index，分类就是type，唯一id就是书编号。实际的那本书就是一个文档。</p>
<h3 id="创建索引文档"><a href="#创建索引文档" class="headerlink" title="创建索引文档"></a>创建索引文档</h3><span id="more"></span>
<ol>
<li>带id创建索引文档,id是你自己生成的唯一id，使用put方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;field&quot;</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果是自动生成的，请使用POST方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST /&#123;index&#125;/&#123;type&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;field&quot;</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取文档"><a href="#获取文档" class="headerlink" title="获取文档"></a>获取文档</h3><p>前面我们说过，如果确定index,type,documentId，我们就能获取一个文档值。对于文档的获取方式我们可以获取到文档的全部值，或者是文档的部分值。</p>
<ol>
<li>根据三元素获取文档全部值：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /website/blog/123?pretty</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> :   <span class="string">&quot;website&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> :    <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> :      <span class="string">&quot;123&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> :    <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> :  &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My first blog entry&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;text&quot;</span>:  <span class="string">&quot;Just trying this out...&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;date&quot;</span>:  <span class="string">&quot;2014/01/01&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中需要注意字段<code>found:true</code>,如果找到了值，这里就是true，如果没有找到，这里回事false，并且响应的HTTP状态码会是404。</p>
<ol start="2">
<li>返回文档的一部分：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /website/blog/123?_source=title,text</span><br></pre></td></tr></table></figure>
<p>这里就是只需要:title,text。返回结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> :   <span class="string">&quot;website&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> :    <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> :      <span class="string">&quot;123&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> :   <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My first blog entry&quot;</span> ,</span><br><span class="line">      <span class="attr">&quot;text&quot;</span>:  <span class="string">&quot;Just trying this out...&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果只需要<code>_source</code>字段不需要任何元数据：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET /website/blog/<span class="number">123</span>/_source</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;My first blog entry&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;text&quot;</span>:  <span class="string">&quot;Just trying this out...&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;date&quot;</span>:  <span class="string">&quot;2014/01/01&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检查文档是否存在"><a href="#检查文档是否存在" class="headerlink" title="检查文档是否存在"></a>检查文档是否存在</h3><p>如果不需要数据，只需要检查在某一个时刻某个文档是否存在，因为有可能这一秒钟结果返回不存在，下一秒钟就创建了，所以用检查的时候主要注意这个时效性。<br>不需要数据的时候我们可以使用HEAD方法来进行请求，格式为：<code>curl -i -XHEAD http://ip:port/index/type/id</code>;<br>比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i -XHEAD http:&#x2F;&#x2F;localhost:9200&#x2F;website&#x2F;blog&#x2F;123</span><br></pre></td></tr></table></figure>

<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>在ES中文档是不可修改的。如果需要更新现有的文档，需要重建索引或者进行替换。也就是说，你可以再调用一次创建索引的接口。<br>只不过在返回的响应中会看到元数据域有部分改变：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> :   <span class="string">&quot;website&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> :    <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> :      <span class="string">&quot;123&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;created&quot;</span>:   <span class="literal">false</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，version已经变成了2，created是false。created为false，是因为相同的索引，type，id已经存在。在内部ElasticSearch会标记旧文档为已删除，并增加一个全新的文档。虽然旧文档不能再访问，但是es不会立即删除它。当索引的数据越来越多的时候，es会在后台删除？(什么时候删除，学完记得看下文档)</p>
<h3 id="确保只能创建文档，非更新"><a href="#确保只能创建文档，非更新" class="headerlink" title="确保只能创建文档，非更新"></a>确保只能创建文档，非更新</h3><p>上面更新的方式我们知道，创建的时候有可能也是更新文档。那么如果保证这次的创建请求,是创建了一个全新的文档而非更新一个文档了？我们可以采取一些手段来保证。</p>
<ol>
<li><p>使用post方式进行增加，让es自动生成文档id</p>
</li>
<li><p>如果采用自己的id，在末尾可以加参数：</p>
</li>
</ol>
<p>a) 使用param的方式创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;website&#x2F;blog&#x2F;123?op_type&#x3D;create</span><br></pre></td></tr></table></figure>
<p>b) 使用restful风格：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;website&#x2F;blog&#x2F;123&#x2F;_create</span><br></pre></td></tr></table></figure>

<p>如果创建过程中有错误，会返回409错误状态码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;error&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;root_cause&quot;</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;document_already_exists_exception&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;[blog][123]: document already exists&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;shard&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;website&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;document_already_exists_exception&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;[blog][123]: document already exists&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;shard&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;website&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">&quot;status&quot;</span>: <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>删除的规则也遵循restful风格，所以类推如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DELETE /website/blog/<span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>如果有值，那么返回200，并且返回json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> :    <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> :   <span class="string">&quot;website&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> :    <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> :      <span class="string">&quot;123&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有找到，将会返回404:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> :    <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> :   <span class="string">&quot;website&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> :    <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> :      <span class="string">&quot;123&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除跟更新一眼哥也是做一个标记操作，不会立即将文档删除，随着索引的数据越来越多，es会在后台进行删除。</p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 安装 (单机单节点/伪集群)</title>
    <url>/2017/12/01/elasticsearch-install/</url>
    <content><![CDATA[<h2 id="ElasticSearch-安装-单机单节点-单机多节点"><a href="#ElasticSearch-安装-单机单节点-单机多节点" class="headerlink" title="ElasticSearch 安装 (单机单节点/单机多节点)"></a>ElasticSearch 安装 (单机单节点/单机多节点)</h2><h3 id="ElasticSearch-简介"><a href="#ElasticSearch-简介" class="headerlink" title="ElasticSearch 简介"></a>ElasticSearch 简介</h3><p>ElasticSearch(ES) 现在已经随着技术发展越来越火爆了。它基于Lucence搜索引擎，实现RestFul风格，开箱即用。广泛用于在网站上做站内搜索。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>这个忒简单了，会上网的人应该都会。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>ES 下载解压后，配置文件主要在<code>config</code>目录下，<br>包含文件：<code>elasticsearch.yml</code>,<code>jvm.options</code>,<code>log4j2.properties</code>。<br>这三个文件分别对应<code>ES配置</code>，<code>JVM配置</code>，<code>ES日志配置</code>。我们这里只讨论<code>elasticsearch.yml</code>的配置，其他的暂时不论。</p>
<h3 id="单机单节点"><a href="#单机单节点" class="headerlink" title="单机单节点"></a>单机单节点</h3><p>单机单节点最爽了，为啥？因为简单啊。进入到解压后文件夹的<code>bin</code>目录，然后window平台双击<code>elasticsearch.bat</code>,*nix平台使用<code>sh elasticsearch</code>,之后再在控制台中看到如下，有个<code>started</code>：</p>
<p><img src="/images/qiniu/2017-12-01-15-42-20.png" alt="2017-12-01-15-42-20"></p>
<p>因为我们什么配置都没改，所以ES使用默认配置，http端口为9200，TCP端口为9300。<br>这个时候我们访问下接口：<code>curl -XGET localhost:9200</code>,或者浏览器打开<code>localhsot:9200</code>,就会看到下面的输出：<br><img src="/images/qiniu/2017-12-01-15-48-31.png" alt="2017-12-01-15-48-31"></p>
<p>单机很简单，真的很简单。</p>
<span id="more"></span>
<h3 id="单机多节点-伪集群"><a href="#单机多节点-伪集群" class="headerlink" title="单机多节点(伪集群)"></a>单机多节点(伪集群)</h3><p>部署完单机，下面就是集群了。集群，什么是集群了？一个服务在多台机器上部署，并且这些服务之间彼此之间内部高度紧密协作拥有某种联系，我们可以当作是这个服务的集群。在某种含义上，可以认为是一台服务器。</p>
<p>ES 伪集群：es服务在同一台机器上根据不同的端口启动服务，构成在本机上的一个集群模式。</p>
<p><img src="/images/qiniu/2017-12-03-14-57-03.png" alt="2017-12-03-14-57-03"></p>
<p>以此为基础，我们来看看怎么配置。</p>
<p>主要<strong>用到的配置属性</strong>有这些，</p>
<p><img src="/images/qiniu/2017-12-01-16-09-24.png" alt="2017-12-01-16-09-24"></p>
<p>我的本地ip地址为：<code>192.168.11.21</code>,</p>
<p>master 的 elasticsearch.yml:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">notice-application</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.21</span></span><br><span class="line"><span class="comment"># network.bind_host: 192.168.11.21</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;192.168.11.21:9300&quot;</span>,<span class="string">&quot;192.168.11.21:9310&quot;</span>,<span class="string">&quot;192.168.11.21:9320&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>slave1 的 elasticsearch.yml:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">notice-application</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">slave1</span></span><br><span class="line"><span class="comment"># network.publish_host: 192.168.11.21</span></span><br><span class="line"><span class="comment"># network.bind_host: 192.168.11.21</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.21</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9210</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9310</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;192.168.11.21:9300&quot;</span>,<span class="string">&quot;192.168.11.21:9310&quot;</span>,<span class="string">&quot;192.168.11.21:9320&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>slave2 的 elasticsearch.yml:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">notice-application</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">slave2</span></span><br><span class="line"><span class="comment"># network.publish_host: 192.168.11.21</span></span><br><span class="line"><span class="comment"># network.bind_host: 192.168.11.21</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.21</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9220</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9320</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;192.168.11.21:9300&quot;</span>,<span class="string">&quot;192.168.11.21:9310&quot;</span>,<span class="string">&quot;192.168.11.21:9320&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>上面的配置，如果要你要体验下可以拷贝到你自己的ES中，将IP改成你的本地ip就可以看到了。</p>
<p>推荐一个图形化工具：<a href="https://github.com/mobz/elasticsearch-head">elasticsearh-head</a>,这货尽然还推出了<a href="https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm?utm_source=chrome-ntp-icon">Chrome 插件</a>。简直完美。</p>
<p>安装之后你就可以head插件看到集群配置了，下面是我的集群启动，电脑配置不太够，只启动了两台服务。<br><img src="/images/qiniu/2017-12-01-16-23-25.png" alt="2017-12-01-16-23-25"></p>
<p>现在说正题，我们说下配置：</p>
<ol>
<li><p><code>cluster.name</code>: 它指代的是集群的名字，一个集群的名字必须唯一，节点根据集群名字加入到集群中</p>
</li>
<li><p><code>node.name</code>: 节点名称，可以是自定义的方便分辨的名字，记住master也是一个节点。eg:master,slave</p>
</li>
<li><p><code>node.master</code>: true/false 是否是集群中的主节点。</p>
</li>
<li><p><code>network.host</code>: 设置<code>network.bind_host</code> 和 <code>publish_host</code>的默认值，这里设置成127.0.0.1和主机ip是有区别的，你可以使用curl -XGET “<a href="http://network.host/9200&quot;%E7%9C%8B%E5%88%B0%E7%BB%93%E6%9E%9C">http://network.host/9200&quot;看到结果</a></p>
</li>
<li><p><code>network.bind_host</code>: 绑定服务器ip地址</p>
</li>
<li><p><code>network.publish_host</code>: 绑定发布的地址</p>
</li>
<li><p><code>http.port</code>: HttpRest 的接口，这个接口可以让你在浏览器访问</p>
</li>
<li><p><code>transport.tcp.port</code>: 给Java或者其它节点的服务端口，代码里面用这个。</p>
</li>
<li><p><code>discovery.zen.ping.unicast.hosts</code>: 这里是一组IP,我一般是使用<code>ip:port</code>这种书写方式，还有很多种方式，详情：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-zen.html">zen的介绍</a></p>
</li>
</ol>
<h3 id="安装中文分词插件"><a href="#安装中文分词插件" class="headerlink" title="安装中文分词插件"></a>安装中文分词插件</h3><p>ElasticSearch 默认的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html">分词器</a>对于中文的分词不是特别友好，英文的词使用空格隔开的，但是中文就不一样了。默认的分词器会将中文的字一个一个拆分，比如“中国”，默认的分词器就是“中”，“国”，然后去匹配。所以我们需要安装一个中文分词器，这里我选择的是<a href="https://github.com/medcl/elasticsearch-analysis-ik/">IK插件</a>，它提供了一些友好的中文分词器，并且支持热更新分词热更新，注意根据自己的ES版本来选择IK的版本。github的readme上有两种安装方式，一种是用命令行模式：<code>./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.0.0/elasticsearch-analysis-ik-6.0.0.zip</code>。</p>
<p>另一种就是解压缩包安装方式，去<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a>下载合适的release版本，然后解压到ES根目录下的plugins目录。</p>
<p>IK 提供了两种分词器：<code>ik_max_word</code>和<code>ik_smart_word</code>。</p>
<!--
在`elasticsearch.yml`中配置默认的分词器：

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index.analysis.analyzer.default.tokenizer :</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line"><span class="attr">index.analysis.analyzer.default.type:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br></pre></td></tr></table></figure>
<p>–&gt;<br>注意：如果要使用IK，你需要进行配置analyzer（字段文本的分词器），search_analyzer（搜索词的分词器）</p>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/_installation.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/_installation.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-network.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-network.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-zen.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-zen.html</a></p>
<p>分词器：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/custom-analyzers.html">https://www.elastic.co/guide/cn/elasticsearch/guide/cn/custom-analyzers.html</a> ，<br><a href="https://www.elastic.co/search?q=%E5%88%86%E8%AF%8D&amp;section=Learn/Docs/Elasticsearch/Definitive+Guide%EF%BC%8C">https://www.elastic.co/search?q=%E5%88%86%E8%AF%8D&amp;section=Learn%2FDocs%2FElasticsearch%2FDefinitive+Guide，</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis.html">https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis.html</a> </p>
<p>配置分词器：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/configuring-analyzers.html">https://www.elastic.co/guide/cn/elasticsearch/guide/cn/configuring-analyzers.html</a></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch - Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ELK+Filebeat搭建日志中心</title>
    <url>/2017/12/12/elasticsearch-logstash-kibana-part/</url>
    <content><![CDATA[<h2 id="基于ELK-Filebeat搭建日志中心"><a href="#基于ELK-Filebeat搭建日志中心" class="headerlink" title="基于ELK+Filebeat搭建日志中心"></a>基于ELK+Filebeat搭建日志中心</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ol>
<li>ubuntu 16</li>
<li>jdk 1.8</li>
<li>elasticesearch 6.0, kibana 6.0, logstash 6.0, filebeat 6.0</li>
</ol>
<blockquote>
<p>我也在windows10下安装过，win10下只需要修改filebeat的文件路径配置就可以了。</p>
</blockquote>
<h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>elastic提供了非常多的工具，官方称为Elastic Stack。它提供了一些<a href="https://www.elastic.co/cn/solutions">解决方案</a>。我们用到的就是其中Stack中的部分工具</p>
<ol>
<li><a href="https://www.elastic.co/cn/downloads/elasticsearch">Elasticsearch</a></li>
</ol>
<p>Elasticsearch 是一个分布式、可扩展开源全文搜索和分析引擎。它能够进行存储，并且能以很快的速度(接近实时)来进行搜索和分析大量的数据。它使用Java编写，底层基于Apache Lucene。</p>
<ol start="2">
<li><a href="https://www.elastic.co/cn/downloads/logstash">Logstash</a></li>
</ol>
<p>Logstash 是一个开源的，服务端数据处理管道。 它可同时从多个源来搜集数据，对数据进行过滤等操作，并且将数据传送到你想要传送的地方进行存储。</p>
<ol start="3">
<li><a href="https://www.elastic.co/cn/downloads/kibana">Kibana</a></li>
</ol>
<p>Kibana 被设计成一个和Elasticsearch共同使用的开源分析和可视化平台，它支持将ES中存储的数据生成多种维度的图等。</p>
<ol start="4">
<li><a href="https://www.elastic.co/downloads/beats/filebeat">Filebeat</a></li>
</ol>
<p>Filebeat 是一个轻量级的日志采集器，用于将源数据采集后发送给Logstash，并且Filebeat使用背压敏感协议，以考虑更多的数据量。如果Logstash正在忙于处理数据，则可以让Filebeat知道减慢读取速度。还有很多Beat可以提供选择，有监控网络的Packbeat，指标Metricbeat。各种beat详情：<a href="https://www.elastic.co/cn/products/beats">https://www.elastic.co/cn/products/beats</a></p>
<p>系统架构简图如下：</p>
<p><img src="/images/qiniu/2017-12-13-09-21-45.png" alt="2017-12-13-09-21-45"></p>
<span id="more"></span>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>将ELK和filebeat下载后解压到一个目录下，四个产品都是开箱即用的。</p>
<h4 id="Logstash安装与配置"><a href="#Logstash安装与配置" class="headerlink" title="Logstash安装与配置"></a>Logstash安装与配置</h4><p>Logstash的作用主要是用来处理数据，当然它也可以直接从日志文件读取记录然后进行处理。在Logstash的<strong>根目录</strong>，我们需要建立一个新文件<code>logstash.conf</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置logstash输入源</span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    host &#x3D;&gt; &quot;localhost&quot;</span><br><span class="line">    port &#x3D;&gt; &quot;5043&quot; #注意要和filebeat的输出端口一致</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置输出的地方</span><br><span class="line">output &#123;</span><br><span class="line">  # 控制台</span><br><span class="line">  stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span><br><span class="line">  # es</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">        hosts &#x3D;&gt; [ &quot;localhost:9200&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Filebeat安装与配置"><a href="#Filebeat安装与配置" class="headerlink" title="Filebeat安装与配置"></a>Filebeat安装与配置</h4><p>Filebeat作为日志搜集器，肯定是需要指定输入源和输出地，所以我们需要先配置它。在Filebeat的根目录下我们需要在<code>filebeat.yml</code>中:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 输入源</span></span><br><span class="line"><span class="attr">filebeat.prospectors:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/*.log</span> <span class="comment"># 日志文件以log结尾并且需要放在/var/log目录下</span></span><br><span class="line">    <span class="comment"># 如果是windows,如下</span></span><br><span class="line">    <span class="comment"># - C:\Users\chen\Desktop\elastic\elkjava\log\*.log</span></span><br><span class="line"><span class="comment"># 输出地</span></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="comment"># The Logstash hosts</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;localhost:5043&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Elasticsearch和Kibana安装与配置"><a href="#Elasticsearch和Kibana安装与配置" class="headerlink" title="Elasticsearch和Kibana安装与配置"></a>Elasticsearch和Kibana安装与配置</h4><p>这次演示我们对es和kibana不做特别的配置，就默认就好了。</p>
<h4 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h4><p>其实没有特别的顺序，我一般的启动顺序是elasticsearch-&gt;logsatsh-&gt;kibana-&gt;filebeat。其实差别都不大，特别注意一个就是，如果你想要测试的话，logstash支持配置自动更新，如果是日志文件更新，想让filebeat重新再搜索一次，删除掉filebeat根目录下<code>data/registry</code>文件。其实类推，如果要删除其它的软件(elk)的的数据，删掉<code>data</code>目录,很直接很暴力，但不建议在正式场景直接这样弄。</p>
<p>启动es:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure>

<p>启动logstash：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试conf文件是否正确配置</span></span><br><span class="line">./bin/logstash -f logstash.conf --config.test_and_exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动logstash，如果有修改conf会自动加载</span></span><br><span class="line">./bin/logstash -f logstash.conf --config.reload.automatic</span><br></pre></td></tr></table></figure>

<p>启动kibana：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kibana</span><br></pre></td></tr></table></figure>

<p>启动filebeat:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c filebeat.yml -d &quot;publish&quot;</span><br></pre></td></tr></table></figure>

<p>现在在浏览器中输入：<a href="http://localhost:5601/">http://localhost:5601</a>打开kibana，</p>
<p>看到下面的图：<br><img src="/images/qiniu/2017-12-12-20-38-18.png" alt="2017-12-12-20-38-18"></p>
<p>点击create，之后再点击左侧导航栏Discover：</p>
<p><img src="/images/qiniu/2017-12-12-20-39-51.png" alt="2017-12-12-20-39-51"></p>
<p>就能看到值了。</p>
<p>不管怎么样，一定要动手实验才知道能不能行。</p>
<h3 id="进阶实战：收集Java日志"><a href="#进阶实战：收集Java日志" class="headerlink" title="进阶实战：收集Java日志"></a>进阶实战：收集Java日志</h3><p>上面搭建的elk是可以用的，但是在实际中我发现一些需要处理的地方，比如Java的日志文件经常将堆栈打印出来，这个时候如果还是按照上面的配置，我们无法正确的显示在kibana中，因为我们上面实际配置的是按行读取的。但是堆栈信息应该是一条。所以我们需要对日志进行一些多行处理。<br>可以在filebeat中处理，也可以在logstash中处理。<br>我们今天直接在filebeat中处理，让logstash只做日志的过滤。</p>
<p>首先准备一份Java的日志文件,大致的日志文件都会像下面这样格式：<code>date log-level log-message</code>=》<code>时间 日志级别 日志内容</code>，下面是一个抛出空指针的文件(有删减)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">12</span>-<span class="number">06</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">38</span>,<span class="number">927</span> WARN ExceptionHandlerExceptionResolver:<span class="number">391</span> Failed to invoke <span class="meta">@ExceptionHandler</span> method: <span class="keyword">public</span> com.framework.common.model.ResultData com.elasticsearch.exception.IntegralExceptionHandler.exceptionHandler(java.lang.Exception)</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">	at com.framework.common.util.SpringUtils.getMessage(SpringUtils.java:<span class="number">152</span>) ~[classes/:?]</span><br><span class="line">	at com.framework.common.util.SpringUtils.getMessage(SpringUtils.java:<span class="number">138</span>) ~[classes/:?]</span><br><span class="line">	at com.framework.common.util.SpringUtils.getMessage(SpringUtils.java:<span class="number">57</span>) ~[classes/:?]</span><br><span class="line">	at com.elasticsearch.exception.IntegralExceptionHandler.exceptionHandler(IntegralExceptionHandler.java:<span class="number">33</span>) ~[classes/:?]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:<span class="number">1.8</span><span class="number">.0_121</span>]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>) ~[?:<span class="number">1.8</span><span class="number">.0_121</span>]</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>) ~[?:<span class="number">1.8</span><span class="number">.0_121</span>]</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>) ~[?:<span class="number">1.8</span><span class="number">.0_121</span>]</span><br></pre></td></tr></table></figure>

<p>在filebeat中主要是将堆栈信息的内容合并到一行中，也就是说发送给logstash的时候将下面的异常堆栈当作log-message，让filebeat读取到堆栈的时候将空行转义成字符串然后将这行的信息补充到第一行后面。我们可以使用filebeat的multiline配置,详情：<a href="https://www.elastic.co/guide/en/beats/filebeat/current/multiline-examples.html">https://www.elastic.co/guide/en/beats/filebeat/current/multiline-examples.html</a></p>
<p><code>filebeat.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.prospectors:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/log/*.log</span> <span class="comment"># 日志文件以log结尾并且需要放在/var/log目录下</span></span><br><span class="line">    <span class="comment"># 如果是windows,如下</span></span><br><span class="line">    <span class="comment"># - C:\Users\chen\Desktop\elastic\elkjava\log\*.log</span></span><br><span class="line">  <span class="attr">multiline:</span> <span class="comment"># 多行处理，正则表示如果前面几个数字不是4个数字开头，那么就会合并到一行</span></span><br><span class="line">      <span class="attr">pattern:</span> <span class="string">^\d&#123;4&#125;</span></span><br><span class="line">      <span class="attr">negate:</span> <span class="literal">true</span> <span class="comment"># 正则是否开启，默认false不开启</span></span><br><span class="line">      <span class="attr">match:</span> <span class="string">after</span> <span class="comment"># 不匹配的正则的行是放在上面一行的前面还是后面</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="comment"># The Logstash hosts</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;localhost:5043&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样的这次我们对Java日志做一些信息提炼，也就是使用过滤规则，将date，log-level,log-message等提取出来：</p>
<p><code>logstash.conf</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    host &#x3D;&gt; &quot;localhost&quot;</span><br><span class="line">    port &#x3D;&gt; &quot;5043&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">			match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;TIMESTAMP_ISO8601:timestamp&#125; %&#123;LOGLEVEL:level&#125; %&#123;JAVALOGMESSAGE:msg&#125;&quot; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">        hosts &#x3D;&gt; [ &quot;localhost:9200&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的就是我们使用filter插件，在其中我们使用了grok(基于正则表达式)过滤我们的日志内容。grok可以将无规则的日志数据通过正则匹配将之转换成有结构的数据，以此我们能够根据相应结构进行查询。grok的使用方式是：<code>%&#123;规则:自定义字段名称&#125;</code><br><a href="https://www.elastic.co/guide/en/logstash/5.4/plugins-filters-grok.html">grok详情</a><br>Logstash提供了很多grok表达式，详情可以看：<a href="https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns">https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns</a></p>
<p>为了效果，我们可以删除filebeat，es，logstash，kibana等根目录的data文件，然后按照之前的步骤重启这些工具，<br>现在可以在kibana中看到相应的结果了：</p>
<p>先看到我们自定义的字段：</p>
<p><img src="/images/qiniu/2017-12-13-10-02-27.png" alt="2017-12-13-10-02-27"></p>
<p>在Discover中过滤字段：</p>
<p><img src="/images/qiniu/2017-12-13-10-04-07.png" alt="2017-12-13-10-04-07"></p>
<p>结果：</p>
<p><img src="/images/qiniu/2017-12-13-10-07-04.png" alt="2017-12-13-10-07-04"></p>
<p>目前就告一段落了，最主要的是自己动手时间。接下准备做的事情是将这些能一个Dockerfile，然后只需要自己配置下filebeat的收集目录和logstash的过滤规则，我们就能使用了。<br>不管怎样只有自己动手去做了，才会知道有很多坑需要填。我也在google搜了很多资料，本来想在文后加个参考链接的，后来发现太多了。算了，还是不贴链接了。总之，谢谢哪些我在网上搜资料给了我灵感，帮我跨过一些坑的人。谢谢。</p>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK - Java</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式文档存储</title>
    <url>/2017/12/21/elasticsearch-routing-data-to-shards/</url>
    <content><![CDATA[<h2 id="ES-分布式文档存储"><a href="#ES-分布式文档存储" class="headerlink" title="ES 分布式文档存储"></a>ES 分布式文档存储</h2><h3 id="路由文档到分片"><a href="#路由文档到分片" class="headerlink" title="路由文档到分片"></a>路由文档到分片</h3><p>创建索引的时候通常我们确定了几个主分片，主分片的数量已经确定，但是输入是存在那个分片？是怎么确定的？是通过一个公司算出来的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shard &#x3D; hash(routing)%number_of_primary_shards</span><br></pre></td></tr></table></figure>

<p>其中routing默认是文档的id，当然也可以自定义routing的值。</p>
<span id="more"></span>

<h3 id="集群中操作"><a href="#集群中操作" class="headerlink" title="集群中操作"></a>集群中操作</h3><p>我们可以往任意节点发送请求，每个节点都有能力处理任意请求。每个节点知道任意文档的位置，并且可以直接将需求转发到响应的节点上。这种节点称为协调节点。比如向node1发送数据请求，node1找到了0分片，然后发现0分片在node1，node2，node3个节点上，然后node1，通过轮询所有分片的来发送请求到哪一个节点做到负载均衡。</p>
<blockquote>
<p>在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的</p>
</blockquote>
<p>任何文档的CRUD操作都必须现在主分片上进行，然后复制到相关的副本分片。这个操作过程ES允许进行配置。</p>
<p>在集群中更新一个文档的步骤：<br><img src="/images/qiniu/2017-12-21-11-34-49.png" alt="2017-12-21-11-34-49"></p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 搜索基础</title>
    <url>/2017/12/21/elasticsearch-search-base/</url>
    <content><![CDATA[<h2 id="Elasticsearch-搜索基础"><a href="#Elasticsearch-搜索基础" class="headerlink" title="Elasticsearch 搜索基础"></a>Elasticsearch 搜索基础</h2><h3 id="三大概念"><a href="#三大概念" class="headerlink" title="三大概念"></a>三大概念</h3><ol>
<li>映射（Mapping）：描叙数据在每个字段中如何存储；</li>
<li>分析（Analysis）：全文是如何处理使之可以被搜索；</li>
<li>领域特定查询语言（QueryDSL）：Elasticsearch 查询语言，json格式。</li>
</ol>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker搭建ELK日志系统</title>
    <url>/2017/12/27/elk-docker/</url>
    <content><![CDATA[<h1 id="使用Docker搭建ELK日志系统"><a href="#使用Docker搭建ELK日志系统" class="headerlink" title="使用Docker搭建ELK日志系统"></a>使用Docker搭建ELK日志系统</h1><p>之前用本地版本安装了ELK之后，就没有再去弄它了。年底没那么忙，心里一直惦记，所以最近又开始折腾了。去elastic官网看一下，果然版本帝就是版本帝，一周一版本。现在我用的版本是基于6.1.1版本的。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>收集Java日志文件，并且根据文件的不同将日志分类，比如：订单日志，客户日志等。</li>
<li>日志文件多行处理</li>
</ol>
<h2 id="总体架构图"><a href="#总体架构图" class="headerlink" title="总体架构图"></a>总体架构图</h2><p><img src="/images/qiniu/2017-12-28-11-23-36.png" alt="2017-12-28-11-23-36"></p>
<h2 id="准备镜像"><a href="#准备镜像" class="headerlink" title="准备镜像"></a>准备镜像</h2><p>6.0之后官方开始自己维护镜像版本:<a href="https://www.docker.elastic.co/">https://www.docker.elastic.co/</a>。找到需要的ELK镜像地址，pull下来就好了。官方pull下来之后镜像名太长了，所以我将镜像全部重新打了tag，命令：<code>docker tag docker.elastic.co/elasticsearch/elasticsearch:6.1.1 elasticsearch:latest</code>。<br>使用<code>docker images</code>查看：<br><img src="/images/qiniu/2017-12-27-14-49-10.png" alt="2017-12-27-14-49-10"></p>
<span id="more"></span>
<h2 id="安装docker版本ElasticSearch"><a href="#安装docker版本ElasticSearch" class="headerlink" title="安装docker版本ElasticSearch"></a>安装docker版本ElasticSearch</h2><p>在elasticsearch的docker版本文档中，官方提到了<code>vm.max_map_count</code>的值在生产环境最少要设置成262144。设置的方式有两种</p>
<ol>
<li>永久性的修改,在<code>/etc/sysctl.conf</code>文件中添加一行：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep vm.max_map_count /etc/sysctl.conf # 查找当前的值。</span><br><span class="line"></span><br><span class="line">vm.max_map_count=262144 # 修改或者新增</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>正在运行的机器：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后我们执行命令，暴露容器的9200，9300端口，方便我们在其它集器上可以通过类似head插件去做es索引的操作等。执行命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 --name elasticsearch -e &quot;discovery.type=single-node&quot; elasticsearch</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果实际使用中，可能需要设置集群等操作。因实际情况而定。如果你需要存储历史数据，那么就可能需要将data目录保存到本地，使用-v，或者mount参数挂载本地一个目录。</p>
</blockquote>
<h2 id="安装docker版本kibana"><a href="#安装docker版本kibana" class="headerlink" title="安装docker版本kibana"></a>安装docker版本kibana</h2><p>kibana的作用主要是帮助我们将日志文件可视化。便于我们操作，统计等。它需要ES服务，所以我们将部署好的es和kibana关联起来，主要用到的参数是<code>--link</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5601:5601 --link elasticsearch -e ELASTICSEARCH_URL=http://elasticsearch:9200 kibana</span><br></pre></td></tr></table></figure>

<p>使用link参数，会在kibana容器hosts文件中加入<code>elasticsearch ip地址</code>，这样我们就直接通过定义的name来访问es服务了。</p>
<h2 id="安装logstash和filebeat"><a href="#安装logstash和filebeat" class="headerlink" title="安装logstash和filebeat"></a>安装logstash和filebeat</h2><p>前面的kibana和ES的安装，如果我们在开发环境中并不需要太多的关注他们的详细配置。但是logstash和filebeat我们需要注意下它的配置，因为这两者是我们完成需求的重要点。</p>
<p>logstash我们只让它进行日志处理，处理完之后将其输出到elasticsearch。</p>
<p>filebeat是一个轻量级收集器，我们使用它来收集Java日志，将不同文件夹下的日志进行tag，处理多行日志行为(主要针对Java异常信息)，之后发送给logstash。</p>
<p>日志的文件格式大概就是：<code>DATE LOG-LEVEL LOG-MESSAGE</code>，格式是在<code>log4j.properties</code>中定义的。你也可以自己定义输出格式。</p>
<p>现在我们定义<code>logstash.conf</code>,主要在logstash中使用grok filter插件。</p>
<p><code>logstash.conf</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    #host &#x3D;&gt; &quot;localhost&quot;</span><br><span class="line">    port &#x3D;&gt; &quot;5043&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">   if [fields][doc_type] &#x3D;&#x3D; &#39;order&#39; &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">			match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;TIMESTAMP_ISO8601:timestamp&#125; %&#123;LOGLEVEL:level&#125; %&#123;JAVALOGMESSAGE:msg&#125;&quot; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if [fields][doc_type] &#x3D;&#x3D; &#39;customer&#39; &#123; # 这里写两个一样的grok，实际上可能出现多种不同的日志格式，这里做个提示而已,当然如果是相同的格式，这里可以不写的</span><br><span class="line">    grok &#123;</span><br><span class="line">			match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;TIMESTAMP_ISO8601:timestamp&#125; %&#123;LOGLEVEL:level&#125; %&#123;JAVALOGMESSAGE:msg&#125;&quot; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">        hosts &#x3D;&gt; [ &quot;localhost:9200&quot; ]</span><br><span class="line">        index &#x3D;&gt; &quot;%&#123;[fields][doc_type]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在logstash.conf中，我们主要使用<code>[fields][doc_type]</code>来标明日志的类型，这个值实在filebeat中定义的。</p>
<p>现在我们假定需要收集两个目录下的日志文件：<code>/home/user/elk/customer/*.log</code>，<code>/home/user/elk/order/*.log</code>：</p>
<p><code>customer.log</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2017-12-26 10:05:56,476 INFO ConfigClusterResolver:43 - Resolving eureka endpoints via configuration</span><br><span class="line">2017-12-26 10:07:23,529 INFO WarehouseController:271 - findWarehouseList,json&#123;&quot;formJSON&quot;:&#123;&quot;userId&quot;:&quot;885769620971720708&quot;&#125;,&quot;requestParameterMap&quot;:&#123;&#125;,&quot;requestAttrMap&quot;:&#123;&quot;name&quot;:&quot;asdf&quot;,&quot;user&quot;:&quot;8857696&quot;,&quot;ip&quot;:&quot;183.63.112.1&quot;,&quot;source&quot;:&quot;asdfa&quot;,&quot;customerId&quot;:&quot;885768861337128965&quot;,&quot;IMEI&quot;:&quot;863267033748196&quot;,&quot;sessionId&quot;:&quot;xm1cile2bcmb15wtqmjno7tgz&quot;,&quot;sfUSCSsadDDD&quot;:&quot;asdf&#x2F;10069&amp;ADR&amp;1080&amp;1920&amp;OPPO R9s Plus&amp;Android6.0.1&quot;,&quot;URI&quot;:&quot;&#x2F;warehouse-service&#x2F;appWarehouse&#x2F;findByCustomerId.apec&quot;,&quot;encryptType&quot;:&quot;2&quot;,&quot;requestStartTime&quot;:3450671468321405&#125;&#125;</span><br><span class="line">2017-12-26 10:07:23,650 INFO WarehouseServiceImpl:325 - warehouse list:8,warehouse str:[&#123;&quot;addressDetail&quot;:&quot;nnnnnnnn&quot;,&quot;areaId&quot;:&quot;210624&quot;,&quot;areaNa&quot;:&quot;&quot;&#125;]</span><br><span class="line">2017-12-26 10:10:56,477 INFO ConfigClusterResolver:43 - Resolving eureka endpoints via configuration</span><br><span class="line">2017-12-26 10:15:56,477 INFO ConfigClusterResolver:43 - Resolving eureka endpoints via configuration</span><br><span class="line">2017-12-26 10:20:56,478 INFO ConfigClusterResolver:43 - Resolving eureka endpoints via configuration</span><br><span class="line">2017-12-26 10:05:56,476 INFO ConfigClusterResolver:43 - Resolving eureka endpoints via configuration</span><br><span class="line">2017-12-26 10:07:23,529 INFO WarehouseController:271 - findWarehouseList,json&#123;&quot;formJSON&quot;:&#123;&quot;userId&quot;:&quot;885769620971720708&quot;&#125;&#125;]</span><br><span class="line">2017-12-26 10:10:56,477 INFO ConfigClusterResolver:43 - Resolving eureka endpoints via configuration</span><br><span class="line">2017-12-26 10:15:56,477 INFO ConfigClusterResolver:43 - Resolving eureka endpoints via configuration</span><br><span class="line">2017-12-26 10:20:56,478 INFO ConfigClusterResolver:43 - Resolving eureka endpoints via configuration</span><br></pre></td></tr></table></figure>

<p><code>order.log</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2017-12-26 11:29:19,374 INFO WebLogAspect:53 -- 请求:18,SPEND TIME:0</span><br><span class="line">2017-12-26 11:38:20,404 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 11:41:07,754 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 12:38:58,683 INFO RedisClusterConfig:107 -- &#x2F;&#x2F;&#x2F;&#x2F; --- 启动单点Redis ---</span><br><span class="line">2017-12-26 12:39:00,325 DEBUG ApplicationContextRegister:26 -- </span><br><span class="line">2017-12-26 12:39:06,961 INFO NoticeServiceApplication:57 -- Started NoticeServiceApplication in 17.667 seconds (JVM running for 18.377)</span><br><span class="line">2017-12-26 11:27:56,577 INFO WebLogAspect:51 -- 请求:19,RESPONSE:&quot;&#123;\&quot;data\&quot;:null,\&quot;errorCode\&quot;:\&quot;\&quot;,\&quot;errorMsg\&quot;:\&quot;\&quot;,\&quot;repeatAct\&quot;:\&quot;\&quot;,\&quot;succeed\&quot;:true&#125;&quot;</span><br><span class="line">2017-12-26 11:27:56,577 INFO WebLogAspect:53 -- 请求:19,SPEND TIME:1</span><br><span class="line">2017-12-26 11:28:09,829 INFO WebLogAspect:42 -- 请求:20,URL:http:&#x2F;&#x2F;192.168.7.203:30004&#x2F;sr&#x2F;flushCache</span><br><span class="line">2017-12-26 11:28:09,830 INFO WebLogAspect:43 -- 请求:20,HTTP_METHOD:POST</span><br><span class="line">2017-12-26 11:28:09,830 INFO WebLogAspect:44 -- 请求:20,IP:192.168.7.98</span><br><span class="line">2017-12-26 11:28:09,830 INFO WebLogAspect:45 -- 请求:20,CLASS_METHOD:com.notice.web.estrictController</span><br><span class="line">2017-12-26 11:28:09,830 INFO WebLogAspect:46 -- 请求:20,METHOD:flushRestrict</span><br><span class="line">2017-12-26 11:28:09,830 INFO WebLogAspect:47 -- 请求:20,ARGS:[&quot;&#123;\n&#125;&quot;]</span><br><span class="line">2017-12-26 11:28:09,830 DEBUG SystemRestrictController:231 -- 刷新权限限制链</span><br><span class="line">2017-12-26 11:38:20,404 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 11:41:07,754 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 11:41:40,664 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 11:43:38,224 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 11:47:49,141 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 11:51:02,525 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 11:52:28,726 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 11:53:55,301 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 11:54:26,717 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 11:58:48,834 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 12:38:51,126 INFO NoticeServiceApplication:664 -- The following profiles are active: test</span><br><span class="line">2017-12-26 12:38:58,683 INFO RedisClusterConfig:107 -- &#x2F;&#x2F;&#x2F;&#x2F; --- 启动单点Redis ---</span><br><span class="line">2017-12-26 12:39:00,325 DEBUG ApplicationContextRegister:26 -- ApplicationContextRegister.setApplicationContext:applicationContextorg.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@5f150435: startup date [Tue Dec 26 12:38:51 CST 2017]; parent: org.springframework.context.annotation.AnnotationConfigApplicationContext@63c12fb0</span><br><span class="line">2017-12-26 12:39:06,961 INFO NoticeServiceApplication:57 -- Started NoticeServiceApplication in 17.667 seconds (JVM running for 18.377)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>日志的文件格式大概就是：<code>DATE LOG-LEVEL LOG-MESSAGE</code>，格式我们是在<code>log4j.properties</code>中定义的。你可以自己定义，自定义注意修改logstash.conf中的grok就好。</p>
<p>之后解决我们的filebeat要解决的问题：收集日志，处理多行日志，给日志打标签。在<code>filebeat.yml</code>中,如下定义：</p>
<p><code>filebeat.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- paths:</span><br><span class="line">    - &#x2F;home&#x2F;user&#x2F;elk&#x2F;logs&#x2F;order&#x2F;*.log</span><br><span class="line">  multiline:</span><br><span class="line">      pattern: ^\d&#123;4&#125;</span><br><span class="line">      negate: true</span><br><span class="line">      match: after</span><br><span class="line">  fields:</span><br><span class="line">    doc_type: order</span><br><span class="line">- paths:</span><br><span class="line">    - &#x2F;home&#x2F;user&#x2F;elk&#x2F;logs&#x2F;customer&#x2F;*.log</span><br><span class="line">  multiline:</span><br><span class="line">      pattern: ^\d&#123;4&#125;</span><br><span class="line">      negate: true</span><br><span class="line">      match: after</span><br><span class="line">  fields:</span><br><span class="line">    doc_type: customer</span><br><span class="line">output.logstash: # 输出地址</span><br><span class="line">  hosts: [&quot;logstash:5043&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>收集日志：直接使用prospector定位并且处理日志文件。</li>
<li>多行日志: 根据日志格式，我们开头都是yyyy，类似与纯4个数字，所以我们使用multile插件，做配置就好。官方的文档挺详细的，主要就是实践：<a href="https://www.elastic.co/guide/en/beats/filebeat/current/multiline-examples.html">filebeat multiline</a></li>
<li>打标签：这个是最重要的，主要的目的是让logstash知道filebeat发送给它的消息是那个类型，然后logstash发送到es的时候，我们可以建立相关索引。这里的fields是内置的，doc_type是自定义的。</li>
</ol>
<blockquote>
<p>之前的document_type 在5.5.0中就已经废弃了。<a href="https://www.elastic.co/guide/en/beats/libbeat/6.1/release-notes-5.5.0.html#_deprecated_6">https://www.elastic.co/guide/en/beats/libbeat/6.1/release-notes-5.5.0.html#_deprecated_6</a></p>
</blockquote>
<p>了解这些之后，我们启动我们的logstash和filebeat。</p>
<p>启动docker版本的logstash：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name logstash --link elasticsearch -d -v ~/elk/yaml/logstash.conf:/usr/share/logstash/pipeline/logstash.conf logstash</span><br></pre></td></tr></table></figure>

<p>启动filebeat，将文件挂载到容器中，这里也可以有其它的处理方法，你可以根据自己的需求来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name filebeat -d --link logstash -v ~/elk/yaml/filebeat.yml:/usr/share/filebeat/filebeat.yml -v ~/elk/logs/:/home/logs/ filebeat</span><br></pre></td></tr></table></figure>

<p>最后记得在kibana里面建立索引(create index)的时候，默认使用的是logstash，而我们是自定义的doc_type,所以你需要输入order*,customer*这样就可以建立两个索引了。</p>
<p>之后就可以在kibana的Discovery里面看到你配置的了</p>
<blockquote>
<p>如果你直接用我的log，请将时间稍微改一下，2017-12-26改为当天实验年月。</p>
</blockquote>
<p>上面的命令我都自己实践过，是可以用的，注意下-v参数挂载的几个本地盘的地址。还有filebeat收集的地址。</p>
<p>配置文件地址仓库：<a href="https://github.com/chenzhijun/elk">使用Docker搭建ELK日志系统</a> ，仓库配有docker-compose.yml文件在根目录下直接运行<code>docker-compose up</code> 就可以看到实际效果了(记得改下日志时间)。</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-8-19</title>
    <url>/2017/08/19/essay-8-19/</url>
    <content><![CDATA[<h2 id="8月19日-阶段总结"><a href="#8月19日-阶段总结" class="headerlink" title="8月19日 阶段总结"></a>8月19日 阶段总结</h2><h3 id="日期格式"><a href="#日期格式" class="headerlink" title="日期格式?"></a>日期格式?</h3><p>SimpleDateFormat ===&gt; SimpleDateFormat</p>
<h3 id="Double-后面有个E"><a href="#Double-后面有个E" class="headerlink" title="Double 后面有个E?"></a>Double 后面有个E?</h3><p>A: double 为啥后面有个E ,E后面的数字代表后面乘以10的位数</p>
<h3 id="java-格式化金额显示"><a href="#java-格式化金额显示" class="headerlink" title="java 格式化金额显示"></a>java 格式化金额显示</h3><p>A: numberFormat,留4位小数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static final int DEFAULT_FORMAT &#x3D; 4;</span><br><span class="line"></span><br><span class="line">public static String formatCurrency(Double money)</span><br><span class="line">&#123;</span><br><span class="line">    NumberFormat numberFormat &#x3D; NumberFormat.getNumberInstance();</span><br><span class="line">    numberFormat.setMaximumFractionDigits(DEFAULT_FORMAT);</span><br><span class="line">    return numberFormat.format(money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看服务器上java命令位置"><a href="#查看服务器上java命令位置" class="headerlink" title="查看服务器上java命令位置:"></a>查看服务器上java命令位置:</h3><p>A: <code>whereis javac/java</code>    <code>ls -al</code> 一直找到没有软连接位置</p>
<h3 id="jenkins-构建的时候-nohup-failed-to-run-command-没有找到目录-没有权限"><a href="#jenkins-构建的时候-nohup-failed-to-run-command-没有找到目录-没有权限" class="headerlink" title="jenkins 构建的时候,nohup: failed to run command 没有找到目录,没有权限"></a>jenkins 构建的时候,nohup: failed to run command 没有找到目录,没有权限</h3><p>A: jenkins启动springboot脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">#pname&#x3D;$1</span><br><span class="line">pname&#x3D;com.apec.warehouse-server-1.0-RELEASE.jar</span><br><span class="line">puser&#x3D;root</span><br><span class="line">pid&#x3D;&#96;ps aux | grep $pname | grep $puser | grep -v grep | awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line"></span><br><span class="line">if [[ -z $pid ]]; then</span><br><span class="line">    echo &quot;I can NOT find $pname running by $puser&quot;</span><br><span class="line">fi</span><br><span class="line">#&#x2F;home&#x2F;cncsen&#x2F;warehouse&#x2F;com.</span><br><span class="line">chmod 777 &#x2F;home&#x2F;cncsen&#x2F;warehouse&#x2F;com.apec-warehouse-server-1.0-RELEASE.jar</span><br><span class="line">kill -9 $pid &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br><span class="line">cd &#x2F;home&#x2F;cncsen&#x2F;warehouse&#x2F;</span><br><span class="line">exec nohup java -Xmx128m -Xss256k -jar $pname --cacheType&#x3D;single  --spring.profiles.active&#x3D;test 5 &gt;&gt;server.log &amp;</span><br><span class="line">tail -f server.log</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>Question</tag>
      </tags>
  </entry>
  <entry>
    <title>Etcd 集群搭建</title>
    <url>/2019/05/23/etcd-cluster-install/</url>
    <content><![CDATA[<h1 id="Etcd-集群安装"><a href="#Etcd-集群安装" class="headerlink" title="Etcd 集群安装"></a>Etcd 集群安装</h1><p>本文参考：<a href="https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/clustering.md">https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/clustering.md</a></p>
<p>不得不说etcd的安装真的非常容易。在<a href="https://github.com/etcd-io/etcd%E7%9A%84release%E9%87%8C%E9%9D%A2%E6%89%BE%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82%E7%84%B6%E5%90%8E%E7%9B%B4%E6%8E%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%90%AF%E5%8A%A8%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%8D%95%E8%8A%82%E7%82%B9%E5%B0%B1%E5%A5%BD%E3%80%82%E7%9C%9F%E7%9A%84%E6%98%AF%E5%A4%AA%E7%AE%80%E5%8D%95%E5%95%8A%E3%80%82">https://github.com/etcd-io/etcd的release里面找到相应的版本。然后直接二进制启动，一个单节点就好。真的是太简单啊。</a> </p>
<p>不过搭建集群版本的话还是需要做一些配置，下面就是我用集群搭建的环境并且真实可用的过程。</p>
<p>下载好相应版本的etcd，然后做如下配置。我们采用的方式是使用Linux的systemd服务：</p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;etcd service</span><br><span class="line">Documentation&#x3D;https:&#x2F;&#x2F;github.com&#x2F;coreos&#x2F;etcd</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;notify</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;etcd --name infra0 --initial-advertise-peer-urls http:&#x2F;&#x2F;100.69.216.107:2380 \</span><br><span class="line">--listen-peer-urls http:&#x2F;&#x2F;100.69.216.107:2380 \</span><br><span class="line">--listen-client-urls http:&#x2F;&#x2F;100.69.216.107:2379,http:&#x2F;&#x2F;127.0.0.1:2379 \</span><br><span class="line">--advertise-client-urls http:&#x2F;&#x2F;100.69.216.107:2379 \</span><br><span class="line">--initial-cluster-token etcd-cluster-1 \</span><br><span class="line">--initial-cluster infra0&#x3D;http:&#x2F;&#x2F;100.69.216.107:2380,infra1&#x3D;http:&#x2F;&#x2F;100.69.216.108:2380,infra2&#x3D;http:&#x2F;&#x2F;100.69.216.109:2380 \</span><br><span class="line">--initial-cluster-state new \</span><br><span class="line">--data-dir &#x2F;data&#x2F;etcd \</span><br><span class="line">--heartbeat-interval 1000 \</span><br><span class="line">--election-timeout 5000</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line">RestartSec&#x3D;5</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>

<p>然后我们使用<code>systemctl start etcd.service</code>一个节点就起来了。另外的2个节点也是一样的操作方式，不过要注意：</p>
<ol>
<li>–name 这里要注意不一样，每个集群的名字都是独立的</li>
<li>–initial-cluster-token 这个是每个集群同一个名字</li>
<li>–initial-cluster-state 这个如果是新集群就是new</li>
<li>–data-dir /data/etcd 这个是一定要有，一定要先创建。不然etcd会在启动命令的目录自己建立一个name.etcd的数据目录，而且如果下次修改了目录，这个节点加入到集群还有坑</li>
</ol>
<p>ps: 遇到的一些问题：</p>
<p>一定要指定data-dir，防止手动测试的时候加入了集群，那么下次指定data-dir之后，该节点就无法加入集群：member 9b3523b532ddb797 has already been bootstrapped 这就是因为之前已经加入了集群，然后data目录下跟当前设置data-dir不一样。解决方式就是将之前的name.etcd目录下的member文件放到新的data-dir下面</p>
]]></content>
      <categories>
        <category>Etcd</category>
      </categories>
      <tags>
        <tag>Etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>ETCD 主机恢复</title>
    <url>/2022/12/19/etcd-recover/</url>
    <content><![CDATA[<h1 id="ETCD-主机恢复"><a href="#ETCD-主机恢复" class="headerlink" title="ETCD 主机恢复"></a>ETCD 主机恢复</h1><p>背景：在没有master 备份的情况下， 集群中有一个master 节点被直接重装系统；该节点非 ETCD master 节点。所以集群还是处于可用状态。但是 master 由之前的三节点变为 2 节点；</p>
<span id="more"></span> 
<p>openshift  版本：v170</p>
<ol>
<li>ETCD 备份 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#etcd master 节点上操作</span></span><br><span class="line">yum install -y etcd</span><br><span class="line">systemctl <span class="built_in">disable</span> etcd.service</span><br><span class="line">systemctl mask etcd.service</span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">mkdir -p /backup/etcd-config-$(date +%Y%m%d)/</span><br><span class="line">cp -R /etc/etcd/ /backup/etcd-config-$(date +%Y%m%d)/</span><br><span class="line"></span><br><span class="line">oc get nodes -o wide|grep master |awk <span class="string">&#x27;&#123;print $6&quot;:2379&quot;&#125;&#x27;</span>|xargs|tr <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">ETCD_ENDPOINTS=$(oc get nodes -o wide|grep master |awk <span class="string">&#x27;&#123;print $6&quot;:2379&quot;&#125;&#x27;</span>|xargs|tr <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">etcdctl --cert /etc/etcd/peer.crt --key /etc/etcd/peer.key --cacert /etc/etcd/ca.crt --endpoints=<span class="variable">$ETCD_ENDPOINTS</span> snapshot save /var/lib/etcd/snapshot.db</span><br><span class="line"></span><br><span class="line"><span class="comment">#要先删掉无效 node,不然redeploy 证书的时候，会卡在 remove console 的步骤</span></span><br><span class="line"><span class="comment">#oc delete nodes [UNKONWN_NODE]</span></span><br><span class="line">oc get nodes|grep master|grep NotReady|awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>|xargs -i oc delete nodes &#123;&#125;</span><br><span class="line"></span><br><span class="line">cnsz92vl12816.chenzhijun.cn</span><br></pre></td></tr></table></figure>
</li>
<li>重新部署 ETCD-CA</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> TOKEN=eyJhbGciOiJIUzUxMiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.5DWDErsUzcBYK-KD_j5tjemwPIrLMU3Xle5lDaoj-3HkYBeMQ2WTvF7wvkIj4Kint_XABxT7MgInCp9Z-gklyw</span><br><span class="line"></span><br><span class="line"><span class="comment">#0.恢复 ETCD 的 CA， 然后 certificate， 然后 master ca， master certificate；</span></span><br><span class="line"><span class="comment">#进入容器，增加 redeploy-etcd-ca.yml</span></span><br><span class="line"><span class="comment">#重新部署 ca</span></span><br><span class="line">cp add_new_nodes.yml redeploy-etcd-ca.yml</span><br><span class="line">---</span><br><span class="line">- import_playbook: openshift-etcd/redeploy-ca.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出容器，执行部署 ca，这里还没有增加主机</span></span><br><span class="line">curl -k -i -H <span class="string">&quot;Content-Type: application/json&quot;</span> -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> --data <span class="string">&#x27;&#123;&#125;&#x27;</span> https://localhost:5001/api/v1/playbooks/redeploy-etcd-ca.yml -X POST</span><br><span class="line"></span><br><span class="line">UUID=xxxx</span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/<span class="built_in">jobs</span>/<span class="variable">$UUID</span>/stdout -X GET</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重新部署 ETCD 证书</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#复制 etcd 证书更新 playbook</span></span><br><span class="line">cp add_new_nodes.yml redeploy-etcd-certificates.yml</span><br><span class="line">---</span><br><span class="line">- import_playbook: openshift-etcd/redeploy-certificates.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新部署 etcd 证书</span></span><br><span class="line">curl -k -i -H <span class="string">&quot;Content-Type: application/json&quot;</span> -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> --data <span class="string">&#x27;&#123;&#125;&#x27;</span> https://localhost:5001/api/v1/playbooks/redeploy-etcd-certificates.yml -X POST</span><br><span class="line"></span><br><span class="line">cp add_new_nodes.yml redeploy-master-ca.yml</span><br><span class="line">---</span><br><span class="line">- import_playbook: openshift-master/redeploy-openshift-ca.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新部署 master 证书, 不执行，master 有</span></span><br><span class="line"><span class="comment">#curl -k -i -H &quot;Content-Type: application/json&quot; -H &quot;Authorization: $TOKEN&quot; --data &#x27;&#123;&#125;&#x27; https://localhost:5001/api/v1/playbooks/redeploy-master-ca.yml -X POST</span></span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line">curl -k -i -H <span class="string">&quot;Content-Type: application/json&quot;</span> -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> --data <span class="string">&#x27;&#123;&#125;&#x27;</span> https://localhost:5001/api/v1/playbooks/redeploy-certificates.yml -X POST</span><br><span class="line"></span><br><span class="line">UUID=xxxx</span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/<span class="built_in">jobs</span>/<span class="variable">$UUID</span>/stdout -X GET</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>增加 master 主机</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#重新部署一遍 master 证书，不然后面的Wait for /apis/metrics.k8s.io/v1beta1 when registered 会出现异常,最好重新部署一遍证书</span></span><br><span class="line">ansible-playbook -i ./inventory project/openshift-master/redeploy-openshift-ca.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">##增加主机</span></span><br><span class="line"><span class="built_in">export</span> ETCD_NODES=cnsz92vl12816.chenzhijun.cn</span><br><span class="line"></span><br><span class="line"><span class="comment">###1. 增加 hosts 配置</span></span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/groups/new_nodes -X POST</span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/groups/new_masters -X POST</span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/hosts/<span class="variable">$ETCD_NODES</span>/groups/new_nodes -X POST </span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/hosts/<span class="variable">$ETCD_NODES</span>/groups/new_masters -X POST </span><br><span class="line">curl -k -i -H <span class="string">&quot;Content-Type: application/json&quot;</span> -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> --data <span class="string">&#x27;&#123;&quot;openshift_node_group_name&quot;: &quot;node-config-master&quot;&#125;&#x27;</span> https://localhost:5001/api/v1/hostvars/<span class="variable">$ETCD_NODES</span>/groups/new_nodes?<span class="built_in">type</span>=inventory -X POST</span><br><span class="line">curl -k -i -H <span class="string">&quot;Content-Type: application/json&quot;</span> -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> --data <span class="string">&#x27;&#123;&quot;openshift_node_group_name&quot;: &quot;node-config-master&quot;&#125;&#x27;</span> https://localhost:5001/api/v1/hostvars/<span class="variable">$ETCD_NODES</span>/groups/new_masters?<span class="built_in">type</span>=inventory -X POST</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>恢复 master pod 组件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">###恢复 master</span></span><br><span class="line">进入到 ansible-runner-service 容器中，</span><br><span class="line"><span class="built_in">cd</span> /root/ansible-runner-service/cmg-ocp/project</span><br><span class="line">cp add_new_nodes.yml add_new_masters.yml</span><br><span class="line"><span class="comment">#修改里面的内容为 openshfit-master</span></span><br><span class="line">---</span><br><span class="line">- import_playbook: openshift-master/scaleup.yml</span><br><span class="line"></span><br><span class="line">curl -k -i -H <span class="string">&quot;Content-Type: application/json&quot;</span> -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> --data <span class="string">&#x27;&#123;&#125;&#x27;</span> https://localhost:5001/api/v1/playbooks/add_new_masters.yml -X POST</span><br><span class="line"></span><br><span class="line">UUID=xxxx</span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/<span class="built_in">jobs</span>/<span class="variable">$UUID</span>/stdout -X GET</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">export</span> ETCD_NODES=cnsz92vl12816.chenzhijun.cn</span><br><span class="line"></span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/groups/new_etcd -X POST</span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/hosts/<span class="variable">$ETCD_NODES</span>/groups/new_etcd -X POST</span><br><span class="line"></span><br><span class="line">curl -k -i -H <span class="string">&quot;Content-Type: application/json&quot;</span> -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> --data <span class="string">&#x27;&#123;&quot;openshift_node_group_name&quot;: &quot;node-config-master&quot;&#125;&#x27;</span> https://localhost:5001/api/v1/hostvars/<span class="variable">$ETCD_NODES</span>/groups/new_etcd?<span class="built_in">type</span>=inventory -X POST</span><br><span class="line"></span><br><span class="line"><span class="comment">#恢复 etcd</span></span><br><span class="line"><span class="comment">#需要将 hosts 文件里面的 new_master,new_nodes 改到正确的位置</span></span><br><span class="line">vi /etc/ansible-runner/inventory/hosts</span><br><span class="line"></span><br><span class="line">OSEv3:</span><br><span class="line">  children:</span><br><span class="line">    etcd:</span><br><span class="line">      hosts:</span><br><span class="line">        cnsz92vl10440.chenzhijun.cn: null</span><br><span class="line">        cnsz92vl10441.chenzhijun.cn: null</span><br><span class="line">    masters:</span><br><span class="line">      hosts:</span><br><span class="line">        cnsz92vl10442.chenzhijun.cn: null</span><br><span class="line">        cnsz92vl10440.chenzhijun.cn: null</span><br><span class="line">        cnsz92vl10441.chenzhijun.cn: null</span><br><span class="line">    new_etcd:</span><br><span class="line">      hosts:</span><br><span class="line">        cnsz92vl10442.chenzhijun.cn: null</span><br><span class="line">    nodes:</span><br><span class="line">      hosts:</span><br><span class="line">        cnsz92vl10442.chenzhijun.cn:</span><br><span class="line">          openshift_node_group_name: node-config-master</span><br><span class="line">        cnsz92vl10440.chenzhijun.cn:</span><br><span class="line">          openshift_node_group_name: node-config-master</span><br><span class="line">        cnsz92vl10441.chenzhijun.cn:</span><br><span class="line">          openshift_node_group_name: node-config-master</span><br><span class="line">        cnsz92vl10443.chenzhijun.cn:</span><br><span class="line">          openshift_node_group_name: node-config-infra</span><br><span class="line">        cnsz92vl10445.chenzhijun.cn:</span><br><span class="line">          openshift_node_group_name: node-config-infra</span><br><span class="line">        cnsz92vl10448.chenzhijun.cn:</span><br><span class="line">          openshift_node_group_name: node-config-compute</span><br><span class="line">        cnsz92vl11127.chenzhijun.cn:</span><br><span class="line">          openshift_node_group_name: node-config-infra</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>检查 hosts 文件，确保之前的 new_masters 配置已删除</p>
</li>
<li><p>确认 ETCD 中失败节点删除</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">100.69.137.3:2379,100.69.137.4:2379,100.69.137.5:2379</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除集群中原来的老 etcd 节点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line"><span class="comment">#查询etcd member list</span></span><br><span class="line">etcdctl --cert /etc/etcd/peer.crt --key /etc/etcd/peer.key --cacert /etc/etcd/ca.crt --endpoints=<span class="string">&quot;100.69.137.3:2379,100.69.137.4:2379,100.69.137.5:2379&quot;</span> member list</span><br><span class="line"><span class="comment">#查询集群状态详情</span></span><br><span class="line">etcdctl --cert /etc/etcd/peer.crt --key /etc/etcd/peer.key --cacert /etc/etcd/ca.crt --endpoints=<span class="string">&quot;100.69.137.3:2379, has been 100.69.137.4:2379,100.69.137.5:2379&quot;</span> --write-out=table endpoint status</span><br><span class="line"><span class="comment">#删除失败节点</span></span><br><span class="line">etcdctl --cert /etc/etcd/peer.crt --key /etc/etcd/peer.key --cacert /etc/etcd/ca.crt --endpoints=<span class="string">&quot;100.69.137.3:2379,100.69.137.4:2379,100.69.137.5:2379&quot;</span> member remove ID</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令执行 example</span></span><br><span class="line">etcdctl --cert /etc/etcd/peer.crt --key /etc/etcd/peer.key --cacert /etc/etcd/ca.crt --endpoints=<span class="string">&quot;100.69.137.3:2379,100.69.137.4:2379,100.69.137.5:2379&quot;</span> --write-out=table endpoint status</span><br><span class="line">Failed to get the status of endpoint 100.75.46.77:2379 (context deadline exceeded)</span><br><span class="line">+-------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">|     ENDPOINT      |        ID        | VERSION | DB SIZE | IS LEADER | RAFT TERM | RAFT INDEX |</span><br><span class="line">+-------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">| 100.75.46.76:2379 | 29ace8a008187a61 |  3.2.22 |   26 MB |     <span class="literal">false</span> |        15 |      74501 |</span><br><span class="line">| 100.75.46.78:2379 | 189fb2b310767596 |  3.2.22 |   26 MB |      <span class="literal">true</span> |        15 |      74516 |</span><br><span class="line">+-------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">[root@cnsz92vl10441 ~]<span class="comment"># etcdctl --cert /etc/etcd/peer.crt --key /etc/etcd/peer.key --cacert /etc/etcd/ca.crt --endpoints=&quot;100.75.46.76:2379,100.75.46.77:2379,100.75.46.78:2379&quot; member list</span></span><br><span class="line">189fb2b310767596, started, cnsz92vl10441, https://100.75.46.78:2380, https://100.75.46.78:2379</span><br><span class="line">29ace8a008187a61, started, cnsz92vl10440, https://100.75.46.76:2380, https://100.75.46.76:2379</span><br><span class="line">b25d6fd89ab25bb3, started, cnsz92vl10442, https://100.75.46.77:2380, https://100.75.46.77:2379</span><br><span class="line">[root@cnsz92vl10441 ~]<span class="comment"># etcdctl --cert /etc/etcd/peer.crt --key /etc/etcd/peer.key --cacert /etc/etcd/ca.crt --endpoints=&quot;100.75.46.76:2379,100.75.46.77:2379,100.75.46.78:2379&quot; member remove b25d6fd89ab25bb3</span></span><br><span class="line">Member b25d6fd89ab25bb3 removed from cluster 4547a2deaf4fef8e</span><br></pre></td></tr></table></figure>

<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b67bcee1-ec5d-4ed1-bd39-181a74cde946/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b67bcee1-ec5d-4ed1-bd39-181a74cde946/Untitled.png"></p>
<ol start="8">
<li>恢复 ETCD</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#增加 new_etcd 分组 . 只要有 new_etcd 这个组，不要 new_masters, new_nodes</span></span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/groups/new_etcd -X POST</span><br><span class="line"></span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/hosts/<span class="variable">$ETCD_NODES</span>/groups/new_etcd -X POST </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /root/ansible-runner-service/cmg-ocp/project</span><br><span class="line">cp add_new_nodes.yml add_new_etcd.yml</span><br><span class="line"><span class="comment">#修改里面的内容为 openshfit-master</span></span><br><span class="line">---</span><br><span class="line">- import_playbook: openshift-etcd/scaleup.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除原来集群中失败的 etcd 节点;会拉取新的 etcd 镜像，保持镜像仓库镜像只有一个版本；</span></span><br><span class="line">curl -k -i -H <span class="string">&quot;Content-Type: application/json&quot;</span> -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> --data <span class="string">&#x27;&#123;&#125;&#x27;</span> https://localhost:5001/api/v1/playbooks/add_new_etcd.yml -X POST</span><br><span class="line">UUID=xxxx</span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/<span class="built_in">jobs</span>/<span class="variable">$UUID</span>/stdout -X GET</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>验证</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl --cert /etc/etcd/peer.crt --key /etc/etcd/peer.key --cacert /etc/etcd/ca.crt --endpoints=<span class="string">&quot;100.75.46.76:2379,100.75.46.77:2379,100.75.46.78:2379&quot;</span> --write-out=table endpoint status</span><br><span class="line"></span><br><span class="line">oc get pods -n kube-system</span><br></pre></td></tr></table></figure>

<p>附录：</p>
<ol>
<li>bootstrap 常用参数命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#TOKEN 导入</span></span><br><span class="line"><span class="built_in">export</span> TOKEN=eyJhbGciOiJIUzUxMiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.5DWDErsUzcBYK-KD_j5tjemwPIrLMU3Xle5lDaoj-3HkYBeMQ2WTvF7wvkIj4Kint_XABxT7MgInCp9Z-gklyw</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署集群</span></span><br><span class="line">curl -k -i -H <span class="string">&quot;Content-Type: application/json&quot;</span> -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> --data <span class="string">&#x27;&#123;&#125;&#x27;</span> https://localhost:5001/api/v1/playbooks/deploy_cluster.yml -X POST</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载集群</span></span><br><span class="line">curl -k -i -H <span class="string">&quot;Content-Type: application/json&quot;</span> -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> --data <span class="string">&#x27;&#123;&#125;&#x27;</span> https://localhost:5001/api/v1/playbooks/uninstall.yml -X POST</span><br><span class="line"></span><br><span class="line"><span class="comment">##删除命令</span></span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/groups/new_etcd -X DELETE</span><br><span class="line"></span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/groups/new_masters -X DELETE</span><br><span class="line"></span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/groups/new_nodes -X DELETE</span><br><span class="line"></span><br><span class="line"><span class="comment">#实时日志</span></span><br><span class="line">curl -k -i -H <span class="string">&quot;Authorization: <span class="variable">$TOKEN</span>&quot;</span> https://localhost:5001/api/v1/<span class="built_in">jobs</span>/<span class="variable">$UUID</span>/stdout -X GET</span><br></pre></td></tr></table></figure>
</li>
<li>卡在某个 ansible 脚本 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: [cnsz92vl10442.chenzhijun.cn -&gt; cnsz92vl10441.chenzhijun.cn]: FAILED! =&gt; &#123;<span class="string">&quot;changed&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;cmd&quot;</span>: [<span class="string">&quot;oc&quot;</span>, <span class="string">&quot;adm&quot;</span>, <span class="string">&quot;create-api-client-config&quot;</span>, <span class="string">&quot;--certificate-authority=/etc/origin/master/ca.crt&quot;</span>, <span class="string">&quot;--client-dir=/tmp/openshift-ansible-O3mFaX&quot;</span>, <span class="string">&quot;--groups=system:masters,system:openshift-master&quot;</span>, <span class="string">&quot;--master=https://cnsz92vl10441:8443&quot;</span>, <span class="string">&quot;--public-master=https://cnsz92vl10441:8443&quot;</span>, <span class="string">&quot;--signer-cert=/etc/origin/master/ca.crt&quot;</span>, <span class="string">&quot;--signer-key=/etc/origin/master/ca.key&quot;</span>, <span class="string">&quot;--signer-serial=/etc/origin/master/ca.serial.txt&quot;</span>, <span class="string">&quot;--user=system:openshift-master&quot;</span>, <span class="string">&quot;--basename=openshift-master&quot;</span>, <span class="string">&quot;--expire-days=730&quot;</span>], <span class="string">&quot;delta&quot;</span>: <span class="string">&quot;0:00:00.193549&quot;</span>, <span class="string">&quot;end&quot;</span>: <span class="string">&quot;2021-01-11 15:59:54.383491&quot;</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;non-zero return code&quot;</span>, <span class="string">&quot;rc&quot;</span>: 1, <span class="string">&quot;start&quot;</span>: <span class="string">&quot;2021-01-11 15:59:54.189942&quot;</span>, <span class="string">&quot;stderr&quot;</span>: <span class="string">&quot;error: --signer-serial, \&quot;/etc/origin/master/ca.serial.txt\&quot; must be a valid file&quot;</span>, <span class="string">&quot;stderr_lines&quot;</span>: [<span class="string">&quot;error: --signer-serial, \&quot;/etc/origin/master/ca.serial.txt\&quot; must be a valid file&quot;</span>], <span class="string">&quot;stdout&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;stdout_lines&quot;</span>: []&#125;</span><br><span class="line"></span><br><span class="line">看下是否 node 没有从集群中删除</span><br></pre></td></tr></table></figure>
</li>
<li>错误 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TASK [openshift_ca : Install the base package <span class="keyword">for</span> admin tooling] ***************</span><br><span class="line">FAILED - RETRYING: Install the base package <span class="keyword">for</span> admin tooling (3 retries left).</span><br><span class="line">FAILED - RETRYING: Install the base package <span class="keyword">for</span> admin tooling (2 retries left).</span><br><span class="line">FAILED - RETRYING: Install the base package <span class="keyword">for</span> admin tooling (1 retries left).</span><br><span class="line">fatal: [cnsz92vl10442.chenzhijun.cn -&gt; cnsz92vl10441.chenzhijun.cn]: FAILED! =&gt; &#123;<span class="string">&quot;attempts&quot;</span>: 3, <span class="string">&quot;changed&quot;</span>: <span class="literal">false</span>, <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;No package matching &#x27;atomic-openshift-3.11.170&#x27; found available, installed or updated&quot;</span>, <span class="string">&quot;rc&quot;</span>: 126, <span class="string">&quot;results&quot;</span>: [<span class="string">&quot;No package matching &#x27;atomic-openshift-3.11.170&#x27; found available, installed or updated&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">ansible masters -i hosts -m shell -a <span class="string">&quot;yum clean all&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有可能少包，那就需要手动装</span></span><br><span class="line">scp atomic-openshift-3.11.170-1.git.0.00cac56.el7.x86_64.rpm cnsz92vl10441:/tmp/</span><br><span class="line"></span><br><span class="line">rpm -Uvh atomic-openshift-3.11.170-1.git.0.00cac56.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i ./inventory ./project/openshift-master/redeploy-openshift-ca.yml</span><br><span class="line"></span><br><span class="line">ansible-playbook -i ./inventory ./project/redeploy-certificates.yml</span><br><span class="line"></span><br><span class="line">ansible-playbook -i ./inventory ./project/openshift-master/redeploy-certificates.yml</span><br><span class="line"></span><br><span class="line">osm_etcd_image=harbor.uat.chenzhijun.top/rhel7/etcd:3.2.22</span><br><span class="line">openshift_pkg_version=-3.11.170</span><br><span class="line"></span><br><span class="line">openshift_is_atomic=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2017/03/15/first-blog/</url>
    <content><![CDATA[<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>最近几天将博客由jeklly换成了hexo，之前的博客确实很丑，并且东西很杂乱，什么都有，而且也没有什么分类的，让人感觉很乱。偶然的机会看到hexo的next主题，心里一种欢呼，这不就是我想要的样子吗？当夜折腾到凌晨1点，总算把博客搭好，顺便了解下一些配置用用法。可是当一切具备的时候，我却有几天都没有写博客，为什么？我也不知道，我想着重新搭建了一个博客，总不能还像以前那样吧？这个博客应该写技术,<span id="more"></span>而且应该全是技术，而且我觉得如果只能写一些比较浅显的技术，那不是有点丢人？所以就这样拖拉几天。我却始终没有动手。今天突然觉悟，其实为啥我要去纠结写什么？写的人是我，博客的目的是记录，是总结。不该给它太多其他的定义，技术浅显有怎样？那是你的感悟。写了技术之外的博客又怎样？那是你的感悟，你人生经历的一种，难道不重要吗？就算程序员，他的世界不应该只有代码，代码是一种艺术，艺术是一种美，而这种美来自于生活。不管怎样，只要你去做了，只要你能坚持到了，那有何尝不是一种成长。顺便献上一句鸡汤：</p>
<blockquote>
<p>你只负责努力，余下交给命运</p>
</blockquote>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基础</title>
    <url>/2017/04/22/git/</url>
    <content><![CDATA[<h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><h3 id="常用-git-基础命令"><a href="#常用-git-基础命令" class="headerlink" title="常用 git 基础命令"></a>常用 git 基础命令</h3><p>克隆项目地址:<code>git clone [http://project/address]</code></p>
<p>查看本地分支/详情:<code>git branch / git branch -v</code></p>
<p>创建分支:<code>git branch branchName</code></p>
<p>分支重命名:<code>git branch -m branchNameOld branchNameNew</code></p>
<p>切换分支:<code>git checkout branchName</code></p>
<p>创建并切换到分支:<code>git checkout -b branchName</code></p>
<p>如果需要操作远程仓库的某个分支，可以用<code>git checkout -b branchName origin/branchName </code> ，意思是基于远程仓库的 origin/branchName 分支的基础上创建本地的branchName分支，分支名最好一样，当然也可以不一样。在push的时候使用<code>git push origin HEAD:branchName</code>就可以了。</p>
<p>查看本地repo文件状态:<code>git status</code></p>
<p>查看文件详细不同:<code>git diff</code></p>
<span id="more"></span>
<p>查看历史:<code>git log</code></p>
<p>添加文件:<code>git add fileName  /  git add . </code></p>
<p>commit文件:<code>git commit -m &quot;注释信息&quot;</code></p>
<p>查看远程主机名:<code>git remote -v</code></p>
<p>更新文件: <code>git pull origin master / git pull</code>,origin为远程名，master为分支名</p>
<p>提交文件: <code>git push orgin master / git push </code> 格式:<code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></p>
<p>查看远程分支:<code>git branch -r</code></p>
<p>查看所有分支:<code>git branch -a</code></p>
<p>常用的貌似就这些，但是远远不止这些，还有<code>git init</code>,<code>git rebase</code> 很大一部分命令，这么多我怎么记得住了？可以用给命令设置别名的方法:</p>
<ol>
<li>使用<code>alias</code>设置系统别名,每次会话结束后会失效. <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		如果要设置&#96;gst&#96;为&#96;git status&#96; 可以这样:</span><br><span class="line">	</span><br><span class="line">		设置别名:&#96;alias gst&#x3D;&#39;git status&#39;&#96;</span><br><span class="line">		</span><br><span class="line">		查看别名:&#96;alias gst&#96;</span><br><span class="line">		</span><br><span class="line">		覆盖别名:&#96;alias  gst&#x3D;&#39;覆盖后的命令&#39;&#96;</span><br><span class="line">		</span><br><span class="line">		删除别名:&#96;unalias gst&#96;</span><br><span class="line">		</span><br><span class="line">		如果需要每次都生效：mac写入到.bash_profile中就可以了&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. git本身设置</span><br></pre></td></tr></table></figure>
  git config –global alias.st status  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	下次使用 &#96;git st&#96; 就可以</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">### github 远程仓库同步</span><br><span class="line">有一种情况，如果你fork了别人的仓库到自己的github仓库，然后本地clone了自己github仓库里面的项目，这时候别人的仓库有了更新，而我们肯定也是要同步更新的，这个时候该怎么办？</span><br><span class="line"></span><br><span class="line">解决方法:</span><br><span class="line"></span><br><span class="line">1:增加fork的源仓库地址到本地:&#96;git remote add remoteName https:&#x2F;&#x2F;github.com&#x2F;remote&#x2F;address&#96;</span><br><span class="line"></span><br><span class="line">2:查看分支信息:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
git remote -v<br>origin    <a href="https://github.com/chenzhijun/java-core-learning-example.git">https://github.com/chenzhijun/java-core-learning-example.git</a> (fetch)<br>origin    <a href="https://github.com/chenzhijun/java-core-learning-example.git">https://github.com/chenzhijun/java-core-learning-example.git</a> (push)<br>upstream    <a href="https://github.com/ORIGINAL_OWNER/java-core-learning-example.git">https://github.com/ORIGINAL_OWNER/java-core-learning-example.git</a> (fetch)<br>upstream    <a href="https://github.com/ORIGINAL_OWNER/java-core-learning-example.git">https://github.com/ORIGINAL_OWNER/java-core-learning-example.git</a> (push)<br>```<br>这里的upstream就是原来的库，orgin指代的就是自己的github仓库了。 </li>
</ol>
<p>3:同步远程库到本地:<code>git fetch upstream</code></p>
<p>4:保证切换到master分支:<code>git checkout master</code></p>
<p>5:合并更新到本地:<code>git merge upstream/master</code></p>
<p>6:推送到自己的github仓库:<code>git push origin master</code></p>
<p>这样github仓库和远程库是同步更新的了。</p>
<p>–</p>
<blockquote>
<p>参考链接</p>
</blockquote>
<ol>
<li><p><a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/">设置远程源</a></p>
</li>
<li><p><a href="https://help.github.com/articles/syncing-a-fork/">同步fork</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab 自定义配置 （三）</title>
    <url>/2018/04/02/gitlab-customer-settings/</url>
    <content><![CDATA[<h2 id="登陆页面与LOGO自定义"><a href="#登陆页面与LOGO自定义" class="headerlink" title="登陆页面与LOGO自定义"></a>登陆页面与LOGO自定义</h2><p><img src="/images/qiniu/2018-04-02-13-53-17.png" alt="2018-04-02-13-53-17"></p>
<p>在这里替换之后返回登陆也可以看到：</p>
<p><img src="/images/qiniu/2018-04-02-13-54-07.png" alt="2018-04-02-13-54-07"></p>
<span id="more"></span>

<h2 id="注册邮箱后缀限制"><a href="#注册邮箱后缀限制" class="headerlink" title="注册邮箱后缀限制"></a>注册邮箱后缀限制</h2><p>在<code>admin area</code>中<code>settings</code>下限制邮箱后缀，将公司邮箱设为白名单，其它邮箱设为黑名单。</p>
<p><img src="/images/qiniu/2018-04-02-13-54-46.png" alt="2018-04-02-13-54-46"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言简单基础介绍</title>
    <url>/2017/04/12/go-language-start/</url>
    <content><![CDATA[<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><h3 id="简单介绍Go"><a href="#简单介绍Go" class="headerlink" title="简单介绍Go"></a>简单介绍Go</h3><p>Go的出名，估计真的是靠“爹”。反正人家有个好爹，这是毋庸置疑的。有时候我会想，为啥要用GO，其实Go能做的事情，Java也能做，到现在我也没有想明白。可能Go的存在就是为了那些C/C++想快速转到互联网行业的一个中转语言吧。说实话，对于指导Go里面有指针的第一时间。心中就是千万匹草泥马。但是草归草，生活的继续，还是得硬着头皮学。我有一个心理目标，既然学，就要分清楚学习到什么程度，以致于来花费多少时间。没错，对于Go，我的想法是能用，并且能稍微的用好一点。</p>
<span id="more"></span>

<h3 id="Hello-Go"><a href="#Hello-Go" class="headerlink" title="Hello Go"></a>Hello Go</h3><p>一切语言的开始都是 <strong>Hello，World</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	fmt.Println(&quot;Hello,World&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是 main.go 文件。go 语言的文件后缀都为 .go。这个基本上每个语言都有这个特性啊。哈哈。</p>
<p>第一行：go 语言包管理机制，所有开始必须有个包名“自报身份”。<br>第二行：import 导入需要用到包<br>第三行：func main(){} 定义一个 main 函数。func 定义一个函数，main函数是可以运行的入口</p>
<h4 id="Go-语法"><a href="#Go-语法" class="headerlink" title="Go 语法"></a>Go 语法</h4><ul>
<li><p>定义一个 variable 的string变量</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var variable string</span><br><span class="line">var variable &#x3D; &quot;string&quot;</span><br><span class="line">variable :&#x3D; &quot;string&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>大小写，变量可见性</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Variable  string    &#x2F;&#x2F;外部可见</span><br><span class="line">var variable  string    &#x2F;&#x2F;外部不可见</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数定义</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Amethod(a int, b string)(int,error)&#123;&#x2F;&#x2F;外部可见，传入a，b两个参数，返回int，error两个类型的参数</span><br><span class="line">   &#x2F;&#x2F;do something</span><br><span class="line">  	return v1,err1</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">func amethod(a int, b string)(int,error)&#123;&#x2F;&#x2F;外部不可见，传入a，b两个参数，返回int，error两个类型的参数</span><br><span class="line">	&#x2F;&#x2F;do something</span><br><span class="line">	return v1,err1</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">intResult,err :&#x3D; Amethod(1,&quot;str&quot;) &#x2F;&#x2F; 调用Amethod方法，并且定义intResult，err来作为接受返回值的两个变量</span><br><span class="line"></span><br><span class="line">		</span><br></pre></td></tr></table></figure></li>
<li><p>流程控制</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if a&gt;0&#123; </span><br><span class="line">	&#x2F;&#x2F;do thing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0;i &lt; 10; i++ &#123; &#x2F;&#x2F; 常见for循环</span><br><span class="line">	&#x2F;&#x2F;do thing</span><br><span class="line">&#125;	</span><br><span class="line">for 1&#x3D;&#x3D;1&#123;  &#x2F;&#x2F; 无限死循环</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var aSlice :&#x3D; []int&#123;1,2,3,4&#125;</span><br><span class="line">for idx,val :&#x3D; range aSlice&#123;&#x2F;&#x2F; 循环slice数组，range关键字</span><br><span class="line">	fmt.Print(idx,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch</span><br><span class="line">continue</span><br><span class="line">break</span><br><span class="line">go 开启协程</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>其实一开始写Go我是拒绝的，有几次都感觉，Java用起来多爽啊，Go这东西简直反人类。最近用着基本上也就没有抱怨了，很多时候都是怕自己做不好，还有自己的舒适区。其实刚毕业的一两年都是一个软件开发者最重要的时间吧。我16年毕业，半年Java开发后跳槽，说实话，如果不是女朋友来深圳的话，我可能真的会在易宝支付做下去吧。来深圳找工作并不是很顺利，很多时候自己心理压力大，也有一点事自己学的<br>不足。一方面还没有做满一年就跳槽，怕留给公司不好的影响，另一方面，半年的时间也就了解了一些基本的支付业务，并没有实际的开发到少东西。而来到新公司，第一件事情就是做一个自己不熟悉的东西。那个时候真的是一边做，也有一遍流泪的。越想越心酸，能力不足，眼前又痛苦。想想别人可以挑公司，而我还被公司挑来挑去。而现在的公司又每天都是做着我不熟悉的Go开发。那个时候心里憋屈啊。 在同事们看来，我从进公司第一天到完成Go开发组长的任务总共用了三天的时间，并且组长也是相当满意任务的完成度。只是他们不知道，我心里是多苦。从熟悉的Java转到Go，我真的是心里一万遍打死了自己，责怪自己。我的同事对我很好，给了我很大的帮助。我真的非常谢谢他们。完成任务后的第一天，我就开始做实际的生产上的项目了。那段时间什么都不知道，什么都不懂。我有时候真的都会默默流泪。但是不管怎样，如果你没能力，那么你只能好好的做好你手中的事情，硬着头皮，最终也是做完了。我很讨厌这种不能自己决定选择的生活，而我不管怎样，也不能放弃。chenzhijun，加油，每天努力一点点。</p>
</blockquote>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 并发基础（一）</title>
    <url>/2019/08/25/golang-goroutine1/</url>
    <content><![CDATA[<h1 id="golang-并发基础（一）"><a href="#golang-并发基础（一）" class="headerlink" title="golang 并发基础（一）"></a>golang 并发基础（一）</h1><p>golang 在语言的语法和运行时方面内置了对并发的支持。在了解golang的并发之前，我们先看一下操作系统的两个概念：线程和进程。你应该知道，在系统中运行一个程序，其实就是启动了一个进程，而要运行起来，对外来说肯定是需要资源的，比如cpu，内存空间，文件句柄，线程等等..每个进程至少有一个线程，每个进程的初始线程被称为主线程。了解到这些，你大概可以类比一下，比如你创建一个项目，肯定要有main方法（主线程），你的项目中可能还有不同的业务逻辑，这个时候就可以让主进程创建多个线程去运行求结果。线程可以共享进程的空间。另外我们要知道，cpu的执行方式是轮询时间分片的，也就是可能这个线程有10ms的cpu执行时间，所以如果是单核cpu，就是每个线程执行一会，抢占式执行。并发(concurrency)不是并行(parallelism)。并行是在相同的时候让不同的代码都能在不同的处理器上执行，也就是同时做很多事情。并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。</p>
<span id="more"></span>
<h2 id="并发通信模型"><a href="#并发通信模型" class="headerlink" title="并发通信模型"></a>并发通信模型</h2><p>golang 采用的并发同步模型为通信顺序进程（Communicating Sequential Process,CSP)的模型，通过在goroutine之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。并发通信模型还有一种是Actor，比较著名的例子就是akka.io。</p>
<h2 id="golang-并发工作模式"><a href="#golang-并发工作模式" class="headerlink" title="golang 并发工作模式"></a>golang 并发工作模式</h2><p>操作系统会在物理处理器上调度线程来运行，而Go语言的运行时会在逻辑处理器上调度goroutine来执行，每个逻辑处理器又分别绑定到单个的操作系统线程。像下图，如果一个Goroutine可以运行的时候，就会被放入到逻辑处理器的执行队列中，逻辑处理器有绑定到一个唯一的操作系统线程中。</p>
<p><img src="/images/qiniu/2019-08-25-20-03-52.png" alt="2019-08-25-20-03-52"></p>
<p>如果一个goroutine执行的是一个阻塞的系统调用，比如打开文件，那岂不是队列中的就绪态goroutine都的阻塞了？当出现这类调用时候，当前线程和当前的goroutine就会从逻辑处理器上分离，当前线程继续阻塞，等待刚刚的系统调用的放回。同时，逻辑处理器失去用来运行的线程。所以调度器就会创建一个新线程，并将其绑定到逻辑处理器上。当阻塞的系统完成调用并且返回，对应的goroutine会放回到本地运行队列，而之前的线程会保存好，一遍之后可以继续使用。如下图，线程A本来是绑定在P0的，后来有阻塞调用，就脱离出去了，然后线程B又绑定了P0。</p>
<p><img src="/images/qiniu/2019-08-25-20-21-14.png" alt="2019-08-25-20-21-14"></p>
<p>golang默认可以创建的线程数量为10000个线程，可以通过runtime/debug包的SetMaxThreads方法来更改。</p>
<!-- golang由于天生的支持高并发的应用，得到了很多大的基础项目的青睐。在golang的并发中最小的单元即为goroutine。今天来聊一下goroutine是怎么和chan配合的。

## channel的分类

channel分为非缓存chan和有缓存chan，  -->

<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>The C10K problem</p>
<p><a href="https://cloud.tencent.com/developer/article/1346210">https://cloud.tencent.com/developer/article/1346210</a></p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 并发基础（二）</title>
    <url>/2019/08/25/golang-goroutine2/</url>
    <content><![CDATA[<h1 id="golang-并发基础（二）"><a href="#golang-并发基础（二）" class="headerlink" title="golang 并发基础（二）"></a>golang 并发基础（二）</h1><p>上一篇简单介绍了并发与并行，goroutine实际工作的原理示意图，现在我们来看下golang是怎么处理并发中竞争状态的。</p>
<p>竞争状态：如果两个或多个goroutine在没有同步的情况下对同一个资源进行读写操作，就处于相互竞争的状态，称为竞争状态。对一个共享资源的操作必须是<strong>原子化</strong>的，即同一时刻只能由一个goroutine对共享资源进行读和写操作。</p>
<span id="more"></span>
<h2 id="同步操作方式–锁住共享资源"><a href="#同步操作方式–锁住共享资源" class="headerlink" title="同步操作方式–锁住共享资源"></a>同步操作方式–锁住共享资源</h2><p>golang提供atomic和sync包，两个包里的函数提供了很好的解决方案。</p>
<h3 id="原子函数-atomic-包"><a href="#原子函数-atomic-包" class="headerlink" title="原子函数 atomic 包"></a>原子函数 atomic 包</h3><p>我们可以看一下atomic提供的原子函数，它提供底层加锁的方式来同步访问整形变量和指针，示例代码:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	counter <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Final Counter:&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">		atomic.AddInt64(&amp;counter, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		runtime.Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁-mutex"><a href="#互斥锁-mutex" class="headerlink" title="互斥锁 mutex"></a>互斥锁 mutex</h3><p>使用互斥锁也是一种同步访问共享资源的方式，互斥的概念就是AB只有一个可以访问，要不就是A，要不就是B。相当于一张门，只能一个人进入，第一个进入的人就把门锁了，其它人都不可以进来，只有等这个人把锁打开了，其它人才能重新竞争锁。</p>
<p>看一下代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Final Counter: %d\n&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">		mutex.Lock() <span class="comment">//锁住</span></span><br><span class="line">		&#123;</span><br><span class="line">			value := counter</span><br><span class="line"></span><br><span class="line">			runtime.Gosched()</span><br><span class="line"></span><br><span class="line">			value++</span><br><span class="line"></span><br><span class="line">			counter = value</span><br><span class="line">		&#125;</span><br><span class="line">		mutex.Unlock()<span class="comment">//释放锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通道-channel"><a href="#通道-channel" class="headerlink" title="通道 channel"></a>通道 channel</h3><p>在goroutine之间还可以通过通道来发送和接受需要共享的资源，在goroutine之间做同步。当一个资源需要被goroutine共享时，通道在goroutine之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道，需要指定被共享的数据类型。go中需要使用内置函数make来创建一个通道。</p>
<p>通道的类型由两种：无缓冲通道与有缓冲通道。定义的方式如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//无缓冲</span></span><br><span class="line">unbuffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有缓冲 </span></span><br><span class="line">buffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通道的赋值和取值如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">buffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">buffered &lt;- <span class="string">&quot;ok, set channel value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">value := &lt;- buffered</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无缓冲通道就像“接力跑步赛”，数据就是那个“接力棒”，通道就是两个运动员之间的跑道。如果运动员A拿到接力棒，不将接力棒传到运动员B的手中，那么B就无法开始跑（阻塞），而A因为B没有拿到接力棒，A也无法去做其它的事情。所以A其实也是阻塞在了传递的这个过程中。可以看到传递“接力棒”和接受“接力棒”这两个过程其实是个同步的，两个都无法独立存在。</p>
<p>有缓存通道就像是吃转转火锅，通道就是传送带，数据就是传送带上的每碟食物，goroutine就是厨师和顾客。缓冲数量就是传送带可以放的碟子数量。所以一个厨师(goroutine)将餐碟放到传送带上，传送带本身就只能存放固定数量的餐碟，也就是缓冲带。如果缓冲带满了，那么厨师只能等待着，等到某个餐碟空了，再放食物。而顾客也是从传送带上取餐碟，只要传送带上面有餐碟，就会吃么。如果顾客拿到手中的餐碟没吃完，传送带上还有空位，那么厨师可以继续放，如果没有空位了，就只能等顾客，吃完再从传送带上取出餐碟，这样才能继续。</p>
<p>两者的区别：无缓冲通道保证接受和发送的goroutine会在同一时间进行数据交换；有缓冲通道就不提供这种保证。</p>
<p>要注意通道的关闭操作，当通道关闭后，goroutine依旧可以从通道接收数据，但是不能再往里面发送数据了。从通道获取数据的时候会返回一个ok标志，如果值为false，那说明通道已经关闭了。</p>
<p>看一下示例。</p>
<p>无缓冲通道：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This sample program demonstrates how to use an unbuffered</span></span><br><span class="line"><span class="comment">// channel to simulate a relay race between four goroutines.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// wg is used to wait for the program to finish.</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for all Go programs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create an unbuffered channel.</span></span><br><span class="line">	baton := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add a count of one for the last runner.</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First runner to his mark.</span></span><br><span class="line">	<span class="keyword">go</span> Runner(baton)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the race.</span></span><br><span class="line">	baton &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for the race to finish.</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runner simulates a person running in the relay race.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runner</span><span class="params">(baton <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newRunner <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait to receive the baton.</span></span><br><span class="line">	runner := &lt;-baton</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start running around the track.</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Runner %d Running With Baton\n&quot;</span>, runner)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// New runner to the line.</span></span><br><span class="line">	<span class="keyword">if</span> runner != <span class="number">2</span> &#123;</span><br><span class="line">		newRunner = runner + <span class="number">1</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Runner %d To The Line\n&quot;</span>, newRunner)</span><br><span class="line">		<span class="keyword">go</span> Runner(baton)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Running around the track.</span></span><br><span class="line">	time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Is the race over.</span></span><br><span class="line">	<span class="keyword">if</span> runner == <span class="number">2</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Runner %d Finished, Race Over\n&quot;</span>, runner)</span><br><span class="line">		wg.Done()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Exchange the baton for the next runner.</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Runner %d Exchange With Runner %d\n&quot;</span>,</span><br><span class="line">		runner,</span><br><span class="line">		newRunner)</span><br><span class="line"></span><br><span class="line">	baton &lt;- newRunner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有缓冲通道：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This sample program demonstrates how to use a buffered</span></span><br><span class="line"><span class="comment">// channel to work on multiple tasks with a predefined number</span></span><br><span class="line"><span class="comment">// of goroutines.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	numberGoroutines = <span class="number">4</span>  <span class="comment">// Number of goroutines to use.</span></span><br><span class="line">	taskLoad         = <span class="number">10</span> <span class="comment">// Amount of work to process.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// wg is used to wait for the program to finish.</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// init is called to initialize the package by the</span></span><br><span class="line"><span class="comment">// Go runtime prior to any other code being executed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Seed the random number generator.</span></span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for all Go programs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create a buffered channel to manage the task load.</span></span><br><span class="line">	tasks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, taskLoad)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Launch goroutines to handle the work.</span></span><br><span class="line">	wg.Add(numberGoroutines)</span><br><span class="line">	<span class="keyword">for</span> gr := <span class="number">1</span>; gr &lt;= numberGoroutines; gr++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(tasks, gr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add a bunch of work to get done.</span></span><br><span class="line">	<span class="keyword">for</span> post := <span class="number">1</span>; post &lt;= taskLoad; post++ &#123;</span><br><span class="line">		tasks &lt;- fmt.Sprintf(<span class="string">&quot;Task : %d&quot;</span>, post)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Close the channel so the goroutines will quit</span></span><br><span class="line">	<span class="comment">// when all the work is done.</span></span><br><span class="line">	<span class="built_in">close</span>(tasks)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for all the work to get done.</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker is launched as a goroutine to process work from</span></span><br><span class="line"><span class="comment">// the buffered channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tasks <span class="keyword">chan</span> <span class="keyword">string</span>, worker <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Report that we just returned.</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Wait for work to be assigned.</span></span><br><span class="line">		task, ok := &lt;-tasks</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// This means the channel is empty and closed.</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;Worker: %d : Shutting Down\n&quot;</span>, worker)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Display we are starting the work.</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker: %d : Started %s\n&quot;</span>, worker, task)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Randomly wait to simulate work time.</span></span><br><span class="line">		sleep := rand.Int63n(<span class="number">100</span>)</span><br><span class="line">		time.Sleep(time.Duration(sleep) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Display we finished the work.</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker: %d : Completed %s\n&quot;</span>, worker, task)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>提到goroutine的channel，通常都会与select一起使用。官网的说明：<a href="https://golang.google.cn/ref/spec#Select_statements">select</a>。简单的说一下select的用法：<br>1：select 的case一定是一个chan的表达式<br>2：select监听的是当前运行的goroutine，如果当前没有运行的goroutine会直接抛出panic；<br>3：如果没有default语句，而多个case都可以执行，那么随机取一个；<br>4：如果有default语句，且case多个可以执行，执行default</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chann</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>, stopCh <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">	<span class="comment">//for &#123;</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="comment">//ch &lt;- i</span></span><br><span class="line">		<span class="comment">//fmt.Println(i)</span></span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stopCh &lt;- <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChan</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	c := <span class="number">0</span></span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> Chann(ch, stopCh)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> ch &lt;- <span class="number">10</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">			fmt.Println(<span class="string">&quot;Recvice c1&quot;</span>, c)</span><br><span class="line">			fmt.Println(<span class="string">&quot;channel&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">			fmt.Println(<span class="string">&quot;Receive s&quot;</span>, ch)</span><br><span class="line">			<span class="comment">//case _ = &lt;-stopCh:</span></span><br><span class="line">			<span class="comment">//	fmt.Println(&quot;stop&quot;)</span></span><br><span class="line">			<span class="comment">//	goto end</span></span><br><span class="line">			<span class="comment">//default:</span></span><br><span class="line">			<span class="comment">//	fmt.Println(&quot;default&quot;)</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//end:</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 包项目结构</title>
    <url>/2019/03/31/golang-package-struct/</url>
    <content><![CDATA[<h1 id="golang-包项目结构"><a href="#golang-包项目结构" class="headerlink" title="golang 包项目结构"></a>golang 包项目结构</h1>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 基础入门 - 数据类型</title>
    <url>/2019/07/14/golang-type/</url>
    <content><![CDATA[<h1 id="golang-基础入门-数据类型"><a href="#golang-基础入门-数据类型" class="headerlink" title="golang 基础入门 - 数据类型"></a>golang 基础入门 - 数据类型</h1><p>任何一门语句都会有它的基本关键字和数据类型。golang的数据类型大致分为三种：基本类型，引用类型，结构体。</p>
<p><img src="/images/qiniu/2019-07-14-23-35-07.png" alt="2019-07-14-23-35-07"></p>
<p>类型的一些细节可以参考：<a href="https://github.com/golang/go/wiki">官网</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 基础入门</title>
    <url>/2019/07/14/hello-golang/</url>
    <content><![CDATA[<h1 id="Golang-基础入门"><a href="#Golang-基础入门" class="headerlink" title="Golang 基础入门"></a>Golang 基础入门</h1><p>了解任何事物首先得了解一下它的历史。golang 在2007年就开始开发，在09年开源，并且在12年发布了第一个稳定版本GO 1。今年19年，go这些年的发展是很快的，目前的版本是go 1.12.7，目前go的开发节奏是半年发布一个版本。并且golang承诺，go的更新时兼容之前的版本的。</p>
<h2 id="Golang-安装"><a href="#Golang-安装" class="headerlink" title="Golang 安装"></a>Golang 安装</h2><p>在golang的官网<a href="https://golang.org/">golang.org</a>下载最新版本的golang或者你需要的版本。接下来如果是windows的机器，那么只需要一路next就行了,之后在<code>c:\\go</code>文件夹下就可以了。如果是Linux系统，只需要将tar.gz包解压到自己工作的位置，然后将$GOLANG_PATH\bin加入到path就可以了。</p>
<span id="more"></span>

<h2 id="Hello-Go"><a href="#Hello-Go" class="headerlink" title="Hello Go"></a>Hello Go</h2><p>开始一门新语言的探险时，大家的第一个demo肯定是“Hello World”。我们也开始第一个”Hello Go”吧：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello,Go..&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将上面的内容保存为一个<code>main.go</code>文件，然后使用<code>go run main.go</code>。你就可以看到输出了，超级简单。</p>
<p>不得不说是真的简洁。看到上面的代码，我们开始进行一下基本golang开发介绍。</p>
<h2 id="main包main方法"><a href="#main包main方法" class="headerlink" title="main包main方法"></a>main包main方法</h2><p>golang中定义一个包的关键字就是<code>package</code>，程序的入口始终都是<code>main</code>包中的<code>main()</code>方法，程序始终都是从这里开始。<br>不像Java中的lang包不需要导入，golang中除了一些关键字，其它的不管是内部包，还是外部包都需要通过关键字<code>import</code>进行导入。</p>
<h2 id="GOROOT，GOPATH"><a href="#GOROOT，GOPATH" class="headerlink" title="GOROOT，GOPATH"></a>GOROOT，GOPATH</h2><p>golang 中有个路径非常重要：GOROOT 和 GOPATH ; </p>
<p>GOROOT ： 其实就是golang的安装目录，当你用在控制台输入： <code>go env GOROOT</code>就能获取到值。</p>
<p>GOPATH ： 实际开发工作的目录。</p>
<p>GOROOT 就不多讲了，这里讲一下GOPATH；golang程序开发不像之前Java开发，Java开发，可能是项目名/src/路径-源码。而golang中，你的所有开发代码其实都是放在GOPATH下的，而且是在$GOPATH/src下。在GOPATH中定义了三个文件夹：<code>src</code>,<code>pkg</code>,<code>bin</code>。</p>
<ol>
<li>pkg 存放项目编译时期的中间文件，比如:<code>.a</code>文件；</li>
<li>bin 目录存放项目的可执行文件，如果你把这个路径放到path目录下，那么就可以直接在控制台执行这里目录下的可执行文件；</li>
<li>src 源码存放路径记住，开发中一定要将代码放到这个路径下；比如Java开发者可能就不适应，因为之前的Java是<code>项目名/src</code>的方式，现在golang是<code>src/项目名</code>;</li>
</ol>
<p>如果开发一个应用<code>myserver</code>,那么目录结构就是：<code>$GOPATH/src/myserver</code>; golang在编译的时候是会自动去找GOPATH下src目录的。这样你可以把所有相关联的项目放到一个GOPATH路径下，不同的项目之间可以隔开，也可把所有项目都放在一个GOPATH下，这样这个路径下的所有包，你都可以直接导入。当然你也可以照样像Java那样包路径结构，只是需要记住要将项目根路径指定为GOPATH，不然编译就会报错。</p>
<h2 id="golang的包"><a href="#golang的包" class="headerlink" title="golang的包"></a>golang的包</h2><p>你可能注意到了我们上面<code>hello go</code>的第二行 <code>import &quot;fmt&quot;</code>；这里的作用就是导入fmt包，这个包在哪里了？golang寻找import包的优先级为：GOROOT–&gt;GOPATH;如果找不到你也可以使用<code>go get</code>工具，它会帮你自动下载包;</p>
<p>项目开发中项目结构如下：</p>
<p><img src="/images/qiniu/2019-07-14-22-14-21.png" alt="2019-07-14-22-14-21"></p>
<p>我们看一个包导入的例子：</p>
<p><img src="/images/qiniu/2019-07-14-22-42-50.png" alt="2019-07-14-22-42-50"></p>
<p>我在项目中的handler下定一个了方法<code>Hello</code>，包名为<code>handler</code>;正常情况下，在main包中我们如果掉用它的话就是<code>handler.Hello()</code>;如下：</p>
<p><img src="/images/qiniu/2019-07-14-22-44-21.png" alt="2019-07-14-22-44-21"></p>
<p>可以看到，main 方法中出了一场，报的是找不到handler包。这个时候要看一下我们的GOPATH了，之前我们也说了golang是先从goroot再从gopath去寻找包的。goroot，一般大家也不会将源码放那里，我们现在看下GOPATH的目录：</p>
<p><img src="/images/qiniu/2019-07-14-22-46-46.png" alt="2019-07-14-22-46-46"></p>
<p>这下可以看到了吧。我们的项目路径是：<code>D:\workspace-paas\goinaction</code>;但是gopath的路径是<code>D:\Users\chenzj001\go</code></p>
<p>我们可以知道GOPATH下是没有我们的handler包的。这个时候的修改方式有两个：</p>
<ol>
<li>将项目移到gopath目录的src目录下；</li>
<li>将GOPATH设置为当前的工作目录；</li>
</ol>
<p>如果采用1的话那么恭喜你，问题解决。如果采用2,哈，那么恭喜你，你肯定是Java派golang开发者，同道中人啊。你可能会想，我不是将GOPATH指到当前项目根路径了么？怎么还是导入不了。唉~。其实就像前面说的，go寻找包的时候都是去src目录下找的。所以你需要在项目路径下再建立一个src目录，再将源码放进去，就能解决异常了，采用2，就相当于是你要用Java开发的包路径结构。这种其实是不推荐的，入乡随俗还是独树一帜看你选择了。我是觉得按照大家的约定会比较好。</p>
<p>我们采用第一种方式，你看下图：</p>
<p><img src="/images/qiniu/2019-07-14-22-59-40.png" alt="2019-07-14-22-59-40"></p>
<p>你可以看到上面的gopath。</p>
<blockquote>
<p>ps: 其实你是可以同时设置多个GOPATH的哦，可以自己动手尝试一下。</p>
</blockquote>
<h2 id="GO-自带的工具"><a href="#GO-自带的工具" class="headerlink" title="GO 自带的工具"></a>GO 自带的工具</h2><p>GO 自带了一些常用工具，使用<code>go --help</code>就能看到。这里介绍常用的几个：</p>
<ol>
<li><code>go build</code>,编译包</li>
<li><code>go run</code>,编译运行</li>
<li><code>go fmt</code>,golang内置的将代码格式化</li>
<li><code>go doc</code>,golang的文档</li>
<li><code>go test</code>,golang测试工具</li>
<li><code>go get</code>,下载导入外部包</li>
</ol>
<p>go 也可以编译成其它平台的可执行文件，比如window下编译成Linux下的执行文件<a href="http://chenzhijun.top/2019/03/31/windows-compile-golang-to-linux-running-script/">golang编译成Linux环境下的二进制文件</a>。</p>
<p>go 的这些工具还是挺有用的，没事可以多用用。</p>
<p>这篇文章介绍了下go的发展史，也写下了<code>hello go</code>之后介绍了gopath，goroot，以及go自带的工具。其实golang其实是面向程序员友好的，对比Java动辄就是几十行代码，golang确实很简洁。不过对比Java来说，golang的生态其实感觉并没有Java那么的完善，另一方面，golang的包管理，我到现在还是有点。。还有一个就是在国内访问golang官网需要科学上网。这有点像什么了，我要推广给大家用，但是大家用起来又是各种阻碍，在已有的产品能实现需求的产品上，如果新产品不能提供很好的体验，其实要退光是有困难的。另一方面，golang其实面向的最多的感觉还是C/C++来转型。一门语言其实有它的优势，也肯定有它的不足。适合自己的业务场景，个人发展路径，取舍在于自己，我从一开始其实挺不喜欢golang的，但最近学会不排斥的心态去了解之后，感觉是真的爽。个人观点，不喜勿喷。一千个观众有一千个哈姆雷特。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Travis-CI持续构建Hexo博客</title>
    <url>/2017/12/19/hexo-travis-ci/</url>
    <content><![CDATA[<h2 id="使用Travis-CI持续构建Hexo博客"><a href="#使用Travis-CI持续构建Hexo博客" class="headerlink" title="使用Travis-CI持续构建Hexo博客"></a>使用Travis-CI持续构建Hexo博客</h2><p>我是用的 Hexo+Github Page 来构建自己的博客。在 Github 创建<code>your_github_name.github.io</code>仓库的时候，可以直接使用<code>your_github_name.github.io</code>作为你的博客域名站点。详细的话，可以自己去 google 下使用 Hexo搭建个人博客。</p>
<p>写本文的原因是因为，每次我在写完一篇总结，提交了push之后。如果要更新到博客上，需要经历的过程就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交源文件到仓库</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布到博客站点</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里还需要输入github账号，密码。</span></span><br></pre></td></tr></table></figure>

<p>我觉得如果提交源文件push之后能够直接发布到博客站点就好了。在网上搜了一圈，很多人的资料还是有些缺陷，自己踩了一路坑，所以有了本篇记录。</p>
<h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><p>先介绍下我的博客环境，我用了两个repo:<br>一个是存博客源码的<code>blog.git</code>,<br>另一个也就是用来做站点发布的<code>chenzhijun.github.com.git</code>。</p>
<blockquote>
<p>网上很多人喜欢用一个库，然后切换分支的做法。之前我也弄过，不过后来发现我经常弄错分支。反正repo不要钱，就无所谓，分开吧。其实就是懒。总之，自己爽就好。</p>
</blockquote>
<span id="more"></span>

<h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><p>其实就是将生成的目录public下的所有文件当作了chenzhijun.github.com.git库下面的文件。</p>
<ol>
<li>生成一个<a href="https://github.com/settings/tokens">Personal access tokens</a>.Token记得勾选如下权限，然后copy保存：</li>
</ol>
<p><img src="/images/qiniu/2017-12-19-15-21-03.png" alt="2017-12-19-15-21-03"></p>
<ol start="2">
<li><p>注册Travis-CI账号：<a href="https://travis-ci.org/">https://travis-ci.org</a>。我是直接使用github登陆的，方便。</p>
</li>
<li><p>激活需要进行CI的仓库：</p>
</li>
</ol>
<p><img src="/images/qiniu/2017-12-19-15-25-02.png" alt="2017-12-19-15-25-02"></p>
<p>点击仓库进去做配置，找到设置的地址：</p>
<p><img src="/images/qiniu/2017-12-19-15-25-48.png" alt="2017-12-19-15-25-48"></p>
<p>配置环境变量等：</p>
<p><img src="/images/qiniu/2017-12-19-15-29-15.png" alt="2017-12-19-15-29-15"></p>
<ol start="4">
<li>之后在博客根目录创建<code>.travis.yml</code>文件，我的文件内容为：</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> <span class="comment"># 设置语言</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span> <span class="comment"># 设置相应版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">    <span class="attr">apt:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">directories:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">node_modules</span> <span class="comment"># 设置缓存，传说会在构建的时候快一些</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># 安装hexo及插件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span> <span class="comment"># 清除</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span> <span class="comment"># 生成</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">$&#123;GH_REF&#125;</span> <span class="string">pub_web</span> <span class="comment"># 因为我有两个仓库，先将发布服务的仓库clone下来，</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-rf</span> <span class="string">public/*</span> <span class="string">pub_web/</span> <span class="comment"># 将源博客仓库(blog.git)目录下的public文件夹下的文件复制到发布服务的仓库(chenzhijun.github.com.git)中</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">pub_web</span> <span class="comment"># 进入到git仓库</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">&quot;username&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">&quot;email@address.com&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-am</span> <span class="string">&quot;Travis CI Auto Builder :$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27; -d &#x27;+8 hour&#x27;)&quot;</span> <span class="comment"># 零时区，+8小时</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">master</span> </span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">    <span class="attr">only:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">master</span> <span class="comment">#只监测master分支,这是我自己的博客，所以就用的master分支了。</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">https://yourname:$&#123;GITHUB_TOKEN&#125;@github.com/yourname/your.blog.address.git</span> <span class="comment">#设置GH_REF，注意更改yourname,GITHUB_TOKEN:就是我们在travis-ci仓库中配置的环境变量</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在<code>_config.yml</code>中加入(这里如果是用hexo，应该一开始就会弄好了)：</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/yourname/yourname.github.com.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>到这里，我们一个简单的ci就弄好了,你可以试着提交一个commit，然后push到你的仓库之后在travis-ci里面就能看到build日志了。</p>
<p><img src="/images/qiniu/2017-12-19-16-17-25.png" alt="2017-12-19-16-17-25"><br><img src="/images/qiniu/2017-12-19-16-17-42.png" alt="2017-12-19-16-17-42"></p>
<p>其实简单的原理就是：</p>
<ol>
<li>向仓库<code>blog.git</code>提交commit；</li>
<li>travis-ci 自动构建<code>blog.git</code>,根据<code>.travis.yml</code>的配置执行；</li>
<li>运行<code>hexo g</code>之后，<code>public</code>目录下文件更新；</li>
<li>克隆<code>chenzhijun.github.com.git</code>仓库，将其命名为别名<code>pub_web</code>，将public下的文件复制到<code>pub_web</code>；</li>
<li>将pub_web目录下的文件提交commit；</li>
<li>push最新的文件到github。</li>
</ol>
<blockquote>
<p>特别注意 personal token只在仓库的https协议下有效，官网说的：<a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/">Creating a personal access token for the command line</a></p>
</blockquote>
<p>这样站点就更新了，如果你是在一个仓库下多个分支，我想应该也容易了。自己动手，丰衣足食。</p>
<p>相关参考：</p>
<p><a href="http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/">使用Travis CI自动部署Hexo博客</a></p>
<p><a href="http://zhzhou.me/2017/02/20/auto-deploy-hexo-on-travis-ci/">使用 Travis-CI 来自动化部署 Hexo</a></p>
<p><a href="http://kchen.cc/2016/11/12/hexo-instructions/">基于 Hexo 的全自动博客构建部署系统</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo - Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate 校验参数</title>
    <url>/2018/01/31/hibernater-validate-properties/</url>
    <content><![CDATA[<h1 id="Hibernater-Validator-校验参数"><a href="#Hibernater-Validator-校验参数" class="headerlink" title="Hibernater Validator 校验参数"></a>Hibernater Validator 校验参数</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>如果我们使用spring mvc 那么肯定知道在方法中我们可以使用注解对参数进行校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(<span class="meta">@Valid</span> User user)</span></span>&#123;</span><br><span class="line">    User userP = user;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候通常是在User对象里面使用一些注解来判断如：@NotNull,@NotEmpty。这些bean验证方法是遵循JSR303和JSR380规范的，目前的情况可以去这里查看详情：<a href="http://beanvalidation.org/2.0/">http://beanvalidation.org/2.0/</a>。</p>
<p>实现规范的这些中有一个包是<a href="http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-customconstraints-simple">Hibernate Validator</a>，这个包不是我们的ORM框架，可能是orm太出名了，以致于提到Hibernate大家都会想到SSH的Hibernate ORM，其实Hibernate Validator是一个非常完善的bean Validator。如果我们不想自己去实现一套，其实是可以引入这个包的。开源社区遇到的情况肯定会比我们自己要多。而且它也支持我们自定义注解来进行校验。</p>
<p>在我们的系统中，是无法采用@Valid这种方式的，因为我们有一些特别的操作处理所以不能使用它。如果你想自己使用的话，可能可以像我这样，写一个Validtor工具类，然后在需要的地方调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Validator VALIDATOR = Validation.byProvider(HibernateValidator.class).configure().failFast(<span class="keyword">true</span>).buildValidatorFactory().getValidator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">validate</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        Set&lt;ConstraintViolation&lt;T&gt;&gt; validateResult = VALIDATOR.validate(obj);</span><br><span class="line">        <span class="keyword">if</span>(!validateResult.isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;message:&quot;</span>+validateResult.iterator().next().getMessage());</span><br><span class="line">            System.err.println(<span class="string">&quot;messageKey:&quot;</span>+validateResult.iterator().next().getMessageTemplate());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;参数校验失败:%s&quot;</span>, validateResult.iterator().next().getPropertyPath().toString()+validateResult.iterator().next().getMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后你可以在属性上面这样定义：</p>
<p><img src="/images/qiniu/2018-01-31-20-00-07.png" alt="2018-01-31-20-00-07"></p>
<p>如果需要使用校验的，只需要使用<span id="more"></span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ValidatorUtil.validate(obj);</span><br></pre></td></tr></table></figure>

<p>如果有异常它会直接抛出来。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>如果在某些场景下，提供给我们的注解不够用，那我们是否可以自己进行扩展了？ 好的架构，是允许做扩展的。validator也可以支持自定义注解。自定义注解详解在这里<a href="http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-customconstraints">自定义验证规则注解</a>。总的来说就是三步：</p>
<ol>
<li>创建一个注解，并且定义一些校验规则；</li>
<li>继承Validator；</li>
<li>定义默认的error message</li>
</ol>
<p>现在我们尝试定义一个自定义注解：</p>
<ol start="0">
<li>准备，定义一个枚举，接下来用到：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenzhijiun.validator.customer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/1/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CaseMode</span> </span>&#123;</span><br><span class="line">    UPPER,</span><br><span class="line">    LOWER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个注解:<code>CheckCase</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenzhijiun.validator.customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123; FIELD, METHOD, PARAMETER, ANNOTATION_TYPE, TYPE_USE &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = CheckCaseValidator.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CheckCase &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;</span>&#123;org.hibernate.validator.referenceguide.chapter06.CheckCase.<span class="string">&quot; +</span></span><br><span class="line"><span class="string">            &quot;</span>message&#125;<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    CaseMode value();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>继承Validator,并且将实现自己的规则逻辑</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chenzhijiun.validator.customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/1/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckCaseValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">CheckCase</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CaseMode caseMode;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(CheckCase constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.caseMode = constraintAnnotation.value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String object, ConstraintValidatorContext constraintContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( object == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( caseMode == CaseMode.UPPER ) &#123;</span><br><span class="line">            <span class="keyword">return</span> object.equals( object.toUpperCase() );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> object.equals( object.toLowerCase() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们这里的主要逻辑就在isValid中处理的。</p>
<ol start="3">
<li>定义error message ，这个错误提示在哪里定义了？我们可以看到在<code>org.hibernate.validator.resource</code>下有很多的properties文件，<br>这是因为Hibernate做了国际化处理。<br><img src="/images/qiniu/2018-01-31-20-14-03.png" alt="2018-01-31-20-14-03"></li>
</ol>
<p>如果我们需要重写，只需要将其中的中文的属性文件进行重写放到resource目录就可以了。在定义的注解中我们可以将message指定为我们复制的properties文中<br>的key，这样就能完成error message的自定义了。</p>
<p>源码：<a href="https://gitee.com/chenzhijun/validator">https://gitee.com/chenzhijun/validator</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Validator</tag>
      </tags>
  </entry>
  <entry>
    <title>编写属于自己的springboot-starter</title>
    <url>/2018/01/31/how-to-build-springboot-starter/</url>
    <content><![CDATA[<h1 id="编写属于自己的springboot-starter"><a href="#编写属于自己的springboot-starter" class="headerlink" title="编写属于自己的springboot-starter"></a>编写属于自己的springboot-starter</h1><p>最近手痒，想实现一下自己的starter，感概于springboot的starter导入方便，要是能有一款自己的starter，那样多么好，比起之前的maven导入方式，好像更有意思。<br>主要可以加重对springboot的自动配置装载的理解。</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>starter的简易目录如下，”autoconfiguration”,”domain”,”service”,”META-INF”：</p>
<span id="more"></span>
<p><img src="/images/qiniu/2018-01-31-11-03-47.png" alt="2018-01-31-11-03-47"></p>
<p>这几个包的作用如下：<br><code>domain</code>一般放置配置的参数，比如我们通常在<code>application.properties</code>中用到的<code>xxx.yyy=value</code>,其中<code>xxx.yyy</code>就是在这里配置的,前面的<code>xxx</code>我们一般指前缀，用以标识某个类级别，后面的<code>yyy</code><br>一般会是指代属性，如果是驼峰标识的属性在properties文件中，默认为<code>-</code>连接。其中前缀的定义方式使用注解<code>@ConfigurationProperties</code></p>
<p><img src="/images/qiniu/2018-01-31-11-12-21.png" alt="2018-01-31-11-12-21"></p>
<p><code>service</code>服务的实际配置使用，我们获取到参数之后，总要将参数用起来，那么参数配置才有价值，而这些都是在service中做处理，也就是业务处理。所以可以想象的到，在service类里面，我们肯定需要一个<br>domain的类来接收配置的参数。</p>
<p><img src="/images/qiniu/2018-01-31-11-16-39.png" alt="2018-01-31-11-16-39"></p>
<p><code>autoconfiguration</code>包其实就是我们的自动装载配置了，它需要告诉系统我们要让哪个配置类自动装载，spring的ioc要管理bean，前提就是这个bean要被加载到了容器中，所以我们需要注入配置类(domain)<br>使用@Configuration指明当前类是配置类，使用@EnableConfigurationProperties指明快速注册到spring中的类。</p>
<p><img src="/images/qiniu/2018-01-31-11-20-27.png" alt="2018-01-31-11-20-27"></p>
<p>另外就是resource下的META-INF包下的<code>spring.factories</code>文件，这里说的是元信息，也是指明我们的配置启动类是在哪个目录，在其它的spring项目里面也可以看到这个文件。</p>
<p><img src="/images/qiniu/2018-01-31-19-33-18.png" alt="2018-01-31-19-33-18"></p>
<p>现在我们看下pom文件我们导入的包：</p>
<p><img src="/images/qiniu/2018-01-31-19-35-17.png" alt="2018-01-31-19-35-17"></p>
<p>我在这里加入了configuration-processor包，这种情况下能够方便我们在配置文件中使用我们自定义的前缀，然后进行提示。</p>
<p><img src="/images/qiniu/2018-01-31-19-37-34.png" alt="2018-01-31-19-37-34"></p>
<p>注意到我这里有些jar包引入的时候使用optional，这种方式声明的包不会让jar包顺延，也就是在使用方我们仍需导入这个包才能使用。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样用SSH连接VirtualBox</title>
    <url>/2017/04/26/how-to-connect-virtual-box-with-ssh/</url>
    <content><![CDATA[<h3 id="用-iterm2-ssh连接virtual-box中运行的centos-minimal版本"><a href="#用-iterm2-ssh连接virtual-box中运行的centos-minimal版本" class="headerlink" title="用 iterm2 ssh连接virtual box中运行的centos minimal版本"></a>用 iterm2 ssh连接virtual box中运行的centos minimal版本</h3><h4 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h4><ul>
<li>安装好虚拟机vb</li>
<li>centos官网下载minimal版本，也可以下载dvd版本之后只安装minimal</li>
<li>iterm2</li>
</ul>
<p>安装过程很简单，直接点击vb的new，之后按照提示一步一步点下去就可以了。<br><a href="http://www.jianshu.com/p/2a853d569228">给个安装教程网址</a></p>
<h4 id="特殊注意点"><a href="#特殊注意点" class="headerlink" title="特殊注意点"></a>特殊注意点</h4><p>如果选择<code>host-only adapter</code>的时候出现无法确认，或者无法选择的情况。这种情况下是因为虚拟机本身没有开一个host-only adapter。可以打开vb的系统设置，然后找到网络(network),选择Host-Only Networks。新建一个就可以了<br><img src="/images/vb-host-only-sys.png"></p>
<p>有问题欢迎留言，一起交流学习。 </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>异常堆栈信息打印</title>
    <url>/2017/11/02/how-to-print-error-stack/</url>
    <content><![CDATA[<h2 id="异常堆栈信息打印"><a href="#异常堆栈信息打印" class="headerlink" title="异常堆栈信息打印"></a>异常堆栈信息打印</h2><p>最近在开发积分和优惠券，忙的焦头烂额，基本上每天都在想着代码怎么写，功能怎么实现。整个架构是怎样。没有产品经理来梳理需求，基本上靠自己写。唉~ 。比较痛苦的是，我开发完功能，然后交互自己又给我随意乱加功能，导致我有些代码的重写，当然直接接口的封装而已，但是这种感觉很不爽，我都开发完了，你也不知会我一下，就乱来。</p>
<span id="more"></span>
<p>不扯了。今天要记录下一个功能，就是将异常信息，通过邮件发送给我。过程中遇到一个问题，怎样获取到异常堆栈信息并将它输出为字符串，来通过邮件的形式发送出来。</p>
<p>其中最为主要的就是获取异常堆栈，并将之输出为字符串；</p>
<p>下面是一个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        testNullException();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> PrintWriter(sw);</span><br><span class="line">        System.out.println(<span class="string">&quot;e.getCause() : &quot;</span> + e.getCause());</span><br><span class="line">        System.out.println(<span class="string">&quot;e.getSuppressed() ： &quot;</span> + e.getSuppressed());</span><br><span class="line">        System.out.println(<span class="string">&quot;e.getStackTrace() ： &quot;</span> + e.getStackTrace());</span><br><span class="line">        System.out.println(<span class="string">&quot;e.getLocalizedMessage() ： &quot;</span> + e.getLocalizedMessage());</span><br><span class="line">        System.out.println(<span class="string">&quot;e.getMessage() ： &quot;</span> + e.getMessage());</span><br><span class="line">        System.out.println(<span class="string">&quot;e.getClass() ： &quot;</span> + e.getClass());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * e.getCause() : null</span></span><br><span class="line"><span class="comment">         e.getSuppressed() ： [Ljava.lang.Throwable;@5b464ce8</span></span><br><span class="line"><span class="comment">         e.getStackTrace() ： [Ljava.lang.StackTraceElement;@57829d67</span></span><br><span class="line"><span class="comment">         e.getLocalizedMessage() ： null</span></span><br><span class="line"><span class="comment">         e.getMessage() ： null</span></span><br><span class="line"><span class="comment">         e.getClass() ： class java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==================&quot;</span>);</span><br><span class="line">        e.printStackTrace(pw);</span><br><span class="line">        System.out.println(<span class="string">&quot;e &quot;</span> + sw.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testNullException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>).toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的主要原理就是通过<code>throwable</code>的<code>printStackTrace(pw)</code>将输出输出到流中，然后通过字符流将其中的数据转换成字符。所以我们可以进行一些封装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStackTrace</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">    StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(sw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        throwable.printStackTrace(printWriter);</span><br><span class="line">        <span class="keyword">return</span> sw.toString();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能你会想说，为啥<code>StringWriter</code>没有在<code>finally</code>关闭，其实不是不关闭，而是<code>sw.close()</code>它就是一个空实现，调用它的<code>close</code>方法，其实也没做操作。</p>
<p>有问题欢迎留言交流，或者联系。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样将shell中命令执行的结果赋值给变量</title>
    <url>/2019/03/31/how-to-transfer-linux-command-result-to-variable-in-shell/</url>
    <content><![CDATA[<h1 id="怎样将shell中命令执行的结果赋值给变量"><a href="#怎样将shell中命令执行的结果赋值给变量" class="headerlink" title="怎样将shell中命令执行的结果赋值给变量"></a>怎样将shell中命令执行的结果赋值给变量</h1><p>其实这个比较简单。只需要将命令使用反单引号起来就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">srvname=`docker inspect 1swd3|grep &quot;name&quot;|awk -F &quot;,&quot; &#x27;&#123;print $1&#125;&#x27;|awk &#x27;&#123;print $NF&#125;&#x27;`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Ansible批量操作服务器</title>
    <url>/2018/07/16/how-to-use-ansible-to-do-something/</url>
    <content><![CDATA[<h1 id="使用Ansible批量操作服务器"><a href="#使用Ansible批量操作服务器" class="headerlink" title="使用Ansible批量操作服务器"></a>使用Ansible批量操作服务器</h1><p>Anbible 是干嘛的？对于一个非专业运维人士（我）来说，它就是我批量操作服务器的一个神器。试想一个场景：公司内部DNS还未搭建好，业务系统使用了域名做请求，这个时候需要你将域名制定到某台机器上，你这个时候就只能修改hosts文件了。嗯，如果是一两台服务器就算了，大不了手动ssh上去改一改，但是如果是10台了？10台不够，100台了？这个时候怎么办？你可能说我召集了一帮兄弟，大家一人改几个。OK，好不容易你改完了，这个时候业务跟你说，嗯，那台服务器挂了，不稳定，暂时换到另一台服务器上另一个IP地址。兄弟，听说醉经淘宝刀打折，买一把吧。哈哈</p>
<p>但是如果这个时候我们使用ansible，这个时候你就可以早点干完，早点回家陪老婆孩子了。接下来我们看看怎么使用ansible，请注意，我只是说怎么使用，是的，怎么使用，没有任何理论，不会讲解任何深的东西，只是用而已。</p>
<span id="more"></span>
<p>1：批量操作服务器。</p>
<p>ansible的一个简单目录结构：<br><img src="/images/qiniu/2018-07-16-22-34-50.png" alt="2018-07-16-22-34-50"></p>
<p><code>install.yml</code>文件内容：</p>
<p><img src="/images/qiniu/2018-07-16-22-36-22.png" alt="2018-07-16-22-36-22"></p>
<p>&lt;!–&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: all </span><br><span class="line">  remote_user: rhlog</span><br><span class="line">  gather_facts: no</span><br><span class="line">  roles:</span><br><span class="line">    - role: oam</span><br><span class="line">      become: yes</span><br><span class="line">      become_method: su</span><br><span class="line">      become_user: root</span><br></pre></td></tr></table></figure>
<p>&lt;–&gt;</p>
<p><code>hosts</code> 文件内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.0.80.34 ansible_become&#x3D;true ansible_become_method&#x3D;su ansible_user&#x3D;ssh_user ansible_ssh_pass&#x3D;&quot;password&quot; ansible_become_pass&#x3D;&quot;ax&#x3D;n@#*!EM&quot; ansible_become_user&#x3D;root</span><br><span class="line">10.07.80.37 ansible_become&#x3D;true ansible_become_method&#x3D;su ansible_user&#x3D;ssh_user ansible_ssh_pass&#x3D;&quot;W)PIukAa&quot; ansible_become_pass&#x3D;&quot;r.*o)Hg!z&quot; ansible_become_user&#x3D;root</span><br></pre></td></tr></table></figure>

<p>这两个是ansible的根目录里面比较重要的文件。install.yml里面remote_user是指登录到服务器的用户，通常大家不会让root用户远程登录的。roles是指在roles文件里面有哪些角色，你要用使用哪个角色。hosts文件一般保存的账号密码。按照这个模式登录就好了。之后我会提供这个安装包，大家可以自己照着改。哈哈。</p>
<p>oam角色里文件内容为：<br><img src="/images/qiniu/2018-07-16-22-41-50.png" alt="2018-07-16-22-41-50"><br>主要看tasks目录里面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"># tasks file for oam</span><br><span class="line">- name: upload file</span><br><span class="line">  copy: src&#x3D;&#x2F;app&#x2F;installation&#x2F;resource&#x2F;moving&#x2F;test&#x2F;roles&#x2F;oam&#x2F;files&#x2F;data.sh dest&#x3D;&#x2F;home&#x2F;data.sh mode&#x3D;755</span><br><span class="line">- name: excute </span><br><span class="line">  shell:  bash &#x2F;home&#x2F;data.sh</span><br><span class="line">- name: find file </span><br><span class="line">  find:</span><br><span class="line">    paths: &#x2F;home&#x2F;</span><br><span class="line">    patterns: &quot;*.log&quot;</span><br><span class="line">    recurse: no</span><br><span class="line">  register: file_2_fetch</span><br><span class="line">- name: fetch</span><br><span class="line">  fetch:</span><br><span class="line">    src: &quot;&#123;&#123; item.path &#125;&#125;&quot;</span><br><span class="line">    dest: &#x2F;home&#x2F;diskdata&#x2F;</span><br><span class="line">    flat: yes</span><br><span class="line">  with_items: &quot;&#123;&#123; file_2_fetch.files &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>&lt;!–&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># !&#x2F;bin&#x2F;bash</span><br><span class="line">name&#x3D;$(hostname -i)</span><br><span class="line">file&#x3D;$&#123;name%% *&#125;</span><br><span class="line">df -h &gt;&#x2F;home&#x2F;rhlog&#x2F;$file.log</span><br></pre></td></tr></table></figure>
<p>&lt;–&gt;<br>在ansible根目录我怎么使用了？<code>ansible-playbook -i hosts install.yml</code> 我的这个程序就是将files目录下的data.sh上传到hosts里面的所有主机中，然后执行data.sh，将<code>df -h</code>的内容输出到<code>ip.log</code>文件中，然后将文件下载到本地<code>/home/diskdata</code>中。这样就相当于批量操作了所有的机器。</p>
<p>另外一个使用方式，不使用上面那种方式，而是直接使用命令行的方式：</p>
<p>1： 判断所有机器是否可以访问某个地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible all -i hosts -m get_url -a &quot;url&#x3D;http:&#x2F;&#x2F;192.168.11.32:8088&#x2F;srv&#x2F;releaseService?wsdl dest&#x3D;.&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<p>2: 判断所有机器是否可以ping通某个地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible all -i hosts -m shell -a &quot;ping -c 3 10.7.18.3&quot;</span><br></pre></td></tr></table></figure>

<p>3: 查找所有机器上某个应用是否启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible all -i hosts -m shell -a &quot;ps -ef | grep haproxy | grep -v grep&quot;</span><br></pre></td></tr></table></figure>

<p>4: 判断所有机器能否连通某个端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible all -i hosts -m shell -a &quot;telnet 192.167.180.3 25&quot;</span><br></pre></td></tr></table></figure>

<p>5: 批量修改某个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible all -i .&#x2F;hosts -s -m shell -a &quot;echo \&quot;127.0.0.1 test.local.com\&quot; &gt;&gt; &#x2F;etc&#x2F;hosts&quot;</span><br></pre></td></tr></table></figure>

<p>ps:</p>
<p><code>-s</code>,是指使用root账户</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>idea-linux-vim等常用快捷键</title>
    <url>/2018/03/26/idea-linux-vim-command-shortcut/</url>
    <content><![CDATA[<p>最近经常看到一些有意思的快捷键，但是又不是经常用到，平常经常用的肯定都能很熟悉了。</p>
<h2 id="idea-常用快捷键"><a href="#idea-常用快捷键" class="headerlink" title="idea 常用快捷键"></a>idea 常用快捷键</h2><p>最常用的肯定是 find action :<code>ctrl shift A</code>，这简直就是神器，如果忘记快捷键，尝试使用这个，然后输入快捷键的功能名称就有可能找到相应 功能了。</p>
<ol>
<li><p>idea 弹出当前类里面的方法框：<code>ctrl o</code>, 类结构图，<code>file structure</code>：<code>ctrl F12</code></p>
</li>
<li><p>跳转： navigate -&gt; back/forward; navigate -&gt; last edit location/next edit location</p>
</li>
<li><p>最近的文件：recent file/recent changed file    <code>ctrl + E</code></p>
 <span id="more"></span></li>
<li><p>书签跳转，bookmarks :<br> <code>F11</code>快速打一个书签；<br> <code>ctrl F11</code>定一个数字，之后使用ctrl+数字快速定位；<br> <code>shift F11</code> 弹出书签预览。</p>
</li>
<li><p>收藏： add to favorites, 快捷键: <code>alt shift F</code>，你可以先建立一个favorites列表(add new favorites lists)，然后在代码行处使用add to favorites。之后可以使用<code>alt 2</code>调用面板查看</p>
</li>
<li><p>跳到某个具体类 <code>Ctrl N</code></p>
</li>
<li><p>找文件：<code>Ctrl shift N</code></p>
</li>
<li><p>找单个字符：<code>Ctrl shift alt n</code>,可以在文件中寻找一个单词，字符等。</p>
</li>
<li><p>字符串搜索：Edit-&gt;Find-&gt;Find in Path: <code>ctrl shift F</code>,可以改建，我的改成了<code>ctrl shift Y</code></p>
</li>
<li><p>移动操作：<code>move caret XXXXX</code>，然后选择相应的选项</p>
</li>
<li><p>大小写：edit-&gt; toggle case ，<code>ctrl shift u</code></p>
</li>
<li><p>相同字符串多列操作：<code>select all occurences</code> –&gt; <code>ctrl shift alt j</code>，比如下图中将<code>=</code>号右边部分全部加上双引号<code>&quot;&quot;</code>，这种情况就可以尝试多列操作。</p>
</li>
</ol>
<p><img src="/images/qiniu/2018-04-04-09-56-31.png" alt="2018-04-04-09-56-31"></p>
<p>在上图中如果只是多列操作，那么后面中文的字符长度不一样，那么不能直接移动，所以可以使用第10条移动操作结合起来一起操作。简直神器。</p>
<ol start="13">
<li><p>不知道怎么操作时神奇键：show intention action，<code>alt enter</code></p>
</li>
<li><p>重构：<code>shift F6</code>,<code>ctrl shift alt t</code></p>
</li>
<li><p>重构方法，签名等：<code>ctrl F6</code></p>
</li>
<li><p>抽取变量，函数等，<code>refactor-&gt;Extract-&gt;xxx</code>；可以选局部变量，全局变量等。下面是选择的variable</p>
</li>
</ol>
<p><img src="/images/qiniu/2018-04-04-11-11-06.png" alt="2018-04-04-11-11-06"></p>
<p><img src="/images/qiniu/2018-04-04-11-11-41.png" alt="2018-04-04-11-11-41"></p>
<p><img src="/images/qiniu/2018-04-04-11-11-56.png" alt="2018-04-04-11-11-56"></p>
<ol start="17">
<li>代码最后一次提交人：annotate。</li>
<li>文件修改位置：previous change</li>
<li>版本撤销：revert</li>
<li>本地修改记录：show history</li>
<li>打本地标签：put label，类似 commit</li>
<li>在当前目录新建文件：<code>ctrl alt insert</code></li>
<li>文件复制：<code>F5</code></li>
<li>文件移动：<code>F6</code></li>
<li>复制文件全路径：<code>ctrl shift C</code></li>
<li>复制文件名：<code>ctrl shift alt C</code></li>
<li>选择复制的历史数据：<code>ctrl shift V</code></li>
<li>maven 依赖图，右键maven-&gt;show dependencies：<code>ctrl shift alt u</code></li>
<li>查看当前类的继承关系，hierarchy class ：<code>ctrl H</code></li>
<li>方法调用，call hierarchy，<code>ctrl alt H</code><h2 id="idea-神奇操作："><a href="#idea-神奇操作：" class="headerlink" title="idea 神奇操作："></a>idea 神奇操作：</h2></li>
</ol>
<h3 id="live-templates"><a href="#live-templates" class="headerlink" title="live templates"></a>live templates</h3><p>注意live templates 可以使用<code>$END$</code>作为最后结束时，光标的位置：</p>
<p><img src="/images/livetemplate.gif" alt="live tempaltes 实例操作"></p>
<h3 id="postfix"><a href="#postfix" class="headerlink" title="postfix"></a>postfix</h3><p>postfix 是idea预置的，无法增加，使用<code>ctrl shift a</code>输入“postfix”就能看到相应的预置postfix。</p>
<p>比如我们想生成下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(args != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//xxxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用postfix可能只需要输入:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">args.nn</span><br></pre></td></tr></table></figure>

<p>就能出现提示，生成上面的代码</p>
<p><img src="/images/postfix.gif" alt="postfix 实例操作"></p>
<h3 id="idea-debug-操作"><a href="#idea-debug-操作" class="headerlink" title="idea debug 操作"></a>idea debug 操作</h3><ol>
<li><p>断点： <code>toggle line breakpoint</code>：<code>ctrl F8</code>。</p>
</li>
<li><p>debug模式启动：<code>shift F9</code></p>
</li>
<li><p>单步运行：F8</p>
</li>
<li><p>结束当前断点：resume，F9</p>
</li>
<li><p>关停所有断点：<code>mute breakpoints</code></p>
</li>
<li><p>条件断点：<code>ctrl shift f8</code></p>
</li>
<li><p>表达式求值：<code>evaluate expression</code>：<code>alt F8</code></p>
</li>
<li><p>从断点跳到光标行：<code>run to cursor</code>：<code>alt f9</code></p>
</li>
<li><p>运行过程中改变值：<code>set value</code>，在Debug视图中选中需要改变的变量按<code>F2</code></p>
</li>
<li><p>在当前位置运行，适用与单元测试：<code>ctrl shift f9</code></p>
</li>
<li><p>从历史运行中寻找一个运行：<code>alt shift f9</code>–&gt;<code>Run--&gt;Debug...</code></p>
</li>
</ol>
<h2 id="idea-常用插件"><a href="#idea-常用插件" class="headerlink" title="idea 常用插件"></a>idea 常用插件</h2><p><code>key promoter</code>，<br><code>idea vim</code>：<code>:sp</code><br><code>lombok plugin</code>，<br><code>maven helper</code>，<br><code>sonar lint</code>，<br><code>alibaba java code guide</code><br><code>emacsidea</code>: 使用<code>ctrl + J</code> 然后再输入想查找的字符，就可以快速定位了，在keymap中修改acejumpworld。</p>
<h2 id="VScode-快捷键"><a href="#VScode-快捷键" class="headerlink" title="VScode 快捷键"></a>VScode 快捷键</h2><p><code>ctrl k</code> 之后按下 <code>v</code>，打开实时预览。</p>
]]></content>
      <categories>
        <category>All</category>
      </categories>
      <tags>
        <tag>All</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8中的日期时间</title>
    <url>/2017/11/29/java-8-date/</url>
    <content><![CDATA[<h2 id="Java8中的日期时间"><a href="#Java8中的日期时间" class="headerlink" title="Java8中的日期时间"></a>Java8中的日期时间</h2><p>最近尝鲜，之前了解过Java8的新日期API，但是一直没有真正的去尝试使用，这次有一个新的项目而且不是特别重要，所以就开始了自己的一次尝试。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>新的日期API是位于<code>java.time.*</code>包下。大致用到的类如下：</p>
<p><img src="/images/qiniu/2017-11-29-23-29-34.png" alt="2017-11-29-23-29-34"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZoneId: 时区ID，用来确定Instant和LocalDateTime互相转换的规则</span><br><span class="line">Instant: 用来表示时间线上的一个点</span><br><span class="line">LocalDate: 表示没有时区的日期, LocalDate是不可变并且线程安全的</span><br><span class="line">LocalTime: 表示没有时区的时间, LocalTime是不可变并且线程安全的</span><br><span class="line">LocalDateTime: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的</span><br><span class="line">Clock: 用于访问当前时刻、日期、时间，用到时区</span><br><span class="line">Duration: 用秒和纳秒表示时间的数量</span><br></pre></td></tr></table></figure>

<p>其中跟日期和时间相关的类为：<code>LocalDate</code>,<code>LocalDateTime</code>,<code>LocalTime</code>;<br>根据他们的名字也可以看出来<code>LocalDate</code>主要针对日期操作，<br><code>LocalDateTime</code>主要针对日期+时间进行操作，<br><code>LocalTime</code>主要为针对时间进行操作。<br>其实对于西方来说，有Date和Time区分的，分为日期类型和时钟类型。</p>
<p>另外跟日期和时间相关的就是时区了：<code>TimeZone</code>,<code>ZoneId</code>;8中内置了很多时区，可以根据需要选择。</p>
<p>另外一个就是<code>Instant</code>，这个指的时间线上的一个点，比如你看成坐标轴的横坐标。</p>
<span id="more"></span>
<h3 id="LocalDate-LocalDateTime-LocalTime"><a href="#LocalDate-LocalDateTime-LocalTime" class="headerlink" title="LocalDate,LocalDateTime,LocalTime"></a>LocalDate,LocalDateTime,LocalTime</h3><p>新的日期API核心三大块。<code>LocalDate</code>是指的:<code>yyyy-MM-dd</code>，这种类型的日期，比如：2017-11-21。所以你可以猜一下，如果是一个日期工具类，平常我们肯定要用到<code>LocalDate</code>，</p>
<ol>
<li>它作为工具类应该提供静态方法来获取一个对象所以有<code>LocalDate.now()</code>来获取一个LocalDate对象;</li>
<li>然后我们有日期了，要获取一个LocalDate对象，那么必须有解析的静态方法：<code>LocalDate.parse(string)</code>，</li>
<li>如果想要获取到某一个具体日期的LocalDate对象：<code>LocalDate.of(int year, Month month, int dayOfMonth)</code>;</li>
<li>以前的日期api不能很方便的操作日期，如果我们要加一天或者减一天都很麻烦，java8 既然是后来者，肯定要有优化所以有了：<code>plus()</code>和<code>minus()</code>;</li>
<li>加一年或者一个月呢？<code>plusYear()</code>,<code>plushMonth()</code>,<code>plusWeeks()</code>,<code>plushDays()</code>;</li>
</ol>
<p>有加必有减，所以就可以知道大部分api内容了。然后这三个API的内容基本一样。</p>
<p><strong>推荐使用LocalDateTime,因为它将日期和时钟都获取了，可以很方便你进行各种日期时间操作</strong></p>
<h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>时区这个操作就好说了，直接看代码，因为java提供了一个默认时区，它会根据当前运行时环境自动判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(ZoneId.systemDefault());<span class="comment">// 跟操作系统时区相关</span></span><br><span class="line"></span><br><span class="line">    ZoneId zoneId = ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>);<span class="comment">//CTT</span></span><br><span class="line">    System.out.println(zoneId);</span><br><span class="line"></span><br><span class="line">    TimeZone timeZone = TimeZone.getTimeZone(<span class="string">&quot;CTT&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(timeZone.toZoneId());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String id : TimeZone.getAvailableIDs()) &#123;</span><br><span class="line">        System.out.print(id + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n====================&quot;</span>);</span><br><span class="line">    TimeZone timeZone1 = TimeZone.getTimeZone(<span class="string">&quot;Asia/Samarkand&quot;</span>);</span><br><span class="line">    System.out.println(timeZone1.toZoneId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/qiniu/2017-11-29-22-58-54.png" alt="2017-11-29-22-58-54"></p>
<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p><code>Instant</code>，表示的是时间线上的一点，我个人认为主要就是将LocalDateTime和Date新旧API连接起来，他们之间可以如下装换：</p>
<p>LocalDateTime 转成 Date</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant instant = LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date date = Date.from(instant);</span><br></pre></td></tr></table></figure>

<p>Date 转成LocalDateTime</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.from(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(localDateTime);</span><br></pre></td></tr></table></figure>

<p>LocalDate 转成 Date</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date =</span><br><span class="line">            Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant</span><br></pre></td></tr></table></figure>

<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><p>字符串格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;默认格式化: &quot;</span> + now);</span><br><span class="line">System.out.println(<span class="string">&quot;自定义格式化: &quot;</span> + now.format(dateTimeFormatter));</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.parse(<span class="string">&quot;2017-08-20 15:26:12&quot;</span>, dateTimeFormatter);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串转LocalDateTime: &quot;</span> + localDateTime);</span><br></pre></td></tr></table></figure>
<h4 id="日期周期"><a href="#日期周期" class="headerlink" title="日期周期"></a>日期周期</h4><p>Period类用于修改给定日期或获得的两个日期之间的区别。</p>
<p>给初始化的日期添加5天:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate initialDate = LocalDate.parse(<span class="string">&quot;2017-07-20&quot;</span>);</span><br><span class="line">LocalDate finalDate = initialDate.plus(Period.ofDays(<span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;初始化日期: &quot;</span> + initialDate);</span><br><span class="line">System.out.println(<span class="string">&quot;加日期之后: &quot;</span> + finalDate);</span><br></pre></td></tr></table></figure>

<p>周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> between = ChronoUnit.DAYS.between(initialDate, finalDate);</span><br><span class="line">System.out.println(<span class="string">&quot;天数差: &quot;</span> + between);</span><br></pre></td></tr></table></figure>

<h4 id="是否润年"><a href="#是否润年" class="headerlink" title="是否润年"></a>是否润年</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> leapYear = LocalDate.now().isLeapYear();</span><br><span class="line">System.out.println(<span class="string">&quot;是否闰年: &quot;</span> + leapYear);</span><br></pre></td></tr></table></figure>

<h4 id="减去一个月"><a href="#减去一个月" class="headerlink" title="减去一个月"></a>减去一个月</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate prevMonth = LocalDate.now().minus(<span class="number">1</span>, ChronoUnit.MONTHS);</span><br></pre></td></tr></table></figure>

<h4 id="一周的第几天"><a href="#一周的第几天" class="headerlink" title="一周的第几天"></a>一周的第几天</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();</span><br><span class="line">System.out.println(<span class="string">&quot;周几: &quot;</span> + dayOfWeek);</span><br><span class="line"><span class="keyword">int</span> dayOfMonth = LocalDate.now().getDayOfMonth();</span><br><span class="line">System.out.println(<span class="string">&quot;第几天？: &quot;</span> + dayOfMonth);</span><br></pre></td></tr></table></figure>

<h4 id="获取这个月第一天"><a href="#获取这个月第一天" class="headerlink" title="获取这个月第一天"></a>获取这个月第一天</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate firstDayOfMonth = LocalDate.now()</span><br><span class="line">                .with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;这个月的第一天: &quot;</span> + firstDayOfMonth);</span><br><span class="line">firstDayOfMonth = firstDayOfMonth.withDayOfMonth(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;这个月的第一天: &quot;</span> + firstDayOfMonth);</span><br></pre></td></tr></table></figure>

<h4 id="判断是否是我的生日"><a href="#判断是否是我的生日" class="headerlink" title="判断是否是我的生日"></a>判断是否是我的生日</h4><p>判断今天是否是我的生日，例如我的生日是 1995-03-19</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate birthday = LocalDate.of(<span class="number">1995</span>, <span class="number">03</span>, <span class="number">19</span>);</span><br><span class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</span><br><span class="line">MonthDay today = MonthDay.from(LocalDate.now());</span><br><span class="line">System.out.println(<span class="string">&quot;今天是否是我的生日: &quot;</span> + today.equals(birthdayMd));</span><br></pre></td></tr></table></figure>

<h4 id="判断是否之前，之后"><a href="#判断是否之前，之后" class="headerlink" title="判断是否之前，之后"></a>判断是否之前，之后</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> notBefore = LocalDate.parse(<span class="string">&quot;2017-07-20&quot;</span>)</span><br><span class="line">                    .isBefore(LocalDate.parse(<span class="string">&quot;2017-07-22&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;notBefore: &quot;</span> + notBefore);</span><br><span class="line"><span class="keyword">boolean</span> isAfter = LocalDate.parse(<span class="string">&quot;2017-07-20&quot;</span>).isAfter(LocalDate.parse(<span class="string">&quot;2017-07-22&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;isAfter: &quot;</span> + isAfter);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 函数式编程-前言</title>
    <url>/2017/11/21/java-8-functional-programming/</url>
    <content><![CDATA[<h2 id="Java-8-函数式编程-前言"><a href="#Java-8-函数式编程-前言" class="headerlink" title="Java 8 函数式编程-前言"></a>Java 8 函数式编程-前言</h2><blockquote>
<p>从 Java 8 发布到现在已经过去很久了，现在 Java 9 也都已经发布了。国人的习惯总是你发布 8 的时候，我用 7 。你发布 9 的时候，我想 Java 8 应该是普及的时候了。那么正当时，还不来普及下 Java 8 的一个大特性，那就有点说不过去了。</p>
</blockquote>
<hr>
<hr>
<h3 id="引言-什么是函数式编程"><a href="#引言-什么是函数式编程" class="headerlink" title="引言 - 什么是函数式编程"></a>引言 - 什么是函数式编程</h3><p>函数式编程（Funtional Programming，以下简称 fp ），我想从 Java 8 发布之后大家对这个名词都不陌生，它有很多好处，减少代码，增加可读性等等。但是什么是函数式编程了？它和我们普通的 OOP 又有什么不同？</p>
<p>先来看一份常规打招呼的代码，在 Java7 之前我们大多是这么玩的：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 打招呼</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">greetJdk7</span><span class="params">(List&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">       String greeting = <span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">       <span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">           greeting += name + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       greeting += <span class="string">&quot;!&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span> greeting;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Java8 之后如果用函数式编程的方式改写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">greetJdk8</span><span class="params">(List&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">    String greeting = names</span><br><span class="line">            .stream()</span><br><span class="line">            .map(name -&gt; name + <span class="string">&quot;,&quot;</span>)</span><br><span class="line">            .reduce(<span class="string">&quot;Hello &quot;</span>,</span><br><span class="line">                    (hello, name) -&gt; hello + name);</span><br><span class="line">    <span class="keyword">return</span> greeting + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者对比起来我们会发现，干净利落，但是看不懂，没关系，之后我会告诉你上面用 Java8 写的代码的含义，并且你也能自己写 Functinal Program。 </p>
<p>在开始之前，我想提前和你分享一些知识：</p>
<ol>
<li>在fp中使用的<strong>所有变量</strong>都是<code>final</code>的，final的含义意味着，在fp中你不能对它进行改变，总之<code>final</code>的使用，我想你是知道的。</li>
</ol>
<p>非法实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; aList =<span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">aList.forEach(obj-&gt;&#123;</span><br><span class="line">     str=<span class="string">&quot;bbb&quot;</span>;<span class="comment">// 这样是不允许的，因为str在这里相当于final</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用局部参数代替全局变量,比如说：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Time time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time.getTime().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currTime</span><span class="params">(Time time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fixedTime.now().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将方法作为参数使用：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addOne</span><span class="params">(List&lt;Integer&gt; numbers)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; plusOne = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Integer number : numbers) &#123;</span><br><span class="line">        plusOne.add(number + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plusOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addOne</span><span class="params">(List&lt;Integer&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers</span><br><span class="line">            .stream()</span><br><span class="line">            .map(number -&gt; number + <span class="number">1</span>)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--
### 函数对象

Java 8 中，函数成为了“第一等公民”，这就意味着，我们可以将函数作为其他函数(俗称方法)的参数，或者将函数作为返回参数，或者像对象一样定义一个函数来使用。

未完待续
-->
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-Java -Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础数据类型</title>
    <url>/2017/03/21/java-basic-type/</url>
    <content><![CDATA[<h2 id="Java-基础数据类型"><a href="#Java-基础数据类型" class="headerlink" title="Java 基础数据类型"></a>Java 基础数据类型</h2><blockquote>
<p>Java 拥有着八大基本数据类型：byte,short,int,long,float,double,boolean,char</p>
</blockquote>
<h3 id="byte-Byte"><a href="#byte-Byte" class="headerlink" title="byte,Byte"></a>byte,Byte</h3><p>了解byte之前我们先了解一下 “字节，位”。字节的单位是Byte，位的单位是bit。一个字节(Byte)=8个位(bit)。<br>在Java里面byte数据类型占用8位，它是带符号位的，怎么明白符号位的意思？一个位代表一个1或者一个0。8位带符号的意思是第一个位表明为符号位，如：0111111，符号位为0代表+，即最大值为127；如果是 11111111,最小值为-128。byte的包装类型为Byte,初始值为0。</p>
<span id="more"></span>
<h3 id="short-Short"><a href="#short-Short" class="headerlink" title="short,Short"></a>short,Short</h3><p>short 在Java里面占用16位，也是带符号位的。最小值为-32768最大值为32767。short的包装类为Short，初始值为0。</p>
<h3 id="int-Integer"><a href="#int-Integer" class="headerlink" title="int,Integer"></a>int,Integer</h3><p>默认情况下占用32位带符号位。从$-2^(31)$-$2^(31)-1$。在官网下得知，在Java8以及之后的版本中，也支持无符号32位int类型，数值从$0$-$2^(32)-1$。int的包装类型为Integer，初始值为0。</p>
<h3 id="long-Long"><a href="#long-Long" class="headerlink" title="long,Long"></a>long,Long</h3><p>长整形数据类型占用64位带符号位。从$-2^(63)$-$2^(63)-1$。使用长整形的主要原因是在int不满足需求的情况下使用。定义long类型的值时在数字后加L: long aLong = 1234L。Java8之后，长整形也支持无符号位64位，$0$-$2^(64)-1$。长整形的包装类型为Long，初始值为0L。</p>
<h3 id="float-Float"><a href="#float-Float" class="headerlink" title="float,Float"></a>float,Float</h3><p>float是单精度32位浮点数，值得范围还有待讨论<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3">Floating-Point Types, Formats, and Values</a>，需要注意，浮点数不是精确的值，所以在有需要精确控制的地方一定要注意(货币，价钱方面)，可以使用BigDecimal来代替浮点数运算。定义float的时候一定要加f，不然系统会默认为double。比如 float aFloat = 0.1f。flocat的包装类型为Float，初始值为0.0f。</p>
<h3 id="double-Double"><a href="#double-Double" class="headerlink" title="double,Double"></a>double,Double</h3><p>double是双精度64位浮点数，遵从IEEE754。double也不是精确的，所以和float需要注意点基本类似。double的包装类型为Double，初始值为0.0d。</p>
<h3 id="boolean-Boolean"><a href="#boolean-Boolean" class="headerlink" title="boolean,Boolean"></a>boolean,Boolean</h3><p>boolean数据类型仅仅有两个可能值，true，false。它在某些情况下占用一位，但是它的占用大小是一个不确定的。boolean的包装类型为Boolean，初始值为false。</p>
<h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p>char 的数据类型是一个16位的Unicode字符类型，最小值\u0000(0)-最大值\uffff(65535)，初始值为\u0000</p>
<blockquote>
<p>可以总结一下，基本数据类型的包装类型都是首先字母大写，包装类型的主要作用是面向对象，增加更多的可操作性。基本数据类型作形参的时候是值传递，不会改变原来的值。特别注意String不是基本数据类型，只是String的对象都存储在静态区，是一个不可变对象,String 默认值为“null”。<br>void 和 Void 也需要注意，在博客上有人把他们归类为第九大数据类型，但是官网却没有说明。参考<a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive Data Types</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 大数据中的敏感词汇处理</title>
    <url>/2019/03/31/java-big-data-sensitive-word/</url>
    <content><![CDATA[<h1 id="Java-大数据中的敏感词汇处理"><a href="#Java-大数据中的敏感词汇处理" class="headerlink" title="Java 大数据中的敏感词汇处理"></a>Java 大数据中的敏感词汇处理</h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>byte 在golang和Java中的区别</title>
    <url>/2019/03/31/java-byte-golang-byte/</url>
    <content><![CDATA[<h1 id="byte-在golang和Java中的区别"><a href="#byte-在golang和Java中的区别" class="headerlink" title="byte 在golang和Java中的区别"></a>byte 在golang和Java中的区别</h1><p>最近做一个项目，想用到md5，做一次数据的校验。因为是两个系统，一个golang开发，一个java开发。首先用Java生成md5值，然后传给golang，发现原始数据一致，但是生成的md5值却不一致。</p>
<p>深究其原因，最终发现是golang和java中对于byte的定义一个是无符号的，一个是有符号的，所以两者最后生成的md5值不一致。现在我发现有的时候真的需要注意到一些比较基础的东西，不然就会成为面向api的工程师。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>byte</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列和堆排序</title>
    <url>/2018/03/21/java-datastructure-priority-queue-heap/</url>
    <content><![CDATA[<h1 id="优先队列和堆排序"><a href="#优先队列和堆排序" class="headerlink" title="优先队列和堆排序"></a>优先队列和堆排序</h1><p>很多情况下，我们会对某个任务做优先级，比如手机系统应用肯定要比第三方应用要优先级要高。实现这种方式的数据结构需要满足：一个最优先的任务（最大或最小值），加入新任务（新元素）；这种数据结构可以用<strong>优先队列</strong>。</p>
<p>优先队列是一种抽象数据类型，表示一组值和对这些值的操作。优先队列最重要的操作就是删除最大元素和插入元素。优先队列里面需要有哪些接口?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MaxPQ()</span><br></pre></td></tr></table></figure>

<p>未完待续…</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-命令模式</title>
    <url>/2017/10/04/java-design-pattern-command/</url>
    <content><![CDATA[<h2 id="设计模式-命令模式"><a href="#设计模式-命令模式" class="headerlink" title="设计模式-命令模式"></a>设计模式-命令模式</h2><p>命令模式是啥啊?感觉从字面上来理解,就是命令-执行.那么谁下命令?谁执行?执行的人从哪里知道命令?又怎么知道要执行哪些命令?<br><strong>命令模式的定义: 将’请求’封装成对象,以便使用不同的请求,队列或者日志来参数化其它对象.命令模式也支持可撤销的操作</strong></p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>让我们假设一件事情,如果有个遥控器,上面有个按钮,按钮可以控制家里的一件东西,比如说开关门,开关灯,开关电视.那么我们该怎么做了?<br>其实这个就相当于一个命令模式了.人是下命令的.也就是按钮执行就是一个命令,按钮对应了什么操作,按下的操作,这个操作怎么执行了?是门执行,还是灯去执行,还是电视了?<br>如果可以,我们可以想想另外一个例子:下馆子.通常我们去到餐馆,服务员给个菜单,然后我们写上我们要吃的菜;完事之后服务员拿走菜单,然后告诉厨师,厨师拿到菜单后开始炒菜.<br>这个过程中,”我们”就相当于一个客户端,我们将菜品(请求)封装成了一个订单对象.服务员拿到请求,告诉厨师请求来了,厨师拿到订单看到里面的菜品(命令)就开始执行.</p>
<span id="more"></span>
<p>命令模式过程图:<br><img src="/images/qiniu/2017-10-04-16-21-22.png" alt="2017-10-04-16-21-22"></p>
<p>类关系图<br><img src="/images/qiniu/2017-10-04-20-47-21.png" alt="2017-10-04-20-47-21"></p>
<p>这个过程如果想清楚了,回到我们为遥控器编程,现在我们拿到的就是一个空遥控器,要控制那个东西也不明白,所以让我们尝试编程看.</p>
<h3 id="命令编程"><a href="#命令编程" class="headerlink" title="命令编程"></a>命令编程</h3><p>我们从简单的开始,必不可少的是命令的执行者,我们假设这次我们控制的是灯泡,<code>Light.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令执行者,命令执行对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;light is on...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们想要让它执行命令,想想看在订餐的时候,菜单是不是都是一样的? 所以我们先定义一个命令标记接口<code>Command.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 命令接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 命令接口具体执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后灯的开关,是不是执行一个命令,我们先只管”灯开”这一个命令(暂时不管灯关),这个命令肯定是继承命令标记接口的,因为我们肯定是要先统一了菜谱,然后再让客户去点菜的.所以我们的灯开命令<code>LightOnCommand.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 灯开的命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 命令执行者</span></span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//命令执行方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置命令执行者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> light</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令对象也有了,我们现在来让遥控器适配上,我们建立一个简单遥控器类<code>SimpleRemoteControl.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遥控器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRemoteControl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 命令执行</span></span><br><span class="line">    Command slot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRemoteControl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置按钮命令,以后也可以绑定灯的开关,或者门的开关.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSlot</span><span class="params">(Command slot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.slot = slot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遥控器按钮按下去</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buttonWasPressed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        slot.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些做完之后,我们看看,遥控器里面我们组合的是一个命令,而命令又统一继承自一个接口,然后各个命令的实现里面又各个命令执行者的组合实例.这样来看,我们按下遥控器,遥控器就会执行命令,命令会知道是那个执行者去执行.现在编写测试类<code>RemoteControlTest.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControlTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遥控器</span></span><br><span class="line">        SimpleRemoteControl remote = <span class="keyword">new</span> SimpleRemoteControl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//电灯</span></span><br><span class="line">        Light light = <span class="keyword">new</span> Light();</span><br><span class="line">        LightOnCommand lightOnCommand = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//命令设置</span></span><br><span class="line">        remote.setSlot(lightOnCommand);</span><br><span class="line">        <span class="comment">//命令执行</span></span><br><span class="line">        remote.buttonWasPressed();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样,我们对遥控器编程算是完成了.如果我们想控制门,或者控制电视,那我们该怎么弄?其实就模仿灯的方式就行了.在这个实例里面,我们可以看到,遥控器其实是不知道具体是让灯开,还是让门开的,就是遥控器的按钮命令是可以任意的,这个应该算是解耦了把.遥控器只知道命令只要实现了<code>Command</code>的接口就可以了.</p>
<p>命令模式感觉这样确实非常清晰的,代码的demo版本理解和实现也不困难,但是不知道在实际开发中,怎么去用它,将它用在些设呢么地方.我在电商系统中的购物车下单是否可以这样使用了? 但是貌似也就一个地方用到了下单,那么我直接实现是否会比使用设计模式会更好了? 现在我感觉我的问题是,不知道怎么去扩展,没地方扩展,自然就会觉得简单直接的方式最好,也就无需去考虑适设计模式.但是设计模式应该在什么地方,什么时候去使用了?真是路,从来就没有一条好走的路.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-装饰者模式</title>
    <url>/2017/09/19/java-design-pattern-decorate/</url>
    <content><![CDATA[<h2 id="设计模式-装饰者模式"><a href="#设计模式-装饰者模式" class="headerlink" title="设计模式-装饰者模式"></a>设计模式-装饰者模式</h2><blockquote>
<p>组合比继承更具有灵活性</p>
</blockquote>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>装饰者模式其实一开始我没想明白，怎么给装饰法？就像当初看Java IO包，始终也没明白怎么这么多类啊。很多人都说它是什么什么装饰者设计模式，那个时候也不怎么懂，就走马观花般过了就过了。<br>最近重新回到基础，又买了本设计模式的书，其实真的不想看，但是看了一两章发现，我靠，这不就是我之前的搞法么？猛回首，发现自己踩过的坑人家也踩过，而我还在踩。当然能力也有限，记下此博客，一，如果有人能看到这里有点了解，那是甚好；二，如果以后自己忘记了，也有个标记，让我返回至此，然后来个回忆。</p>
<p>回到正途，装饰者，啥事装饰者？看看平常我们说装饰房屋，那么是不是先有个房子，然后再给房子搞下装饰，刷墙啊，放书架啊，这就是一个装饰。那么装饰者模式怎么回事了？<em>动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的扩展方案。</em> 装饰者模式的最大特点是在装饰类里面进行了组合，组合的威力发挥到最大。当然这种组合也必须要有一个约束，那么就是必须在同一类中，总不能指驴为马吧。所以装饰的是一类或者一组类似的对象。</p>
<h3 id="自我的理解"><a href="#自我的理解" class="headerlink" title="自我的理解"></a>自我的理解</h3><p>有时候光想真的会发现自己很多地方好像已经明白了，但是实际上，当我们写代码的时候会发现，要注意点细节真的很多。</p>
<span id="more"></span>
<p>装饰者模式中，其实讲究的是子类对父类的继承扩展，以及子类对于父类子集同类的组合。理解起来其实就是，我可以用我爸爸的人脉帮我办事，也可以用我哥哥的人脉办事，最终我做事可能就不需要太多的人脉了。这种方式很好的解耦了，而且对于扩展的话，我可以随便改，而对于我老爸，老哥，我却没有改的可能。这就是设计模式的一个设计原则：开放封闭原则，类对扩展开放，对修改关闭。</p>
<p><img src="/images/qiniu/2017-09-19-10-01-02.png" alt="装饰者模式类图"></p>
<p>我们来实际敲敲代码，假设我们要开咖啡店，咖啡店有多种原料，根据不同的原料组成不同的咖啡，拥有不同的售价。</p>
<p><img src="/images/qiniu/2017-09-19-10-02-16.png" alt="装饰者实际类图"></p>
<p>首先我们建立基础类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun.coffee.type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡的基类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    String description = <span class="string">&quot;unknown beverage&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后在咖啡基础类上建立具体的咖啡：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun.coffee.type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 焦炒咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkRoast</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DarkRoast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        description = <span class="string">&quot;DarkRoast...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun.coffee.type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浓缩咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span></span>&#123;</span><br><span class="line">        description = <span class="string">&quot;espresso...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun.coffee.type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优选咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBlend</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseBlend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        description = <span class="string">&quot;houseblend...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到上面的三个咖啡都是继承自抽象类Beverage，形成<code>同类</code>；</p>
<p>接下来我们建立装饰者的基类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun.coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> me.chenzhijun.coffee.type.Beverage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到装饰者类也是继承Beverage，并且也同样是抽象类，唯一的抽象方法就是要实现getDescription();</p>
<p>之后我们在装饰者类的基础上增加几个具体的装饰者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun.coffee;</span><br><span class="line"><span class="keyword">import</span> me.chenzhijun.coffee.type.Beverage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 摩卡咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription()+<span class="string">&quot; mocha...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost()+<span class="number">3.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun.coffee;</span><br><span class="line"><span class="keyword">import</span> me.chenzhijun.coffee.type.Beverage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大豆奶咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soy</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot; soy...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun.coffee;</span><br><span class="line"><span class="keyword">import</span> me.chenzhijun.coffee.type.Beverage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加奶泡的咖啡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Whip</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot; whip...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">2.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在我们队咖啡加了一些装饰：摩卡，大豆，奶泡，这些都是装饰者类，而且装饰者类里面都有一个<code>Beverage</code>,这就方便我们组合其他的同族的类的功能。</p>
<p>最后来看先卖咖啡：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> me.chenzhijun.coffee.type.Beverage;</span><br><span class="line"><span class="keyword">import</span> me.chenzhijun.coffee.type.DarkRoast;</span><br><span class="line"><span class="keyword">import</span> me.chenzhijun.coffee.type.Espresso;</span><br><span class="line"><span class="keyword">import</span> me.chenzhijun.coffee.type.HouseBlend;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Starbucks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Beverage beverage = <span class="keyword">new</span> Espresso();<span class="comment">//浓缩咖啡已经是成品了</span></span><br><span class="line"></span><br><span class="line">        System.out.println(beverage.getDescription() + <span class="string">&quot;, &quot;</span> + beverage.cost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双份摩卡加奶泡</span></span><br><span class="line">        Beverage beverage2 = <span class="keyword">new</span> DarkRoast();</span><br><span class="line">        beverage2 = <span class="keyword">new</span> Mocha(beverage2);</span><br><span class="line">        beverage2 = <span class="keyword">new</span> Mocha(beverage2);<span class="comment">//多一份摩卡</span></span><br><span class="line">        beverage2 = <span class="keyword">new</span> Whip(beverage2);</span><br><span class="line">        System.out.println(beverage2.getDescription() + <span class="string">&quot;, &quot;</span> + beverage2.cost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大豆+摩卡+奶泡</span></span><br><span class="line">        Beverage beverage3 = <span class="keyword">new</span> HouseBlend();</span><br><span class="line">        beverage3 = <span class="keyword">new</span> Soy(beverage3);<span class="comment">//</span></span><br><span class="line">        beverage3 = <span class="keyword">new</span> Mocha(beverage3);</span><br><span class="line">        beverage3 = <span class="keyword">new</span> Whip(beverage3);</span><br><span class="line"></span><br><span class="line">        System.out.println(beverage3.getDescription() + <span class="string">&quot;, &quot;</span> + beverage3.cost());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以看到如果我们单纯的采用继承，那么将会继承自多个类，而且很笨重，而组合的方式很灵活；</p>
<p><img src="/images/qiniu/2017-09-19-14-03-12.png" alt="功能主要调用图"></p>
<p>装饰者模式中，jdk中用的最多的可能就是IO包了。基本上所有的IO类都继承至四大主类:<code>Reader/Writer;InputStream/OutputStream</code>。</p>
<p>其实我们只要理解了一个其它的就是可以类比了。 </p>
<blockquote>
<p>Reader/Writer 是在Stream之后引进的，因为对字符的操作比较多，所以引进了新的字符输入输出。jdk1.7之后都实现了AutoCloseable接口,try-with-resources语法来实现自动关闭流。</p>
</blockquote>
<p>我们仅仅来看下InputStream类，所有的输入流都可以算作是InputStream的子类，在InputStream中定义了几个方法，查看子类中有个FilterInputStream类，而且大多数的类都继承自FilterInputStream而不是InputStream，仔细的看下FilterInputStream类中的方法，可以发现FilterInputStream中有一个InputStream的属性，而所有的方法都是用的是这个属性的方法，FilterInputStream就是一个装饰类，查看它的一个子类DataInputStream，可以发现DataInputStream中只有一个构造方法为DataInputStream(InputStream);FilterInputStream类的说明中，也指到它的作用就是包含一个其它的InputStream族类，然后使用它们的增加的方法来为己用。</p>
<p>类比下装饰者模式，FilterInputStream可以说就是一个装饰者，我们要用哪个InputStream的时候也是将InputStream层层包括装饰进去。如果这样来看JavaIO流其实也就并没有那么复杂了。当然因为装饰者模式的特点，我们可以看到生产了很多的小类，是的IO包的类异常的多。</p>
<p>参考文档：<br>Head First 设计模式 第三章装饰者模式</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-工厂模式</title>
    <url>/2017/10/04/java-design-pattern-factory/</url>
    <content><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>最近看了很久的工产模式，一直没敢下笔。因为我发现我就算弄了很久也就明白了简单工厂和工厂模式，抽象工厂一直没有弄的太明白。今天想着不如试试看，至少先把自己会的记录下来吧，不然越久越容易忘记了。</p>
<p><strong>工厂模式定义:定义了一个创建对象的接口,但由子类决定实例化的具体对象是哪个.工厂方法让类把实例化推迟到了子类中.</strong></p>
<h3 id="工厂简述"><a href="#工厂简述" class="headerlink" title="工厂简述"></a>工厂简述</h3><p>想想一个例子，假如我们想吃批萨，那么如果是简单的话，我们可能就买个面粉自己揉几下然后放到烤箱里面。只要出来的时候是个饼的形状，也就差不多了（对我这种不调食的人来说…）。但是我们可能还有一些有追求的人，他可能想吃海鲜批萨，可能想吃芝士批萨，可能想吃原味批萨。这么多要求，你觉得在家里自己做麻烦么？麻烦怎么办？丢个别人呗。那么我们就建个工厂，专门给我们做批萨，而我想吃什么批萨的时候，打个电话过去，告诉它给我做个什么口味的批萨，然后它把吃的给我送过来就好了。这种方式就基本上就是一个工厂模式了。<br>很显然，我们将”做批萨解耦出来了。工厂负责做批萨，而我只要批萨就行，至于你批萨是怎么做的，你工厂随便弄，最后给个批萨给我，就行。</p>
<span id="more"></span>

<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>其实简单工厂是工厂模式的一种特例，严格来说它就是工厂模式。我们先来看看有哪些东西我们要在实例中用的：批萨，吃批萨的人或者说需要批萨的客户端，生成批萨的工厂。</p>
<p>产品批萨，如果各个地方不同，可以实现该类。<code>Pizza.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String pizzaName;</span><br><span class="line">    <span class="keyword">private</span> String cheese;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCheese</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cheese;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setCheese</span><span class="params">(String cheese)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cheese = cheese;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPizzaName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pizzaName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPizzaName</span><span class="params">(String pizzaName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pizzaName = pizzaName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pizza</span><span class="params">(String pizzaName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pizzaName = pizzaName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;prepare...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bake...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;box...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单批萨工厂，<code>SimplePizzaFactory.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String pizzaType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pizzaType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123; <span class="comment">// 芝士批萨</span></span><br><span class="line">            pizza = <span class="keyword">new</span> Pizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pizzaType.equals(<span class="string">&quot;chicken&quot;</span>)) &#123;<span class="comment">//鸡肉批萨</span></span><br><span class="line">            pizza = <span class="keyword">new</span> Pizza(<span class="string">&quot;chicken&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要批萨的人，我们将它看成批萨店好了:<code>PizzaStore.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePizzaFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span><span class="params">(SimplePizzaFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String pizzaType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Pizza pizza = factory.createPizza(pizzaType);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在如果有人加盟店，继承自PizzaStore，然后传入他们的工厂就行了。比如说我想在深圳开一个深圳批萨，然后深圳本地有个当地的批萨工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShenZhenPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SimplePizzaFactory simplePizzaFactory = <span class="keyword">new</span> ShenzhenPizzaFactory();</span><br><span class="line">        PizzaStore pizzaStore = <span class="keyword">new</span> PizzaStore(simplePizzaFactory);</span><br><span class="line">        pizzaSore.orderPizza(<span class="string">&quot;chicken&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样任何在深圳地方的人想吃批萨只要在批萨店调用<code>orderPizza</code>方法就行了。</p>
<p>不过想想看，如果有一天我们有个长沙批萨店，他们要特殊化，主打高端人士批萨，这种时候他可能就希望是自己来决定是自己来生产批萨还是找长沙的批萨工厂。这种时候怎么办了？我们将代码做些改进，既然不管那个加盟店都必须要继承自<code>PizzaSore</code>,那我们将PizzaStore做一些改动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String pizzaType)</span></span>&#123;</span><br><span class="line">        Pizza pizza = createPizza(pizzaType);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String pizzaType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Pizza</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String pizzaName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPizzaName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pizzaName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPizzaName</span><span class="params">(String pizzaName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pizzaName = pizzaName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;prepare...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bake...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;box...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangShaPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChangShaPizza</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="string">&quot;ChangSha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后长沙的pizza店：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangShaPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Pizza <span class="title">createPizza</span><span class="params">(String pizzaType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pizzaType.equals(<span class="string">&quot;ChangSha&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChangShaPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将它定义为虚拟抽象类，并且增加抽象方法。这样每一个继承它的子类都必须自己实现一次<code>createPizza</code>方法，这样子类的实现，父类就完全不管了，只要定个统一接口就好了。</p>
<p>该总结一下啦，修改后我们的类主要是：PizzaStore,Pizza。我们将他们分下类：创建者类和产品类。</p>
<p><code>PizzaStore</code> ：可以相当于创建者(Creator)类，它是一个抽象方法，定义了一个抽象工厂方法，让子类实现该方法来制造产品。创建者里面也会有抽象的产品(这里相当于pizza，因为你也可以继承pizza然后实现自己的独特pizza)的依赖，不过创建具体哪种产品交由子类实现。我们在<code>ChangShaPizzaStore</code>里面就是实现了具体的产品。</p>
<p><code>Pizza</code> ： 相当于抽象产品类，其实我们也可以实现我们自己的Pizza，然后给它加点形状，特色啥的。这是个相当于工厂生产的产品抽象.如下图所示:<br><img src="2017-10-04-14-51-34.png" alt="2017-10-04-14-51-34"></p>
<p>其中Creator就相当于我们的PizzaStore所有的加盟店必须继承它,并且实现创建pizza的方法,而ConcreteCreator是唯一知道应该创建那个一个具体产品的(ChangShaPizza),所有的产品都实现一个产品接口Product.</p>
<p>可以看到如果加盟店越多,可能pizza的具体种类也就越多,而我们的PizzaStore只依赖于Pizza这个顶级产品类,而具体是ChangShaPizza还是BeijingPizza它就不需要管那么多了.这里有个原则可以引出来:<strong>依赖倒置原则:要依赖抽象,而不依赖具体实现类</strong>.</p>
<h3 id="抽象工产模式"><a href="#抽象工产模式" class="headerlink" title="抽象工产模式"></a>抽象工产模式</h3><p><strong>抽象工厂模式:提供一个接口,用于创建相关或依赖对象的家族,而不需要明确指定具体类.</strong></p>
<p><img src="/images/qiniu/2017-10-04-15-40-38.png" alt="2017-10-04-15-40-38"></p>
<p>可以看到,我们将工厂创建批萨的工厂也用一个工产接口来实现,而我们的新的store只依赖于工厂接口而不再是任何一个具体工厂接口.</p>
<p>如何理解了? 比如工厂模式中,我们生产pizza是基于子类的具体实现的,子类里面去进行具体的pizza封装,然后进行实例化,而抽象工产,它是不会去创建具体实例对象的,它的职责是创建相关或依赖对象的家族,它的每一个接口都是创建的一个单独的对象.比如Pizza,它会去创建做一个pizza需要的各种原料,各个原料其实都是一个单独的对象个体,它称为一个原料工厂.原料工厂是一个接口,然后各个实现了该接口的具体类去具体实现每种原来如何创建.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeijingPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    PizzaIngredientFactory pizzaIngredientFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeijingPizza</span><span class="params">(PizzaIngredientFactory pizzaIngredientFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pizzaIngredientFactory = pizzaIngredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cheese =  pizzaIngredientFactory.createCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>工厂模式和抽象工厂模式,他们之前一个是用的继承方式(工厂模式),一个是用的组合(抽象工厂).</p>
<p>抽象工厂: 如果需要创建产品家族和想让制造的想关产品集合起来的时候可以用抽象工厂.</p>
<p>工厂模式: 把客户端代码从需要实例化的具体类中解耦.</p>
<p>总之工厂就是将对象的创建封装了起来,更加的松耦合,做到弹性的设计.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-观察者模式</title>
    <url>/2017/09/14/java-design-pattern-observer/</url>
    <content><![CDATA[<h2 id="设计模式-观察者模式"><a href="#设计模式-观察者模式" class="headerlink" title="设计模式-观察者模式"></a>设计模式-观察者模式</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>观察者模式的有点类似现在的手机消息推送，比如你注册了一个APP，然后app有了更新一定会通知你，不然你看看手机里面的推送栏是不是每天淘宝都会推送给你一条消息。哈哈。当然为什么它知道要给你推送，不给哪些非智能机推送了？简单的更类似与现在报纸-订阅。只要你订了报纸，那么每天报纸更新都会把报纸给你送过来。所以我认为观察者模式应该也叫”订阅模式”，因为必须客户端先去注册（订阅）然后才能收到注册中心的更新或者通知。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>我们先来想想观察者模式中有哪些主体： </p>
<ol>
<li>注册中心（主题（或者叫被观察对象））</li>
<li>客户端 (观察者)</li>
</ol>
<p>现在我们分析下里面的行为：</p>
<p>报社（注册中心-主题）怎么知道有哪些人订了报纸（客户注册）了？那么就是报社必须要有一个记录有哪些人（客户端-观察者）在报社注册的’花名册’；那么现在是法治社会，当然不能强迫去订报纸吧，所以人们订报纸都是自愿的，那么自愿就必须自己去报社订阅(主动注册)。订了报纸之后，不能收不到报纸吧？那报社现在都是比较强势的，一般把报纸送到门口，所以你必须有一个接受的地址，这种算是约定；既然可以订阅，那么当然也有取消订阅（取消注册）；那么报社也就在’花名册’把你的名字去掉就可以了。</p>
<p>整个实现过程就是这样，观察者模式并不复杂，主要是报社(注册中心-主题)，花名册(订阅者名单)，订阅者（接受通知者），订阅(行为)，门(注册中心通知接受者的地址)。</p>
<span id="more"></span>
<p>开始写我们的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsPaperSubject</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> List observers;<span class="comment">//花名册</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> String newsPaper; <span class="comment">//新闻内容</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">             observers.add(observer);<span class="comment">//注册一个观察者、增加一个订阅客户</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unRegister</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">         observers.remove(observer);<span class="comment">//取消订阅</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNewsPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(Observer obj:observers)&#123;</span><br><span class="line">             obj.updateNewsPageOnDoor(newsPaper); <span class="comment">// 告知订阅者，新闻有更新</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNews</span><span class="params">(String news)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.newsPaper = news;  <span class="comment">// 设置新闻</span></span><br><span class="line">         sendNewsPage();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NewsPaperSubject newsPaperSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateNewsPageOnDoor</span><span class="params">(String news)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新news....&quot;</span>+news);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observer</span><span class="params">(NewsPaperSubject newsPaperSubject)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.newsPaperSubject = newsPaperSubject;</span><br><span class="line">         <span class="keyword">this</span>.newsPaperSubject.register(<span class="keyword">this</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面两个类我想你能基本了解订阅者模式是怎样一回事了。不过我们写的代码还是有点问题，耦合太严重，我们不应该针对具体实现编程，所以我们进行一次改版：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">//主题超类</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsPaperSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> List observers;<span class="comment">//花名册</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> String newsPaper; <span class="comment">//新闻内容</span></span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">             observers.add(observer);<span class="comment">//注册一个观察者、增加一个订阅客户</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">         observers.remove(observer);<span class="comment">//取消订阅</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(Observer obj:observers)&#123;</span><br><span class="line">             obj.update(newsPaper); <span class="comment">// 告知订阅者，新闻有更新</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNews</span><span class="params">(String news)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.newsPaper = news;  <span class="comment">// 设置新闻</span></span><br><span class="line">         notifyObservers();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String newsPaper)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 具体观察者</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentObserver</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Subject newsPaperSubject;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">StudentObserver</span><span class="params">(Subject newsPaperSubject)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.newsPaperSubject = newsPaperSubject;</span><br><span class="line">         newsPaperSubject.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String news)</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;updateNews..&quot;</span>+news);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新版本的情况如果我们有了个政府观察者，我们只需要实现一个Observer新的实现对象就可以了。这种就是针对接口编程，具体的实现细节都是隐藏的。这样其实我们就做到了松耦合。对于注册中心来说只要订阅者实现了Observer的update接口，并且注册到花名单就行了。这样当注册中心发现改变需要通知的时候就可以通知到所有花名单中的订阅者。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-单例模式</title>
    <url>/2017/09/23/java-design-pattern-single/</url>
    <content><![CDATA[<h2 id="设计模式-单例模式"><a href="#设计模式-单例模式" class="headerlink" title="设计模式-单例模式"></a>设计模式-单例模式</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>单例应该是最简单也是最常用的模式了。单例模式通常用在当一个系统只需要唯一一个类，比如线程池，日志打印等。单例模式的类就只有一个，听起来很简单，但是要写好单例却不容易。不信你自己先想想怎么保证系统里面只有一个单例？</p>
<p><em>单例模式：确保一个类只有一个实例，并且提供一个全局访问点</em></p>
<h3 id="单例实践"><a href="#单例实践" class="headerlink" title="单例实践"></a>单例实践</h3><p>要保证单例的第一步就是要保证类不能随意实例话，new 一个对象的代价是很简单的比如：<code>new Object()</code>。但如果不能new了？没错，我们第一步就是让构造方法私有话，不会对外开放<code>private ObjectConstractor()</code>;但是如果我们还是需要使用这个类怎么办了？一个最简单的单例模式就可以写出来了：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;<span class="comment">//使用static来确保唯一。但是static真的管用么？</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;<span class="comment">//先判断是不是存在，不存在就实例一个。</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实你可以想到，如果在多线程的环境下，我们上面的代码还是会有问题的，就是线程A和线程B同时同刻读取instance，然后两者都是读到null，然后就AB都会去实例话一次instance，这跟我们预想的不一致。</p>
<p>嗯我们可以做点改进，那就是<code>同步</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错在上列中我们是可以解决掉多线程的情况下，instance实例话两次的情况的，这种方式我们也叫做<code>懒汉式单例模式</code>。但是我们引入了<code>synchronized</code>,这又会造成一个新的问题，那就是我们，我们知道这种同步是会降低性能的，当然如果你的机器配置够好，那么对此就可以完全忽略，但是作为程序员，总有一种想要压榨性能的天生渴望～</p>
<p>让我们再来做些改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种改进的方式是在jvm加载该类的时候就已经初始话了，JVM保证任何线程访问这个类之前一定先创建了该类，这种方式也被形象的称为<code>饿汉式单例模式</code>。</p>
<h2 id="单例模式实现方法"><a href="#单例模式实现方法" class="headerlink" title="单例模式实现方法"></a>单例模式实现方法</h2><h3 id="懒汉式单例模式："><a href="#懒汉式单例模式：" class="headerlink" title="懒汉式单例模式："></a>懒汉式单例模式：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉式单例模式："><a href="#饿汉式单例模式：" class="headerlink" title="饿汉式单例模式："></a>饿汉式单例模式：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双重加锁校验："><a href="#双重加锁校验：" class="headerlink" title="双重加锁校验："></a>双重加锁校验：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single.doubblechecking;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sinleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.sinleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举单例模式"><a href="#枚举单例模式" class="headerlink" title="枚举单例模式:"></a>枚举单例模式:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// init something..</span></span><br><span class="line">        object = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举的方式特别有意思，所以我额外还写了一个测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> single.enums.Singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.INSTANCE;</span><br><span class="line">        instance.getObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance.getObject());</span><br><span class="line">        System.out.println(instance.getObject());</span><br><span class="line">        System.out.println(instance.getObject());</span><br><span class="line">        System.out.println(instance.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这四次输出都是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Object@7f31245a</span><br><span class="line">java.lang.Object@7f31245a</span><br><span class="line">java.lang.Object@7f31245a</span><br><span class="line">java.lang.Object@7f31245a</span><br></pre></td></tr></table></figure>

<p>用枚举实现单例是&lt;<Effective java>&gt;里面提倡的，但是实际中我看很少有人用，我们公司也有人直接用的是懒汉式方法上加<code>synchronized</code>，历史的原因就不追述了，但是自己写的代码一定要好好的检查。</p>
<blockquote>
<p>什么是好的代码？可能就是编写以后不需要再重构的代码。因为它的性能已经是最完美了，顶多也就是加一些判断逻辑而已。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-策略模式</title>
    <url>/2017/09/12/java-design-pattern-strategy/</url>
    <content><![CDATA[<h2 id="Java设计模式-策略模式"><a href="#Java设计模式-策略模式" class="headerlink" title="Java设计模式-策略模式"></a>Java设计模式-策略模式</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>策略，什么是策略？就在不同情况下用不同的方式去处理。那么策略模式是什么？ 模式，模式简而言之就是套路，就是前人总结下来得到验证的套路。所以策略模式其实就是用策略去解决一类事情的套路。</p>
<h3 id="策略模式的一个小思考"><a href="#策略模式的一个小思考" class="headerlink" title="策略模式的一个小思考"></a>策略模式的一个小思考</h3><p>说到套路，那么一个套路就要有组成部分，不然怎么套路？而策略模式中，它的主要点就是变化的情况，以及应对变化的处理方法。比如有一家超市打折，可能为了吸引顾客、庆祝节日等，但是可能中途来个产品经理，他说为了利润最大化，要根据付款总数来对顾客实行不同打折额度。这种时候程序员心中都是千万匹马儿在奔腾，就不能为为别人做点好事么？（其实心里就是想着，tmd，又改需求，我还想回家陪老婆孩子的）~~~咳咳，走远了。 就这个超市打折来说，打折这种事情是一定存在的，而对打折的方式可能还会有各种变化。那么怎么去应对这种变化？再说一个例子，如果有个制造鸭子的工厂，我们都知道鸭子有很多类（比如死的，活的），死的就像玩具类~，活的就像烤鸭类(貌似烤之前才是活的.),不管怎样，我想说大多数鸭子都有一些基本行为，比如：飞？叫？游泳？诸如此类..但是我们会发现，鸭厂产出的鸭子最终还是要卖出去的，那么这个鸭子能不能飞？能不能叫？能不能游泳？那都是买家说了算，谁给钱听谁的。那么好了A可能要一个能飞，但不能叫，也不能游泳；B呢想要个能飞，能叫，能游泳；这下如果鸭厂只能生产一种只会飞，或者只会叫的鸭子，那肯定是不行的，但是也不能为了A专门搞个生产线，B专门搞个生产线，这样搞，要是N多客户，N多需求，那可怎么办？说了这么多，基本是废话，那么还是来代码看看。</p>
<span id="more"></span>

<h3 id="鸭厂造鸭"><a href="#鸭厂造鸭" class="headerlink" title="鸭厂造鸭"></a>鸭厂造鸭</h3><p>鸭厂生产鸭,先确定一个<code>Duck</code>类，鸭子基本上有飞，叫，游泳的功能属性;那么鸭子就有了三个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class Duck&#123;</span><br><span class="line"></span><br><span class="line">    public void fly()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    public void swim()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    public void gua()&#123;&#125;;&#x2F;&#x2F;呱呱叫</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>先看下如果要满足A，不用策略模式的话，我们是这样玩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ADuck extends Duck&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void fly()&#123;</span><br><span class="line">            System.out.println(&quot;A的鸭子会飞&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void swim()&#123;</span><br><span class="line">            System.out.println(&quot;A鸭子不能游泳&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void gua()&#123;</span><br><span class="line">            System.out.println(&quot;A鸭子不能叫，太吵&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每一个需求方都需要重新实现一遍，这是不现实的，要是上千个可怎么办？而且用继承的方式，我们就必须的检查每一个继承的方法，那些方法要重写， 那些不需要.</p>
<h3 id="鸭厂改造"><a href="#鸭厂改造" class="headerlink" title="鸭厂改造"></a>鸭厂改造</h3><p>想想看鸭子，鸭子还是鸭子，我们换个角度想，鸭子了，是不会变的，那它还是主体；客户变的是啥？是鸭子的功能，而这种功能我们可以集中起来，对于鸭子我们将它的功能抽出来。当他需要什么功能再给它什么功能。只有它需要我再给。这也是一个设计原则：<strong>多用组合，少用继承</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface FlyBehavior&#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface SwimBehavior&#123;</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Duck&#123;</span><br><span class="line">    FlyBehavior flyBehavior;</span><br><span class="line">    SwimBehavior swimBehavior;</span><br><span class="line"></span><br><span class="line">    public void fly()&#123;</span><br><span class="line">        flyBehavior.fly();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void swim()&#123;</span><br><span class="line">        swimBehavior.swim();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;public void gua()&#123;&#125;;&#x2F;&#x2F;呱呱叫</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们用接口将飞和游泳的行为组合进去Duck，你会问，为啥不直接让Duck实现flyBehavior和swimBehavior接口了？其实如果使用实现的话，那么就会发现一个鸭子可能实现了N个行为，而且对于N个行为你都的重写他的实现方法，不能好的复用。</p>
<p>然后我们只需要实现FlyBehavior和SwimBehaior接口就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">陆地鸭：</span><br><span class="line"></span><br><span class="line">public class CanNotSwim implements swimBehavior</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void swim()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;不会游泳的鸭子....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用翅膀飞的鸭子：</span><br><span class="line"></span><br><span class="line">public class FlyWithWings implements FlyBehavior</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;用翅膀飞......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们将鸭子的行为给我们要造的鸭子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">会飞不回游泳的鸭子：</span><br><span class="line"></span><br><span class="line">public class CanFlyButCanNotSwimDuck extends Duck&#123;</span><br><span class="line">    </span><br><span class="line">    public CanFlyButCanNotSwimDuck()</span><br><span class="line">    &#123;</span><br><span class="line">        swimBehavior &#x3D; new CanNotSwim();</span><br><span class="line">        flyBehavior &#x3D; new FlyWithWings();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>刚刚是通过构造方法来指定行为，将鸭子造出来的。那么这样其实貌似每一种鸭子我好像还是得new一个子类出来，还是不太优雅，怎么弄？</p>
<p>给鸭子升级：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line"></span><br><span class="line">    public void fly( FlyBehavior flyBehavior)&#123;</span><br><span class="line">        flyBehavior.fly();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void swim( SwimBehavior swimBehavior)&#123;</span><br><span class="line">        swimBehavior.swim();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">    public static void main([]string args)&#123;</span><br><span class="line">        Duck A &#x3D; new Duck();</span><br><span class="line">        a.fly(new FlyWithWings());</span><br><span class="line">        a.swim(new CanNotSwim());</span><br><span class="line"></span><br><span class="line">        Duck B &#x3D; new Duck();</span><br><span class="line">        B.fly(new FlyWithWings())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然也可以通过<code>set</code>方法来设置行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line">   </span><br><span class="line">   FlyBehavior flyBehavior;</span><br><span class="line">   SwimBehavior swimBehavior;</span><br><span class="line"></span><br><span class="line">   public void fly()&#123;</span><br><span class="line">       flyBehavior.fly();</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   public void swim()&#123;</span><br><span class="line">       swimBehavior.swim();</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   public void setFlyBehavior(FlyBehavior flyBehavior)&#123;</span><br><span class="line">       this.flyBehavior&#x3D;flyBehavior;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种时候我们就能看到策略模式的用处了，当来了一个新的功能，比如造一个’带火箭飞的鸭子’，那么只需要实现一个飞的行为就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class FlyWithRocket implements FlyBehavior</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;火箭带飞....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只需要需要的地方再设置成飞的行为为<code>FlyWithRocket</code>就可以了。</p>
<p>可以看到我们将会变化的部分抽离出来，然后进行组合；这也说明了软件开发的一个设计原则：<strong>针对接口编程,而不是实现编程</strong>。对于抽出来的一组行为，其实是独立于鸭子的，这也说明我们可以在其他地方使用这些行为。比如造鸭鸣器就可以复用鸭子的叫的行为。</p>
<h3 id="策略模式总结"><a href="#策略模式总结" class="headerlink" title="策略模式总结"></a>策略模式总结</h3><p>总的来说，策略模式就是定义了一组行为，将各行为分别封装起来，然后可以互相替换。这组行为是独立于真正使用行为的实体的。</p>
<blockquote>
<p>如果在再开发中，思考下哪些是变动的，哪些是可以抽出来的。业务变动是不可预计的，不能为了设计而设计，但是多留心，代码也能写的更加优雅。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式-模板方法模式</title>
    <url>/2017/10/09/java-design-pattern-template-method/</url>
    <content><![CDATA[<h2 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>模板方法模式,它其实肯定是有一个模板的.模板是什么?就是假定的标准.而这个标准由我们定义.模板方法指什么了?它就是封装了一系列操作到一个方法里面.为啥这么说?看生活中的一个实例:</p>
<h3 id="生活例子"><a href="#生活例子" class="headerlink" title="生活例子"></a>生活例子</h3><ul>
<li>泡咖啡: 如果我们想要喝咖啡,我们会怎么做?<ol>
<li>烧水;</li>
<li>放咖啡;</li>
<li>选个马克杯子;</li>
<li>加点牛奶或糖.</li>
</ol>
</li>
</ul>
<p>泡一杯咖啡,我们大概就是这样操作.让我们再看看有些人不喜欢咖啡,喜欢喝茶.那么应该是怎样了?</p>
<ul>
<li>泡茶: 如果喜欢喝茶,泡一杯茶怎么做?<ol>
<li>烧水;</li>
<li>放茶叶;</li>
<li>选个保温杯?;</li>
<li>加奶或者加柠檬?.加点奶变奶茶,或者加点柠檬变成柠檬茶?<span id="more"></span>
泡茶的步骤,我们大概就是这样了.</li>
</ol>
</li>
</ul>
<p>看看泡茶和泡咖啡的流程,它是不是可以抽象出来?比如说</p>
<ul>
<li>第一步: 烧水,我统一在一个地方烧水不就行了?要烧两次浪费电么(电烧水壶).</li>
<li>第二步: 放咖啡/放茶叶,简单来说,这不是就放饮料而已么.</li>
<li>第三步: 选杯子,马克杯还是保温杯不就是选一个杯子啊.</li>
<li>第四步: 加奶,加糖,加柠檬.总的来说就是加调料.</li>
</ul>
<p>如果仔细想想看这几个步骤,总体来说他们都是一样的.所以我们抽象出来就是:</p>
<ol>
<li>烧水</li>
<li>放饮料</li>
<li>选杯子</li>
<li>放调料</li>
</ol>
<p>如果我们在代码里面实现就是:</p>
<p>饮料模板类:<code>BeverageTemplate.java</code>,饮料模板类定义了一系列的模板方法,其中如果是共用的,比如<code>boilwater()</code>,那么子类继承之后就无需再单独实现了,另外如果是其它的方法,那么就交由具体的子类单独去实现.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饮料模板</span></span><br><span class="line"><span class="comment"> * Beverage:饮料</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BeverageTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *准备饮料</span></span><br><span class="line"><span class="comment">     * 将一系列方法按照一个固定的模板排布</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareBeverage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilWater();<span class="comment">//烧水</span></span><br><span class="line">        putBeverage();<span class="comment">//放饮料</span></span><br><span class="line">        packageCup();<span class="comment">//选杯子装杯</span></span><br><span class="line">        addCondiment();<span class="comment">//放调料</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;烧开水...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">packageCup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">putBeverage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咖啡类,继承自饮料模板类,并且重写了几个模板方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBeverage</span> <span class="keyword">extends</span> <span class="title">BeverageTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addCondiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖,咖啡太苦...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">packageCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;选个星巴克的杯子好拍(zhuang)照(bi)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">putBeverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;放现磨咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>茶类,继承自饮料模板类,重写父类的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeaBeverage</span> <span class="keyword">extends</span> <span class="title">BeverageTemplate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addCondiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;放点奶,变奶茶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">packageCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;选个保温杯,多喝几次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">putBeverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;放茶叶&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到每一个子类都有自己的具体操作实现,但是他们的操作步骤确已经订好了.这有点类似是,父类只是定义接口,具体实现交个子类.</p>
<p>但是你可能会想,加不加调料,那是喝的人说了算啊.我们现在的定义方式不就是所有的人都要加,那如果我想喝的就是绿茶,不需要奶,怎么办? 这种时候,我们其实可以稍微做些改动,修改一下我们的模板类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饮料模板</span></span><br><span class="line"><span class="comment"> * Beverage:饮料</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BeverageTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *准备饮料</span></span><br><span class="line"><span class="comment">     * 将一系列方法按照一个固定的模板排布</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareBeverage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilWater();<span class="comment">//烧水</span></span><br><span class="line">        putBeverage();<span class="comment">//放饮料</span></span><br><span class="line">        packageCup();<span class="comment">//选杯子装杯</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(needCondiment())&#123;</span><br><span class="line">            addCondiment();<span class="comment">//放调料</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要调料</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needCondiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;烧开水...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">packageCup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">putBeverage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后我们可以看到,我们成功的加入了一个钩子,这个钩子有啥用?那就是当我们的子类如果不需要调料的时候,子类重新实现一下即可.我们也可以实现一个空方法如下面:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饮料模板</span></span><br><span class="line"><span class="comment"> * Beverage:饮料</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BeverageTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *准备饮料</span></span><br><span class="line"><span class="comment">     * 将一系列方法按照一个固定的模板排布</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareBeverage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilWater();<span class="comment">//烧水</span></span><br><span class="line">        putBeverage();<span class="comment">//放饮料</span></span><br><span class="line">        packageCup();<span class="comment">//选杯子装杯</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(needCondiment())&#123;</span><br><span class="line">            addCondiment();<span class="comment">//放调料</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        otherMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">otherMethod</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要调料</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needCondiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;烧开水...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">packageCup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">putBeverage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这种,我们加入了<code>otherMethod()</code>然后里面实现是一个空方法.这种空方法如果看jdk会发现有很多都是这样弄的.比如io包里面就有.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在是时候来总结一下了.茶和咖啡,我们将通用步骤抽出来,然后放到父类的通用模板里面,而具体的实现操作我们交给子类,子类的各实现中,我们应该不要互相调用.尤其是不应该调用父类的方法.这样的目的是减少依赖.即父类可以调用子类的实现,而子类中的实现应该避免去调用父类的组件.这个有点类似考大学,学子只需要好好读好书,考高分就行了,而学校是否录取你,你填好自愿之后,你也别去问了,它需要的时候自然回来通知你.书中称这种为<code>好莱坞原则</code>:别去调用高层次组建,高层次组件回来调用你.</p>
<p>现在该给模板方法模式下定义了:<code>在一个方法中定义了一个算法的骨架,而将一些步骤延迟到子类中.模板方法使得子类可以在不改变算法结构的情况下,重新定义算放中的某些步骤.</code></p>
<p>仔细回想,我们的<code>prepare()</code>它可不可以算个算法步骤?第一步干嘛,第二步干嘛..这就是算法骨架么.然后所有的子类都将实现抽象方法.这不就是将实现放到子类中了么.</p>
<p>好了,就到此了.如果你有什么问题,欢迎一起探讨.</p>
<p>参考资料: &lt;&lt;Head First 设计模式&gt;&gt;</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 开发遇到的两个问题</title>
    <url>/2019/03/31/java-develop-normal-error/</url>
    <content><![CDATA[<h1 id="Java开发遇到的两个问题"><a href="#Java开发遇到的两个问题" class="headerlink" title="Java开发遇到的两个问题"></a>Java开发遇到的两个问题</h1><h2 id="Object-反序列化失败"><a href="#Object-反序列化失败" class="headerlink" title="Object 反序列化失败"></a>Object 反序列化失败</h2><p>使用<code>@ReponseBody</code>返回一个json串，返回的类型是<code>Object</code>，我们知道如果是<code>@RestController</code>，都会已restful返回，也就是返回json格式的数据，但是如果你是使用Object返回值，然后Object只是一个null或者仅仅只是<code>new Object()</code>，那么就会返回下面的异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class java.lang.Object and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: java.util.ArrayList[1])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RestTemplate使用中path有-问题"><a href="#RestTemplate使用中path有-问题" class="headerlink" title="RestTemplate使用中path有{}问题"></a>RestTemplate使用中path有{}问题</h2><p>RestTemplate 默认就是将path中的<code>&#123;&#125;</code>作为一个赋值表达式的，它会认为你需要替换<code>&#123;&#125;</code>中的内容。所以在path中最好特别注意下。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-encode 编码注意事项</title>
    <url>/2017/05/10/java-encode/</url>
    <content><![CDATA[<p>Tomcat URL 编码配置<br><a href="http://localhost:8080/examples/servlets/servlet/%E9%A5%BA%E5%AD%90?author=%E9%A5%BA%E5%AD%90">http://localhost:8080/examples/servlets/servlet/饺子?author=饺子</a></p>
<p>其中<br>http: 对应scheme，协议</p>
<p>localhost: 对应Domain，主域</p>
<p>8080: port，端口，配置在tomcat<Connector port="8080"/></p>
<p>examples: ContextPath，配置在tomcat<Context path="/examples"/> </p>
<p>servlet/servlet: ServletPath，在web.xml中<url-pattern>中配置</p>
<p>饺子: pathInfo，指到具体的servlet</p>
<p>author=饺子: QueryString，传递的参数，如果是post就是表单方式提交</p>
<p>浏览器编码将非ASCII字符编码成16进制数然后再之前加上”%”</p>
<span id="more"></span>
<p>对URL的URI不分进行解码的字符实在<Connect URIEncoding="UTF-8">中定义的.默认为ISO-8859-1，QueryString的解码字符要么是Header中的ContentType定义的charset，默认是ISO-8859-1，要使用ContentType中定义的编码，需要将connector的<Connector URIEncoding="UTF-8" useBodyEncodingForURI="true"/>，其中的useBodyEncodingForURI 仅仅是对QueryString进行BodyEncoding解码，不针对整个URI。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Encode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 枚举和注解总结</title>
    <url>/2018/03/22/java-enum-anotation/</url>
    <content><![CDATA[<h1 id="Java-枚举和注解总结"><a href="#Java-枚举和注解总结" class="headerlink" title="Java 枚举和注解总结"></a>Java 枚举和注解总结</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="没有枚举前我们基本上常量来定义值："><a href="#没有枚举前我们基本上常量来定义值：" class="headerlink" title="没有枚举前我们基本上常量来定义值："></a>没有枚举前我们基本上常量来定义值：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED   = <span class="number">1</span>;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果有了枚举后我们会怎样了？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    GREEN,RED,BLACk,.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码是不是就清晰很多了？而且使用的时候输出的值我们是可以使用GREEN，是不是可以很明白的知道是什么颜色？</p>
<h3 id="枚举的创建"><a href="#枚举的创建" class="headerlink" title="枚举的创建"></a>枚举的创建</h3><p>枚举是继承自<code>Enum</code>，使用<code>enum</code>关键字。</p>
<h3 id="枚举的使用场景"><a href="#枚举的使用场景" class="headerlink" title="枚举的使用场景"></a>枚举的使用场景</h3><p>枚举适合在<strong>固定的常量</strong>下使用，比如四季，月份，星期；这种基本公认的而且不会有改变的场景下使用。</p>
<h3 id="编译器中的枚举"><a href="#编译器中的枚举" class="headerlink" title="编译器中的枚举"></a>编译器中的枚举</h3><p>编译器默认帮我们实现了很多枚举中的方法，比如equals(),hashCode(),toString,values(),valueOf(String)等。这些都是编译器帮我们做的。</p>
<h3 id="枚举中的注意事项"><a href="#枚举中的注意事项" class="headerlink" title="枚举中的注意事项"></a>枚举中的注意事项</h3><ol>
<li>不能使用static，final修饰枚举，因为它是隐式的final类型的；</li>
<li>因为是final类型，所以我们也就知道它是<strong>不能被继承</strong>的；</li>
<li>从Enum继承的clone是final类型的，枚举是不能重写clone方法的，并且Enum里面的clone方法直接抛出异常，所以enum是不能被clone的;</li>
<li>enum中的ordinal是强依赖于枚举实例的定义顺序的，所以用ordinal来做判断顺序是不推荐的，因为只要在非最后加入实例，那么就会改变整体的顺序;如果是需要顺序可以自定义属性。</li>
</ol>
<span id="more"></span>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解出现前"><a href="#注解出现前" class="headerlink" title="注解出现前"></a>注解出现前</h3><p>注解的作用我理解为就是用来约定一些数据定义，让我们可以在某个属性或者某个地方做个标记。在注解出现前能做这个的应该是XML，我们通常在xml中定义类或者属性的相关配置。而有了注解我们可以在代码中直接定义了。</p>
<h3 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h3><ol>
<li>定义注解的注解，元注解：<code>@Rentation</code>，<code>@Target</code>，<code>@Document</code>，<code>@Inherited</code></li>
<li>jdk内置注解：<code>@Override</code>，<code>@Deprecated</code>…</li>
<li>自定义的注解</li>
<li>spring等外部注解</li>
</ol>
<p>作用场景：</p>
<p><code>@Rentation</code>：Source，Class，Runtime</p>
<p>作用目标域：</p>
<p><code>@Target</code>：Construct，Field，Local_variable,method,package,paramter,type</p>
<h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>注解的定义使用<code>@interface</code>关键字，并且使用元注解进行标注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Rentation(Rentation.Runtime)</span></span><br><span class="line"><span class="meta">@Target(ElementType.Field)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> XxAnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">values</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><p>注解里面的属性只能使用以下6种类型来定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 所有的基本类型；</span><br><span class="line"><span class="number">2.</span> String</span><br><span class="line"><span class="number">3.</span> Class</span><br><span class="line"><span class="number">4.</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">5. <span class="title">Annotation</span></span></span><br><span class="line"><span class="class">6. 以上类型的数组类型</span></span><br></pre></td></tr></table></figure>

<p>注解不允许使用基本类型的包装类来定义里面的注解属性。注解里面的属性都是使用方法的方式来定义的。有点类似接口方法。<br>注解的属性需要注意一下几点：</p>
<ol>
<li>要么具有默认值，要么在使用注解的时候提供属性的值；</li>
<li>非基本类型的元素，默认值不能为null；</li>
<li>如果只有一个属性，那么可以设置为value，在使用注解的时候就可以直接赋值；<code>@XxAnotation(&quot;ok&quot;)</code></li>
</ol>
<blockquote>
<p>ps:注解是不能继承的。</p>
</blockquote>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>我们定义了注解，设置了元素值。那么就必须要有一个处理器来进行注解处理。这个可以看看之前的<a href="http://www.chenzhijun.top/2017/08/19/java-sensitive/">Java 特殊字段脱敏</a>，我们可以使用反射来获取注解定义的值，然后进行业务处理。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Enum 与 Json 的互相转换</title>
    <url>/2019/07/06/java-enum-how-to-generate-json/</url>
    <content><![CDATA[<h1 id="Java-Enum-与-Json-的互相转换"><a href="#Java-Enum-与-Json-的互相转换" class="headerlink" title="Java Enum 与 Json 的互相转换"></a>Java Enum 与 Json 的互相转换</h1><p>在Java中使用Enum的频率很高，我们也经常使用 Enum 作为类的一个属性定义。那么如果需要将Enum转换成Json或者将Json传转换成Enum该怎么操作了？接下来我们看一下。Enum序列化成Json的几种方式。</p>
<blockquote>
<p>本实例使用的是<code>jackson</code>的包，用的是<code>ObjectMapper</code>.</p>
</blockquote>
<p>首先我们定义一个类<code>Instance</code>，里面有一个<code>Enum</code>的参数: <strong>state</strong> ; 在这里我们为了方便观察几种不同 Enum 的json序列化方式，state定义为<code>Object</code>,<code>Instance</code>类定义如下;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.PropertyNamingStrategy;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonNaming;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonNaming(PropertyNamingStrategy.SnakeCaseStrategy.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instance</span> </span>&#123;</span><br><span class="line">    Object state;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instance</span><span class="params">(Object state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state=state;</span><br><span class="line">        <span class="keyword">this</span>.bookName=<span class="string">&quot;《Java枚举类-json转换》&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(Object state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="原生Enum"><a href="#原生Enum" class="headerlink" title="原生Enum"></a>原生Enum</h2><p>这种我们通常是不做任何改动，就一个普通的定义Enum:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    SUCCESS(<span class="string">&quot;success&quot;</span>, <span class="number">1</span>), FAILED(<span class="string">&quot;failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    State(String value, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种方式下，我们可以看一下转换成json后的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enumJsonTest</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    <span class="comment">//枚举类不做任何改动json转化结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;枚举不做任何改动json转化结果:&quot;</span>);</span><br><span class="line">    Instance instance = <span class="keyword">new</span> Instance(State.SUCCESS);</span><br><span class="line">    System.out.println(objectMapper.writeValueAsString(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后可以看到结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;state&quot;</span>:<span class="string">&quot;SUCCESS&quot;</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;《Java枚举类-json》&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，Enum默认使用的是<code>enum.name()</code>来作为json的值。</p>
<h2 id="使用-Enum-的所有属性值作为json值"><a href="#使用-Enum-的所有属性值作为json值" class="headerlink" title="使用 Enum 的所有属性值作为json值"></a>使用 Enum 的所有属性值作为json值</h2><p>有时候我们可以让Enum像一个普通类一样，json序列化的时候将其中的所有属性都能输出，可以使用的方式是在Enum的定义上加上<code>@JsonFormat(shape = JsonFormat.Shape.OBJECT)</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonFormat(shape = JsonFormat.Shape.OBJECT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State2</span> </span>&#123;</span><br><span class="line">    SUCCESS(<span class="string">&quot;success&quot;</span>, <span class="number">1</span>), FAILED(<span class="string">&quot;failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    State2(String value, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法如上,输出的结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;state&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;num&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;book_name&quot;</span>: <span class="string">&quot;《Java枚举类-json转换》&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Enum的某一个属性作为json值"><a href="#使用Enum的某一个属性作为json值" class="headerlink" title="使用Enum的某一个属性作为json值"></a>使用Enum的某一个属性作为json值</h2><p>有时候我们可能想要使用Enum中定义的某一个自定义属性的值，只需要在属性的<code>get</code>方法上使用<code>@JsonValue</code>即可满足需求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State1</span> </span>&#123;</span><br><span class="line">    SUCCESS(<span class="string">&quot;success&quot;</span>, <span class="number">1</span>), FAILED(<span class="string">&quot;failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    State1(String value, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试方法如上,输出的结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;state&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;book_name&quot;</span>: <span class="string">&quot;《Java枚举类-json转换》&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到与原生的Enum相比，state的值变成了我们在Enum中定义的<code>value</code>。<strong>注意值的大小写</strong>。</p>
<h2 id="自定义序列化结果"><a href="#自定义序列化结果" class="headerlink" title="自定义序列化结果"></a>自定义序列化结果</h2><p>有时候我们还可能想更高级一点，那么就可以自定义序列化结果。比如Enum的属性<code>num</code>，原本是<code>int</code>类型，但是我们就是想让它变成一个<code>String</code>类型，或者我不想要Enum其中的某一个变量。那么可以自己实现序列化接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializerProvider;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ser.std.StdSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateSerializer</span> <span class="keyword">extends</span> <span class="title">StdSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">StateSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(State3.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> State3)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        State3 state = (State3) o;</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        jsonGenerator.writeString(state.name());</span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        jsonGenerator.writeString(state.getValue());</span><br><span class="line">        jsonGenerator.writeFieldName(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="comment">//        jsonGenerator.writeNumber(state.getNum());</span></span><br><span class="line">        jsonGenerator.writeString(String.valueOf(state.getNum()));</span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们定义了我们自己的特殊要求，之后再Enum的定义中进行指定,使用<code>@JsonSerialize(using = StateSerializer.class)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonSerialize;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonSerialize(using = StateSerializer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State3</span> </span>&#123;</span><br><span class="line">    SUCCESS(<span class="string">&quot;success&quot;</span>, <span class="number">1</span>), FAILED(<span class="string">&quot;failed&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    State3(String value, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法如上，输出的结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;state&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;SUCCESS&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;num&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;book_name&quot;</span>: <span class="string">&quot;《Java枚举类-json转换》&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附上所有的测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumJsonTest</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enumJsonTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//枚举类不做任何改动json转化结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;枚举不做任何改动json转化结果:&quot;</span>);</span><br><span class="line">        Instance instance = <span class="keyword">new</span> Instance(State.SUCCESS);</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(instance));<span class="comment">//&#123;&quot;state&quot;:&quot;SUCCESS&quot;,&quot;name&quot;:&quot;《Java枚举类-json》&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n使用枚举的某一个参数作为json的转化结果:&quot;</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> Instance(State1.SUCCESS);</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(instance));<span class="comment">//&#123;&quot;state&quot;:&quot;success&quot;,&quot;book_name&quot;:&quot;《Java枚举类-json转换》&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n将Enum所有的参数一起作为json的转化结果:&quot;</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> Instance(State2.SUCCESS);</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(instance));<span class="comment">//&#123;&quot;state&quot;:&#123;&quot;value&quot;:&quot;success&quot;,&quot;num&quot;:1&#125;,&quot;book_name&quot;:&quot;《Java枚举类-json转换》&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n使用serializer自定义enum的json转化结果:&quot;</span>);</span><br><span class="line">        instance = <span class="keyword">new</span> Instance(State3.SUCCESS);</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(instance));<span class="comment">//&#123;&quot;state&quot;:&#123;&quot;name&quot;:&quot;SUCCESS&quot;,&quot;value&quot;:&quot;success&quot;,&quot;num&quot;:&quot;1&quot;&#125;,&quot;book_name&quot;:&quot;《Java枚举类-json转换》&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;json-&gt;class&quot;</span>);</span><br><span class="line">        String json = <span class="string">&quot;&#123;\&quot;state\&quot;:&#123;\&quot;value\&quot;:\&quot;success\&quot;,\&quot;num\&quot;:1&#125;,\&quot;book_name\&quot;:\&quot;《Java枚举类-json转换》\&quot;&#125;\n&quot;</span>;</span><br><span class="line">        instance = objectMapper.readValue(json, Instance.class);</span><br><span class="line">        System.out.println(instance.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，Enum的Json转化就可以任君”宰割”了~~</p>
<p>如果是Json串转Java类型，就把上面的方式换过来即可。比如上一个测试类中的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">String json = &quot;&#123;\&quot;state\&quot;:&#123;\&quot;value\&quot;:\&quot;success\&quot;,\&quot;num\&quot;:1&#125;,\&quot;book_name\&quot;:\&quot;《Java枚举类-json转换》\&quot;&#125;\n&quot;;</span><br><span class="line">instance = objectMapper.readValue(json, Instance.class);</span><br><span class="line">System.out.println(instance.getState());</span><br></pre></td></tr></table></figure>

<p>嗯嗯<del>全文完</del></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Enum</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson 转换Map问题</title>
    <url>/2017/08/19/java-fastjson-map/</url>
    <content><![CDATA[<h2 id="使用FastJson-转换成HashMap-lt-String-List-gt-问题"><a href="#使用FastJson-转换成HashMap-lt-String-List-gt-问题" class="headerlink" title="使用FastJson 转换成HashMap&lt;String,List&gt;问题"></a>使用FastJson 转换成HashMap&lt;String,List<Object>&gt;问题</h2><h3 id="背景需求"><a href="#背景需求" class="headerlink" title="背景需求"></a>背景需求</h3><p>有个json串需要转换成Map&lt;String,List<Object>&gt;这种格式,在使用fastjson的时候发现出现异常,调试后发现是类型转化出错,它将List<Object>转成了JSONArray<JSONObject>,这个就很尴尬了.这个问题也找了很久,一直以为它可以直接转换成我想要的List<Object>,没想到最后来了个JSONArray.</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><span id="more"></span>
<p>因为实际中我们需要的是List而不是JSONArray,如果每个都是自己手动去改变,不太符合程序员的特质.所以想到一个通用办法解决:将JSONArray的值取出来,转换成List再重新塞进Map对象里面,具体实现代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static &lt;T&gt; HashMap&lt;String, List&lt;T&gt;&gt; fromJson2Map(String jsonString)</span><br><span class="line">&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; jsonMap &#x3D; JSON.parseObject(jsonString, HashMap.class);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, List&lt;T&gt;&gt; resultMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for(String key : jsonMap.keySet())</span><br><span class="line">    &#123;</span><br><span class="line">        JSONArray jsonArray &#x3D; (JSONArray)jsonMap.get(key);</span><br><span class="line">        List list &#x3D; handleJSONArray(jsonArray);</span><br><span class="line">        resultMap.put(key, list);</span><br><span class="line">    &#125;</span><br><span class="line">    return resultMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt; List&lt;T&gt; handleJSONArray(JSONArray jsonArray)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;T&gt; list &#x3D; new ArrayList();</span><br><span class="line">    for(Object object : jsonArray)</span><br><span class="line">    &#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; (JSONObject)object;</span><br><span class="line">        T obj &#x3D; (T)JSONObject.parseObject(jsonObject.toJSONString(), Object.class);</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最后<code>T obj = (T)JSONObject.parseObject(jsonObject.toJSONString(), Object.class);</code> 其实我一开始是犹豫的,主要是Object.class,后来想想Java的Object是一切对象的父类,自然可以多态转成子类啊.所以这里就完美的解决了问题. 当然代码应该会有性能问题,应该是new ArrayList() 吧, 每次都会new一个新对象,用完了之后也没有其它的用了,一直等着垃圾回收?.突然觉得自己路还有很长的要走.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO流</title>
    <url>/2017/09/20/java-io/</url>
    <content><![CDATA[<h2 id="Java-IO流"><a href="#Java-IO流" class="headerlink" title="Java IO流"></a>Java IO流</h2><h3 id="Java-IO流简述"><a href="#Java-IO流简述" class="headerlink" title="Java IO流简述"></a>Java IO流简述</h3><p>JavaIO 中流都分别在java.io包中，主要分为几类：</p>
<ul>
<li>字节流：Byte Stream-&gt;InputStream/OutputStream</li>
<li>字符流: Character Stream-&gt;Reader/Writer</li>
<li>缓冲流：Buffered Stream</li>
<li>数据流：Data Stream 只针对基本数据类型：(boolean, char, byte, short, int, long, float, double) 还有String</li>
<li>对象流: Object Stream,继承自Serializable,必须序列化</li>
<li>控制台的流..</li>
</ul>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>字节流其实又叫做二进制流，因为它是最基本的二进制的数据的读取，也就是010101的读取与传输。如果读取的数据全是文字类型，那么推荐使用字符流的，如果是图片或者其它的图片可以使用字节流。看下<code>InputStream</code> 类里面的相关方法：</p>
<p><img src="/images/qiniu/2017-09-20-17-24-13.png" alt="2017-09-20-17-24-13"></p>
<p>InputStream实现了Closeble,Closeble继承了AutoCloseable，其实就是相当与一个标记，AutoCloseable是1.7才出来的，主要是为了<code>t-w-r</code>语法主动关闭流。</p>
<p>InputStream是<code>abstract</code>的，一定要注意它是一个抽象类。我们说的装饰者模式里面，InputStream的实际实现(实现了InputStream的相关方法)基本都是类似于组件，而InputStream相当与一个超类。里面的主要构成是8个方法一个属性。</p>
<h4 id="available"><a href="#available" class="headerlink" title="available()"></a>available()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看我们的第一个方法<code>available()</code>,它的作用是返回流中估计的长度，而这个长度怎么设置？看源码中的介绍最后归结两句话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 永远也不要调用此方法来确认分配多大的缓存空间，因为它永远返回0。</span><br><span class="line">2. 任何继承&#96;InputStream&#96;的子类必须重写该方法。</span><br></pre></td></tr></table></figure>

<p>意思就是子类自己去实现这个方法。</p>
<span id="more"></span>

<h4 id="mark"><a href="#mark" class="headerlink" title="mark()"></a>mark()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void mark(int readlimit) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>mark()</code>方法在原文中有个：<code> Marking a closed stream should not have any effect on the stream.</code> 这里的方法是个空方法，子类需要自己实现，当然这里没有强制要求。只是mark的作用是在reset的时候开始的。当调用mark的时候会从readlimit的位置开始将之后读到的内容放到缓存块中。这样reset之后再读取就能取到值了。</p>
<h4 id="markSupported"><a href="#markSupported" class="headerlink" title="markSupported()"></a>markSupported()</h4><p><code>markSupported()</code>方法是指是否支持<code>mark</code>和<code>reset</code>方法，只有两者都支持得时候才能返回<code>true</code>,默认为<code>false</code>;<br>可以查看<code>FileInputStream</code>和<code>DataInputStream</code>,这两个子类有分别不同的方式。</p>
<h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>读取流中的下一个字节数，返回一个0-255的int值。如果读到流的最后一个字节，返回<code>-1</code>。该方法子类必须自己重写。</p>
<h4 id="read-byte"><a href="#read-byte" class="headerlink" title="read(byte[])"></a>read(byte[])</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将流的内容读取到<code>b</code>字节数组（缓冲数组）中。如果b的长度为0，那么不会有任何的字节会读取到数组中，并且返回0。如果不是的话，它会将缓存小于等于b的数组长度，一次一次来读取内容。读取到最后返回-1。</p>
<h4 id="read-1"><a href="#read-1" class="headerlink" title="read()"></a>read()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = read();</span><br><span class="line">    <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b[off] = (<span class="keyword">byte</span>)c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">            c = read();</span><br><span class="line">            <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            b[off + i] = (<span class="keyword">byte</span>)c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实这个方法可以看到是调用的<code>read()</code>方法来实现的。目的就是将读到的<code>byte</code>字节一个一个缓存到字节数组中。</p>
<h4 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;mark/reset not supported&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通俗的讲如果你在书的某一个位置放了一个书签，那么在你想返回到书签的位置的时候。这个动作就叫做reset().<br>默认是抛出异常的，除非子类自己实现它。调用reset的时候，markSupport也必须返回true。并且mark的位置不能是无效的。比如你放书签不能超过书的范围吧。</p>
<h4 id="skip-long"><a href="#skip-long" class="headerlink" title="skip(long)"></a>skip(long)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> remaining = n;</span><br><span class="line">    <span class="keyword">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = (<span class="keyword">int</span>)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);</span><br><span class="line">    <span class="keyword">byte</span>[] skipBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    <span class="keyword">while</span> (remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        nr = read(skipBuffer, <span class="number">0</span>, (<span class="keyword">int</span>)Math.min(size, remaining));</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        remaining -= nr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - remaining;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接看代码实现。里面使用的read(byte,0,length);这不就是读取字符么。跳过多少个字符，就是先读多少个字符，读完之后之后读的字符再返回给你，返回实际跳过的字符。</p>
<h4 id="MAX-SKIP-BUFFER-SIZE"><a href="#MAX-SKIP-BUFFER-SIZE" class="headerlink" title="MAX_SKIP_BUFFER_SIZE"></a>MAX_SKIP_BUFFER_SIZE</h4><p><code>private static final int MAX_SKIP_BUFFER_SIZE = 2048;</code> 这个属性的默认值为2048，好像也就只在skip里面用到了，就是定义一个最大的缓存大小。</p>
<h3 id="其它流"><a href="#其它流" class="headerlink" title="其它流"></a>其它流</h3><p>所有的字节流都是继承InputStream。</p>
<p>非缓存流获取数据是直接跟OS打交道。缓存流将数据读到内存空间然后内存空间空了才去调用底层OS方法。自动刷缓存可以设置<code>autoflush</code>,通过构造方法设置。</p>
<p>建立一个缓存流<code>new DataOutputStream(new BufferedOutputStream(new FileOutputStream(dataFile)))</code></p>
<p>Data stream : DataInputStream/DataOutputStream  </p>
<blockquote>
<p>不要使用浮点数来表示精确的数字，如果需要精确的数字用BigDecimal</p>
</blockquote>
<p>Object Streams : ObjectInputStream/ObjectOutputStream </p>
<h3 id="文件流（NIO）"><a href="#文件流（NIO）" class="headerlink" title="文件流（NIO）"></a>文件流（NIO）</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类转 Json 时属性名使用下划线</title>
    <url>/2019/07/06/java-json-generate-with-underline/</url>
    <content><![CDATA[<h1 id="Java-类转-Json-时属性名使用下划线"><a href="#Java-类转-Json-时属性名使用下划线" class="headerlink" title="Java 类转 Json 时属性名使用下划线"></a>Java 类转 Json 时属性名使用下划线</h1><p>很多时候和其它系统对接的时候，不太喜欢用驼峰的方式，毕竟如果是给前端的api，写个驼峰总感觉有点怪异，总喜欢将属性使用下划线。也就是一个<code>bookName</code>,给前端的时候是：<code>book_name</code>，当然如果是后台系统，还是使用驼峰啊。</p>
<h2 id="Java-统一-json-为下划线"><a href="#Java-统一-json-为下划线" class="headerlink" title="Java 统一 json 为下划线"></a>Java 统一 json 为下划线</h2><p>在 Java 中有两种方式可以实现这种方式，一种是全局的，一种是局部。</p>
<span id="more"></span>
<h3 id="全局修改属性的json名为下划线格式"><a href="#全局修改属性的json名为下划线格式" class="headerlink" title="全局修改属性的json名为下划线格式"></a>全局修改属性的json名为下划线格式</h3><p>如果需要全局的修改，那么只需要在类上面使用<code>@JsonNaming(PropertyNamingStrategy.SnakeCaseStrategy.class)</code>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.PropertyNamingStrategy;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonNaming;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonNaming(PropertyNamingStrategy.SnakeCaseStrategy.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instance</span> </span>&#123;</span><br><span class="line">    Object state;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instance</span><span class="params">(Object state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state=state;</span><br><span class="line">        <span class="keyword">this</span>.bookName=<span class="string">&quot;《json转换》&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(Object state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>转换后的json为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;state&quot;</span>: <span class="string">&quot;Success&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;book_name&quot;</span>: <span class="string">&quot;《json转换》&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部修改属性的json名为下划线格式"><a href="#局部修改属性的json名为下划线格式" class="headerlink" title="局部修改属性的json名为下划线格式"></a>局部修改属性的json名为下划线格式</h3><p>局部的方式就是使用<code>@JsonProperty(value = &quot;book_name&quot;)</code>这个作用在属性上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instance</span> </span>&#123;</span><br><span class="line">    String state;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(value = &quot;book_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instance</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.bookName = <span class="string">&quot;《json转换》&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jsonTest</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    Instance instance = <span class="keyword">new</span> Instance(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    System.out.println(objectMapper.writeValueAsString(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Apache POI操作生成Execl</title>
    <url>/2017/12/11/java-poi-operation/</url>
    <content><![CDATA[<h2 id="使用Apache-POI操作生成Execl"><a href="#使用Apache-POI操作生成Execl" class="headerlink" title="使用Apache POI操作生成Execl"></a>使用Apache POI操作生成Execl</h2><p>使用Java操作数据生成Excel表格，在网上能搜到的方式有很多，比如jxl，还有今天用到POI。POI是Apache开源的一个项目，该工具使用简单，方便。</p>
<h3 id="准备与一些概念约定"><a href="#准备与一些概念约定" class="headerlink" title="准备与一些概念约定"></a>准备与一些概念约定</h3><p>需要在<a href="http://poi.apache.org/">poi官网</a>下载相应的jar包，或者使用maven来引入包。在开始之前我们需要知道一些关于excel文档的概念。一个excel文件通常称为[workbook]，excel里面的一个工作页面通常叫做[sheet]，sheet里面的格子称为[单元格cell]，单元格由坐标确定唯一位置，相应为[行row]，[列col]。</p>
<p><img src="/images/qiniu/2017-12-11-15-41-40.png" alt="2017-12-11-15-41-40"></p>
<p>了解这些我们可以开始看看poi的一些类和接口。</p>
<span id="more"></span>
<h3 id="POI"><a href="#POI" class="headerlink" title="POI"></a>POI</h3><p>POI 中主要的几个类为：<code>HSSFWorkbook</code>，<code>HSSFSheet</code>，<code>Row</code>，<code>Cell</code>。就像我们创建一个最简单的报表文件一样，先创建excel文件(HSSFWorkbook)，然后创建一个工作页(HSSFSheet)，然后找到哪一行(Row)，在哪一列上创建一个单元格(Cell)。你在excel中操作的最小单位都是Cell，所以我们进行读取和操作的最小单位也是Cell。</p>
<p>嗯，如果你还喜欢猜测，为什么猜测了？因为这几个类都是HSSF开头，那么是不是后面的就是他们的父类，而这些HSSF开头的都是他们的实现了。答案是的。<!--你没猜错，就是具体的实现类，我们为啥用实现来操作，而不是面向接口编程，建议在正式实现的时候用面向接口编程。而我这里就不那么严格了。--></p>
<p>开始编程前，请记住，你再操作excel的一个步骤，写代码的时候流程也是这样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建 excel workbook</span></span><br><span class="line">HSSFWorkbook hssfWorkbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line"><span class="comment">//创建工作簿 sheet</span></span><br><span class="line">HSSFSheet hssfSheet = hssfWorkbook.createSheet();</span><br><span class="line"><span class="comment">//找到需要操作的行row,从第0行开始。我们在excel中看到的行是从1开始数，但是在poi中是从0开始。</span></span><br><span class="line"><span class="keyword">int</span> rowNum = <span class="number">0</span>;</span><br><span class="line">Row row1 = hssfSheet.createRow(rowNum);</span><br><span class="line"><span class="comment">//创建单元格cell</span></span><br><span class="line"><span class="keyword">int</span> colNum = <span class="number">0</span>;</span><br><span class="line">Cell row1Col1 = row1.createCell(colNum);</span><br><span class="line"><span class="comment">//操作单元格内容</span></span><br><span class="line">row1Col1.setCellValue(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">// 导出excel文件</span></span><br><span class="line">FileOutputStream fout = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    fout = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.xsl&quot;</span>);</span><br><span class="line">    hssfWorkbook.write(fout);</span><br><span class="line">    fout.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一个简单的单元格内容操作就完成了。</p>
<h3 id="多变的需求"><a href="#多变的需求" class="headerlink" title="多变的需求"></a>多变的需求</h3><p>很多时候我们会有一些特殊的要求，比如文字居中，多行合并，多列合并，加底色，文字颜色等等。。</p>
<p>用的最多的就是文字居中了，这类需求往往都是对于一个单元格有相应要求，POI针对这种需求有一个类：<code>Style</code>。用style来设置单元格的相关样式，下面来看一个文本居中的样式代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HSSFCellStyle style = excel.createCellStyle();</span><br><span class="line">style.setAlignment(CellStyle.ALIGN_CENTER);</span><br><span class="line">row1Col1.setCellStyle(style);<span class="comment">//内容居中显示</span></span><br></pre></td></tr></table></figure>

<p>我们在进行合并的时候，其实实际上合并的还是单元格。所以我们在创建单元格的时候进行一些单元格范围参数设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单元格范围 参数（int firstRow, int lastRow, int firstCol, int lastCol)</span></span><br><span class="line">CellRangeAddress cellRangeAddress = <span class="keyword">new</span> CellRangeAddress(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//在sheet里增加合并单元格</span></span><br><span class="line">hssfSheet.addMergedRegion(cellRangeAddress);</span><br><span class="line"><span class="comment">//生成第一行</span></span><br><span class="line">Row row = hssfSheet.createRow(<span class="number">0</span>);</span><br><span class="line">Cell first = row.createCell(<span class="number">0</span>);</span><br><span class="line">first.setCellValue(<span class="string">&quot;表头&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此时被合并的行的其中的单元格都将无效，也就是说再操作这些被合并的单元格都已经不再称为单元格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单元格范围 参数（int firstRow, int lastRow, int firstCol, int lastCol)</span></span><br><span class="line">CellRangeAddress cellRangeAddress = <span class="keyword">new</span> CellRangeAddress(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//在sheet里增加合并单元格</span></span><br><span class="line">hssfSheet.addMergedRegion(cellRangeAddress);</span><br><span class="line"><span class="comment">//生成第一行</span></span><br><span class="line">Row row = hssfSheet.createRow(<span class="number">0</span>);</span><br><span class="line">Cell first = row.createCell(<span class="number">0</span>);</span><br><span class="line">first.setCellValue(<span class="string">&quot;first&quot;</span>);</span><br><span class="line"><span class="comment">//操作被合并的单元格</span></span><br><span class="line">Row row2 = hssfSheet.createRow(<span class="number">1</span>);</span><br><span class="line">Cell second = row2.createCell(<span class="number">0</span>);</span><br><span class="line">second.setCellValue(<span class="string">&quot;second&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>像上述代码，second不会输出到excel，因为它的所在单元格(1,0)已经被合并了。</p>
<p>通常我们都会自己写一些工具类，然后进行操作excel操作，你也可以试着自己写一个。我这里就不贴我的代码了。</p>
<p>纸上得来终觉浅，绝知此事要躬行</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java HashMap</title>
    <url>/2021/03/25/java-map-hashmap-concurrenthashmap/</url>
    <content><![CDATA[<h1 id="HashMap-介绍"><a href="#HashMap-介绍" class="headerlink" title="HashMap 介绍"></a>HashMap 介绍</h1><p>这个该怎么写了？其实网上好多博客说了这个，其实我看了之后，甚至看了源码之后我也不知道怎么写，源码中Hashmap的介绍大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hashmap 大致是等于hashtable的，除了非同步和允许null值之外；</span><br><span class="line">不保证数据的顺序；</span><br><span class="line">常数级别的get和put；</span><br><span class="line">最重要性能的两个属性： capacity  ， loadfactor</span><br><span class="line">0.75的加载因子数是一种空间和时间上的tradeoff（平衡）</span><br><span class="line">相同的hashcode()会降低它的性能</span><br><span class="line">hashmap的实现是非同步的；</span><br><span class="line">iterator fail-fast ConcurrentModificationException.</span><br></pre></td></tr></table></figure>
<p>首先我们介绍下它的内部数据结构吧。</p>
<h2 id="HashMap的内部结构"><a href="#HashMap的内部结构" class="headerlink" title="HashMap的内部结构"></a>HashMap的内部结构</h2><span id="more"></span>
<p>Hashmap 是由<code>Node&lt;K,V&gt;[] table</code>和链表组成的结构，数组被分为一个个的桶（bucket），通过 hash 值在这个桶上进行寻址。hash 值相同的键值对就以链表的形式存储，如果链表的大小超过 <code>TREEIFY_THRESHOLD=8</code>就会将链表进行树化。</p>
<p><img src="/images/qiniu/2020-03-26-22-27-21.png" alt="2020-03-26-22-27-21"></p>
<p>接下来我们看看它的一个初始化方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 new 一个 hashmap 的时候会发现，<code>Node&lt;K,V&gt;[] table;</code> table 就没有设值。</p>
<p>然后我么来看一个 put 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">// 开始进行resize()保证桶的容量； </span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">//i = (n - 1) &amp; hash 是不是最后一个桶，并且为null</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="comment">//直接加到tab后面</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// 进行树化</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>总的一个put流程大致就是： 初始化或者 resize() 扩容和树化；</p>
<p>现在我们看看 resize() 方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;<span class="comment">//threshold=capacity * load factor</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//是否超过最大值 MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 2 的 30 次方</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//两倍扩容</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">       <span class="comment">// 桶的容量默认值： DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4； 默认值 16；</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">       <span class="comment">// 桶扩容的阀值：</span></span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//设置扩容的阀值</span></span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">       <span class="comment">//如果原来的桶中不为null，扩容后要把桶中的数据迁移到新桶中。</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      <span class="comment">// 会讲原来的一个链条打散成两条链</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           <span class="comment">//这里也就是会在高并发下导致hashmap出现问题的原因</span></span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">//这里的 e.hash &amp; oldCap ==0 可以有效避免重复计算hash值，而且把原来的桶中重复的值分散到新的桶中。</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>看完 resize 就会发现发现它做了很多事，初始化，扩容，数据复制；数据复制也会造成一定的开销。<br>另外resize中的防止rehash并且分散之前的冲突节点的算法也很巧妙：<br><img src="/images/qiniu/2020-03-27-23-13-43.png" alt="2020-03-27-23-13-43"></p>
<p>另外我们看下树化：<code>treeifyBin(tab, hash);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="comment">//如果是空桶或者桶里面的数据少于 MIN_TREEIFY_CAPACITY = 64;只是简单扩容就行了。</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                   hd = p;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>所以可以看到 HashMap 的 <code>LOAD_FACTOR</code> 加载因子和容量是多么的重要了。我们一般的化可以优化为：<br><code>负载因子 * 容量 &gt; 元素数量</code> 即初始化容量时候，值要大于“预估元素数量 / 负载因子” </p>
<p>hashmap在高并发场景下会发生什么了？<br>要记住，hashmap本身就被声明为了非同步安全的类，如果在多线程环境下是会有可能导致无限循环占用cpu，size不准确，具体的原因可以看下这篇博客 <a href="https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html">a beatiful race condition</a></p>
<p>那么问一下，为什么要进行树化了？<br>本质上是个安全问题，如果一个对象hash冲突，都被放到一个桶里面，就会形成一个链表，链表的查询是线性的，就会严重影响存储的性能；<br>另外有种安全攻击叫做“哈希碰撞拒绝服务攻击”，就是构建哈希冲突的数据，恶意代码用这些数据与服务器进行交互，导致服务端cpu大量占用。来达到攻击的目录。</p>
<p>那么，并发下，我们应该怎么使用HashMap了？<br>明天讲～</p>
<!--

但是假如你在面试，面试官会怎么问你了？

咳咳，模拟下：

Q：你好，请问你们平常用的jdk版本是多少？
A：线上主要用的是jdk8
Q：那你能介绍下常见的这个HashMap吗？
A：balabla 上面一大段
Q：1.8中对hashmap有什么优化了？
A：在数据存储中引入了树化，在数据超过8的时候就会变成红黑树。
Q：为什么要引入树来做存储了？有什么好处了？
Q: 能不能介绍下hashmap put的整个过程？
Q: 能不能介绍下hashmap的使用场景？
Q：高并发的场景下应该怎么办了？ 





## 这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题？

## 这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off （要什么不要什么）是什么

## 这个技术适用的场景（技术场景或业务场景）

## 这个技术的组成部分和关键点（核心思想，核心组件）

## 这个技术的底层原理和关键实现

## 已有的实现和它之间的对比
https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6423457

-->


<p>参考：<a href="https://www.cnblogs.com/Michaelwjw/p/6411176.html">https://www.cnblogs.com/Michaelwjw/p/6411176.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 特殊字段脱敏</title>
    <url>/2017/08/19/java-sensitive/</url>
    <content><![CDATA[<h2 id="利用Java给敏感字段脱敏"><a href="#利用Java给敏感字段脱敏" class="headerlink" title="利用Java给敏感字段脱敏"></a>利用Java给敏感字段脱敏</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>客户信息中,有敏感字段比如身份证,银行卡,手机号码等字段要进行脱敏处理(加星号).</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><span id="more"></span>
<p>想实现一个工具类调用<code>XxxUtils.maskObject(obj)</code>;就可以实现脱敏,过程中想到的是用反射,然后给需要脱敏的字段加上注解.可能有需求要将星号变成美元符号,手机号码保留前3位与后四位,身份证保留前后,各一位,所以考虑在注解<code>@Sensitive</code>中加入3属性<code>sensitiveChar</code>替换字符,<code>prefixLength</code>前缀预留长度,<code>suffixLength</code>后缀预留长度;之后再<code>maskObject()</code>方法中进行反射之后将值进行脱敏处理.</p>
<p>定义的<code>Sensitive</code>注解:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Sensitive</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否打码,默认为true</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean mask() default true;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前缀预留位数</span><br><span class="line">     *</span><br><span class="line">     * 比如:</span><br><span class="line">     *          prefixLength&#x3D;3</span><br><span class="line">     *</span><br><span class="line">     *          private String idCard&#x3D;&quot;41234560987123543&quot;</span><br><span class="line">     *</span><br><span class="line">     *          打码后为: idCard&#x3D; 412**************</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int prefixLength() default 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后缀预留位数</span><br><span class="line">     *</span><br><span class="line">     * 比如:</span><br><span class="line">     *          suffixLength&#x3D;3</span><br><span class="line">     *</span><br><span class="line">     *          private String idCard&#x3D;&quot;41234560987123543&quot;</span><br><span class="line">     *</span><br><span class="line">     *          打码后为: idCard&#x3D; **************543</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int suffixLength() default 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 敏感字符替换字符</span><br><span class="line">     *</span><br><span class="line">     * 比如:</span><br><span class="line">     *          sensitiveChar&#x3D;&quot;$&quot;,(suffixLength&#x3D;3);</span><br><span class="line">     *</span><br><span class="line">     *          private String idCard&#x3D;&quot;41234560987123543&quot;</span><br><span class="line">     *</span><br><span class="line">     *          打码后为: idCard&#x3D; $$$$$$$$$$$$$$543</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String sensitiveChar() default &quot;*&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Sensitive</code>主要为类的属性进行描叙,方便我们反射的时候获取预留信息.</p>
<p>定义的反射工具类<code>MaskUtils</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * @author chen</span><br><span class="line"> * @version V1.0</span><br><span class="line"> * @date 2017&#x2F;8&#x2F;17</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final class MaskUtils</span><br><span class="line">&#123;</span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(MaskUtils.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * List&lt;object&gt; 打码</span><br><span class="line">     *</span><br><span class="line">     * @param obj</span><br><span class="line">     * @param &lt;E&gt;</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InstantiationException</span><br><span class="line">     * @throws IllegalAccessException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;E&gt; List&lt;E&gt; maskListObject(List&lt;E&gt; obj) throws InstantiationException, IllegalAccessException</span><br><span class="line">    &#123;</span><br><span class="line">        if(null &#x3D;&#x3D; obj || obj.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;E&gt; maskList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for(E e : obj)</span><br><span class="line">        &#123;</span><br><span class="line">            maskObject(e);</span><br><span class="line">            maskList.add(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return maskList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打码</span><br><span class="line">     *</span><br><span class="line">     * @param obj</span><br><span class="line">     * @param &lt;E&gt;</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IllegalAccessException</span><br><span class="line">     * @throws InstantiationException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static &lt;E&gt; E maskObject(E obj)</span><br><span class="line">    &#123;</span><br><span class="line">        logger.info(&quot;打码前:&#123;&#125;&quot;, JsonUtil.toJSONString(obj));</span><br><span class="line">        if(null &#x3D;&#x3D; obj)</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Class aClass &#x3D; obj.getClass();</span><br><span class="line">        Field[] declaredFields &#x3D; aClass.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        for(Field field : declaredFields)</span><br><span class="line">        &#123;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            Sensitive annotation &#x3D; field.getAnnotation(Sensitive.class);</span><br><span class="line">            if(null &#x3D;&#x3D; annotation || !field.getType().equals(String.class))</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(annotation.mask())</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                String value &#x3D; null;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    value &#x3D; (String)field.get(obj);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IllegalAccessException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                if(StringUtils.isEmpty(value))</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                int suffix &#x3D; annotation.suffixLength();</span><br><span class="line">                int prefix &#x3D; annotation.prefixLength();</span><br><span class="line">                String character &#x3D; annotation.sensitiveChar();</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    field.set(obj,</span><br><span class="line">                              maskString(value, produceCharacter(value.length() - prefix - suffix, character), prefix,</span><br><span class="line">                                         suffix));</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IllegalAccessException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;打码后:&#123;&#125;&quot;, JsonUtil.toJSONString(obj));</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String maskString(String id, String replacement, int prefix, int suffix)</span><br><span class="line">    &#123;</span><br><span class="line">        if(null &#x3D;&#x3D; id || &quot;&quot;.equals(id))</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String value &#x3D; id.replace(id.substring(prefix, id.length() - suffix), replacement);</span><br><span class="line"></span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String maskPhone(String mobilePhone)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        return maskString(mobilePhone, &quot;*&quot;, 3, 4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String produceCharacter(int len, String character)</span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb &#x3D; sb.append(character);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MaskUtils()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>工具类里面抛出两个异常,其实可以查看到是不会出现异常的情况的.</p>
<p>测试类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class User&#123;</span><br><span class="line">    </span><br><span class="line">    @Sensitive(prefixLength &#x3D; 3, suffixLength &#x3D; 4)</span><br><span class="line">    private String userPhone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User user &#x3D; new User;</span><br><span class="line">user.setUserPhone(&quot;13823456789&quot;);</span><br><span class="line">MaskUtils.maskObject(user);</span><br><span class="line">&#x2F;&#x2F;userPhone:138****6789</span><br></pre></td></tr></table></figure>

<p>其实Java反射这样用着还是不错的,第一次尝试自己造轮子. 于是当我第一次把轮子给我的小伙伴的时候,他直接怼了我一句:花了一下午搞定这个,你直接重写toString不久可以了?…….</p>
<p>WTF, 还有这种操作?????????</p>
<p>但是后来仔细想想,他的这种可能侵入就很大了,比如我的类toString是输出类的原始信息,按照他这样,那我怎么获取类原始信息.另外每一个类里面都要去这样写,我这种懒人不太适合.<br>所以~~~~,我就喜欢造轮子.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>查漏补缺 Java 系列 - String，StringBuffer，StringBuilder有什么区别</title>
    <url>/2021/03/18/java-string-stringbuffer-stringbuilder/</url>
    <content><![CDATA[<h1 id="查漏补缺-Java-系列-String，StringBuffer，StringBuilder有什么区别"><a href="#查漏补缺-Java-系列-String，StringBuffer，StringBuilder有什么区别" class="headerlink" title="查漏补缺 Java 系列 - String，StringBuffer，StringBuilder有什么区别"></a>查漏补缺 Java 系列 - String，StringBuffer，StringBuilder有什么区别</h1><h2 id="String，StringBuffer，StringBuilder-他们三者的优势和劣势？"><a href="#String，StringBuffer，StringBuilder-他们三者的优势和劣势？" class="headerlink" title="String，StringBuffer，StringBuilder 他们三者的优势和劣势？"></a>String，StringBuffer，StringBuilder 他们三者的优势和劣势？</h2><p>一般来说，Java中String是用来对字符串进行操作的类，是一个 Immutable 类，它是被声明为final class，所有的属性也是final的；String中的所有跟字符串修改的方法都是新建了一个String，就会产生很多额外的String对象；</p>
<p>StringBuffer是一个线程安全的类，它的所有方法都加上了synchronized; StringBuffer还有个优点就是它在执行append的操作的时候将新的字符串插入到原来的串中，可能是末尾，也可能是中间位置；</p>
<p>StringBuilder 是 Java 1.5 中新增的，它可以看成是StringBuffer的非线程安全实现版本。</p>
<span id="more"></span>
<h2 id="String，StringBuffer，StringBuilder-三者的使用场景？"><a href="#String，StringBuffer，StringBuilder-三者的使用场景？" class="headerlink" title="String，StringBuffer，StringBuilder 三者的使用场景？"></a>String，StringBuffer，StringBuilder 三者的使用场景？</h2><p>其实在jdk9开始，如果我们javap String相关的源码会发现，不再有之前的StringBuilder出现了。这是因为在新的jdk9中，采用了一种新的方式：COMPACT_STRINGS 。底层的数据结构用的是 一个bytes数组+coder的方式组建String的内容，用coder来判断是用LATIN1,UTF16。那么很明显了。<br>如果你在jdk8里面，需要线程同步安全的化，可以使用StringBuffer；如果涉及到大量的String操作，可以考虑使用StringBuilder；但是我认为这个还是要根据编码来，编码首先是给人看的，一定要保证可读性。比如下列的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">&quot;abc&quot;</span>).append(<span class="string">&quot;def&quot;</span>);<span class="comment">//如果很长了？</span></span><br><span class="line"></span><br><span class="line">String abcdeft=<span class="string">&quot;abc&quot;</span>+<span class="string">&quot;def&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="三者的关键组成部分和关键点？"><a href="#三者的关键组成部分和关键点？" class="headerlink" title="三者的关键组成部分和关键点？"></a>三者的关键组成部分和关键点？</h2><blockquote>
<p>ps: jdk8中用的是数组char；jdk9+中用的是数组byte；</p>
</blockquote>
<h2 id="三者的底层原理和关键实践"><a href="#三者的底层原理和关键实践" class="headerlink" title="三者的底层原理和关键实践"></a>三者的底层原理和关键实践</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java-基础之string</title>
    <url>/2017/08/08/java-string/</url>
    <content><![CDATA[<h2 id="Java-基础-String"><a href="#Java-基础-String" class="headerlink" title="Java 基础-String"></a>Java 基础-String</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The class String includes methods for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings, and for creating a copy of a string with all characters translated to uppercase or to lowercase. Case mapping is based on the Unicode Standard version specified by the Character class.</span><br><span class="line"></span><br><span class="line">&#96;String&#96;类包括了一系列字符的方法，比如：比较字符，查找字符，子字符串，创建一个全是大写或者全是小写的字符。匹配是在unicode标准版本规范在&#96;Character&#96; 类的基础上。</span><br><span class="line"></span><br><span class="line">The Java language provides special support for the string concatenation operator ( + ), and for conversion of other objects to strings. String concatenation is implemented through the StringBuilder(or StringBuffer) class and its append method. String conversions are implemented through the method toString, defined by Object and inherited by all classes in Java. For additional information on string concatenation and conversion, see Gosling, Joy, and Steele, The Java Language Specification.</span><br><span class="line"></span><br><span class="line">Java语言提供了对字符的操作符&#96;+&#96;做了特殊的支持,并且对其他的objects转换成string也做了相应支持。String的连接是StringBuilder(或者说StringBuffer)来实现的它的append方法的。String转换是通过实现定义在Object(所有的java方法都继承了它)的toString方法。更多的额外的字符操作和转换的特殊操作，看看gosling，joy，steele，写的《java语言规范》。</span><br><span class="line"></span><br><span class="line">Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown.</span><br><span class="line"></span><br><span class="line">除非有额外的标记，传递一个null参数给一个构造方法或者非构造方法在这个类中，会导致&#96;NullPointerException&#96;被抛出。</span><br><span class="line"></span><br><span class="line">A String represents a string in the UTF-16 format in which supplementary characters are represented by surrogate pairs (see the section Unicode Character Representations in the Character class for more information). Index values refer to char code units, so a supplementary character uses two positions in a String.</span><br><span class="line"></span><br><span class="line">一个String呈现的字符串是用UTF-16格式，不够的补位。</span><br><span class="line"></span><br><span class="line">The String class provides methods for dealing with Unicode code points (i.e., characters), in addition to those for dealing with Unicode code units (i.e., char values).</span><br><span class="line"></span><br><span class="line">这个String类提供方法处理Unicode代码点和unicode代码单元。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>上面是摘抄自<code>String</code>类的介绍，翻译的地方有些不是特别理解。</p>
<h3 id="String-父类"><a href="#String-父类" class="headerlink" title="String 父类"></a>String 父类</h3><p><code>String</code>继承自Object,实现Serializable, CharSequence, Comparable<String><br>重写了Object的toString，equals,hashCode方法;实现了compareTo</p>
<p>hashCode方法重写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Returns a hash code for this string. The hash code for a</span><br><span class="line"> * &#123;@code String&#125; object is computed as</span><br><span class="line"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line"> * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span><br><span class="line"> * &lt;&#x2F;pre&gt;&lt;&#x2F;blockquote&gt;</span><br><span class="line"> * using &#123;@code int&#125; arithmetic, where &#123;@code s[i]&#125; is the</span><br><span class="line"> * &lt;i&gt;i&lt;&#x2F;i&gt;th character of the string, &#123;@code n&#125; is the length of</span><br><span class="line"> * the string, and &#123;@code ^&#125; indicates exponentiation.</span><br><span class="line"> * (The hash value of the empty string is zero.)</span><br><span class="line"> *</span><br><span class="line"> * @return  a hash code value for this object.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h &#x3D; hash;</span><br><span class="line">    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] &#x3D; value;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            h &#x3D; 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash &#x3D; h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到String重写了hashCode方法，计算规则中n为长度。i为坐标就是index.表明如果是空字符串那么hash值为0。hashCode中是31的幂次方。为什么是31不是其他的数，貌似有人说是2的5次方-1，也有说是可以稍微大点的质数都可以。</p>
<p>重写了equals方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Compares this string to the specified object.  The result is &#123;@code</span><br><span class="line">* true&#125; if and only if the argument is not &#123;@code null&#125; and is a &#123;@code</span><br><span class="line">* String&#125; object that represents the same sequence of characters as this</span><br><span class="line">* object.</span><br><span class="line">*</span><br><span class="line">* @param  anObject</span><br><span class="line">*         The object to compare this &#123;@code String&#125; against</span><br><span class="line">*</span><br><span class="line">* @return  &#123;@code true&#125; if the given object represents a &#123;@code String&#125;</span><br><span class="line">*          equivalent to this string, &#123;@code false&#125; otherwise</span><br><span class="line">*</span><br><span class="line">* @see  #compareTo(String)</span><br><span class="line">* @see  #equalsIgnoreCase(String)</span><br><span class="line">*&#x2F;</span><br><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">  if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (anObject instanceof String) &#123;</span><br><span class="line">      String anotherString &#x3D; (String)anObject;</span><br><span class="line">      int n &#x3D; value.length;</span><br><span class="line">      if (n &#x3D;&#x3D; anotherString.value.length) &#123;</span><br><span class="line">          char v1[] &#x3D; value;</span><br><span class="line">          char v2[] &#x3D; anotherString.value;</span><br><span class="line">          int i &#x3D; 0;</span><br><span class="line">          while (n-- !&#x3D; 0) &#123;</span><br><span class="line">              if (v1[i] !&#x3D; v2[i])</span><br><span class="line">                  return false;</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>equals方法中先看到<code>this==anObject</code>,effective里面有说过重写对象的equal方法的几个注意点。在String中String也重写了equals方法，所以比较字符串是否相等的时候一般都要使用equals方法。</p>
<p>String也实现了compareTo:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Compares two strings lexicographically.</span><br><span class="line"> * The comparison is based on the Unicode value of each character in</span><br><span class="line"> * the strings. The character sequence represented by this</span><br><span class="line"> * &#123;@code String&#125; object is compared lexicographically to the</span><br><span class="line"> * character sequence represented by the argument string. The result is</span><br><span class="line"> * a negative integer if this &#123;@code String&#125; object</span><br><span class="line"> * lexicographically precedes the argument string. The result is a</span><br><span class="line"> * positive integer if this &#123;@code String&#125; object lexicographically</span><br><span class="line"> * follows the argument string. The result is zero if the strings</span><br><span class="line"> * are equal; &#123;@code compareTo&#125; returns &#123;@code 0&#125; exactly when</span><br><span class="line"> * the &#123;@link #equals(Object)&#125; method would return &#123;@code true&#125;.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * This is the definition of lexicographic ordering. If two strings are</span><br><span class="line"> * different, then either they have different characters at some index</span><br><span class="line"> * that is a valid index for both strings, or their lengths are different,</span><br><span class="line"> * or both. If they have different characters at one or more index</span><br><span class="line"> * positions, let &lt;i&gt;k&lt;&#x2F;i&gt; be the smallest such index; then the string</span><br><span class="line"> * whose character at position &lt;i&gt;k&lt;&#x2F;i&gt; has the smaller value, as</span><br><span class="line"> * determined by using the &lt; operator, lexicographically precedes the</span><br><span class="line"> * other string. In this case, &#123;@code compareTo&#125; returns the</span><br><span class="line"> * difference of the two character values at position &#123;@code k&#125; in</span><br><span class="line"> * the two string -- that is, the value:</span><br><span class="line"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line"> * this.charAt(k)-anotherString.charAt(k)</span><br><span class="line"> * &lt;&#x2F;pre&gt;&lt;&#x2F;blockquote&gt;</span><br><span class="line"> * If there is no index position at which they differ, then the shorter</span><br><span class="line"> * string lexicographically precedes the longer string. In this case,</span><br><span class="line"> * &#123;@code compareTo&#125; returns the difference of the lengths of the</span><br><span class="line"> * strings -- that is, the value:</span><br><span class="line"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line"> * this.length()-anotherString.length()</span><br><span class="line"> * &lt;&#x2F;pre&gt;&lt;&#x2F;blockquote&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param   anotherString   the &#123;@code String&#125; to be compared.</span><br><span class="line"> * @return  the value &#123;@code 0&#125; if the argument string is equal to</span><br><span class="line"> *          this string; a value less than &#123;@code 0&#125; if this string</span><br><span class="line"> *          is lexicographically less than the string argument; and a</span><br><span class="line"> *          value greater than &#123;@code 0&#125; if this string is</span><br><span class="line"> *          lexicographically greater than the string argument.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int compareTo(String anotherString) &#123;</span><br><span class="line">    int len1 &#x3D; value.length;</span><br><span class="line">    int len2 &#x3D; anotherString.value.length;</span><br><span class="line">    int lim &#x3D; Math.min(len1, len2);</span><br><span class="line">    char v1[] &#x3D; value;</span><br><span class="line">    char v2[] &#x3D; anotherString.value;</span><br><span class="line"></span><br><span class="line">    int k &#x3D; 0;</span><br><span class="line">    while (k &lt; lim) &#123;</span><br><span class="line">        char c1 &#x3D; v1[k];</span><br><span class="line">        char c2 &#x3D; v2[k];</span><br><span class="line">        if (c1 !&#x3D; c2) &#123;</span><br><span class="line">            return c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len1 - len2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到hashCode，equals，compareTo 中都有提到value？那么value是什么？稍后看。现在回到compareTo,它是Comparable接口中唯一一个方法，约定俗成的方式是如果大返回1，如果等于返回0，如果小于返回-1。实现Comparable接口还有一个好处可以在集合中排序。</p>
<p>其中我们讲到<code>value</code>，看到String类中value的定义是:<code>private final char value[];</code>这说明我们的String类其实底层的实现也是char,这也是为啥String不属于基础类型的一个原因吧,但是语言开发者考虑到String用的比较多所以也做了很多特殊的处理.</p>
<h3 id="final-可变不可变"><a href="#final-可变不可变" class="headerlink" title="final ,可变不可变"></a>final ,可变不可变</h3><p>可以在源码中看到String为定义为final,并且里面的值也是大多定义为final的.定义为final的类是不能被<em>继承</em>的.另外定义为final也就意味着值是不能改变的.既然不能改变值,那么String类其实可以说是安全的. 想想看为啥value不是public而是private,其实这是必须的,因为如果是public那么就可以改变里面的值,记住final是不能改变引用指向的对象,但是对象里面的值还是可以改变的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringMe</span><br><span class="line">&#123;</span><br><span class="line">    public final static char[] aChar &#x3D; new char[]&#123;&#39;1&#39;,&#39;2&#39;,&#39;3&#39;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class StringTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(StringMe.aChar);</span><br><span class="line">        StringMe.aChar[0] &#x3D; 34;</span><br><span class="line">        System.out.println(StringMe.aChar); &#x2F;&#x2F;改变了achar[0]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;StringMe.aChar &#x3D; new char[]&#123;&#39;3&#39;&#125;;&#x2F;&#x2F;编译报错,想改变aChar指向的对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String-特殊点"><a href="#String-特殊点" class="headerlink" title="String 特殊点"></a>String 特殊点</h3><p>常常会见到下面这种情况,面试中常有:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;        String a &#x3D; &quot;a&quot;;</span><br><span class="line">&#x2F;&#x2F;        String a_new &#x3D; new String(&quot;a&quot;);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(a &#x3D;&#x3D; a_new);&#x2F;&#x2F;false</span><br><span class="line">&#x2F;&#x2F;        System.out.println(a.equals(a_new));&#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        String abc &#x3D; &quot;ab&quot; + &quot;c&quot;;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        String abc_new &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(abc &#x3D;&#x3D; abc_new);&#x2F;&#x2F;fasle</span><br><span class="line">&#x2F;&#x2F;        System.out.println(abc.equals(abc_new));&#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        abc_new &#x3D; &quot;abc&quot;;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(abc &#x3D;&#x3D; abc_new);&#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;        System.out.println(abc.equals(abc_new));&#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">        final String ab &#x3D; &quot;ab&quot;;</span><br><span class="line">        String abcd &#x3D; ab + &quot;cd&quot;;</span><br><span class="line">        String abcd_origin &#x3D; &quot;abcd&quot;;</span><br><span class="line">        System.out.println((abcd &#x3D;&#x3D; abcd_origin)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">        final String abcde &#x3D; &quot;abcde&quot;;</span><br><span class="line">        String abcdef &#x3D; abcde + &quot;f&quot;;</span><br><span class="line">        String abcdef_origin &#x3D; new String(&quot;abcdef&quot;);</span><br><span class="line">        System.out.println(abcdef &#x3D;&#x3D; abcdef_origin); &#x2F;&#x2F;false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/encode-java-stringtest.png" alt="String类反编译图片"><br>反编译的图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String ab &#x3D; &quot;ab&quot;;</span><br><span class="line">String cd &#x3D; &quot;cd&quot;;</span><br><span class="line">String abcd1 &#x3D; ab + cd;</span><br><span class="line">String abcd2 &#x3D; &quot;ab&quot; + cd;</span><br><span class="line">String abcd3 &#x3D; ab + &quot;cd&quot;;</span><br><span class="line">String abcd5 &#x3D; &quot;abcd&quot;;</span><br><span class="line">String abcd6 &#x3D; &quot;ab&quot;+&quot;cd&quot;;</span><br><span class="line">System.out.println((abcd1 &#x3D;&#x3D; abcd2)); &#x2F;&#x2F; false</span><br><span class="line">System.out.println((abcd2 &#x3D;&#x3D; abcd3)); &#x2F;&#x2F; false</span><br><span class="line">System.out.println((abcd3 &#x3D;&#x3D; abcd5)); &#x2F;&#x2F; false</span><br><span class="line">System.out.println((abcd5 &#x3D;&#x3D; abcd6)); &#x2F;&#x2F; true</span><br><span class="line">System.out.println((abcd1 &#x3D;&#x3D; abcd5)); &#x2F;&#x2F; false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/encode-java-stringtest2.png" alt="String类反编译图片2"></p>
<p>图中可以看出其实String底层的相加也是用的StringBuild</p>
<p>….未完待续….<br>// 相似点，同类</p>
<p>StringBuilder: 如果不考虑多线程的问题,那么我们就是用Stringbuilder其实在String的底层实现中,也是用的StringBuilder来对字符做操作;</p>
<p>StringBuffer: StringBuffer的所有方法都是同步的,可以看到源码中都有Synchronize关键字.操作字符串的方法基本类似.</p>
<p>// 常用方法<br>indexOf(); 返回第一个匹配的位置,没有匹配返回-1;<br>append();<br>split();split中的”abc”.split(“abc”),会返回”abc”,长度为1;<br>toString();<br>equals();//复写了Object<br>hashCode();//复写了Object<br>trim();去掉两端空格<br>…..</p>
<p>// 是否同步，线程安全</p>
<p>String中的方法是不同步的,但是String是一个final类.final类不能被继承,基本类型的包装类基本都是final的,也就是都不能被继承. 另外记住一个. final修饰的String类, 不是说private String a; 那么a也是final类型的.这是错误的.  如果一个String a = “1234”; a=”1233423”; 这个时候a是重新指向了1233424而不是将原来的值改变了.</p>
<h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><p>今天看到一个方法，intern() 方法返回的是strings pool ，由String类独自管理。字符池一开始是空的。如果要两个string1.intern()==string2.intern(),仅仅只有当两个的equals（Object）相等才行，调用intern()如果在字符池里面有就返回字符池里面的，如果没有就会加入到字符池中，能够保证的是调用此方法，一定会返回在字符串池中的唯一一个值。</p>
<h4 id="String-indexOf"><a href="#String-indexOf" class="headerlink" title="String.indexOf()"></a>String.indexOf()</h4><p>总是觉得String应该是Java里面用的最多的，既然String基于char[]数组，那么多String的一些操作是怎样的？看了下indexOf的源码，然后品味了一下,其实暴露给用户使用的只有indexOf(str),indexOf(str,offSet),两个方法，但是看看源码里面indexOf至少有三个，这个不得不让我们想想：为什么有这么多？而这几个indexOf 在里面的实现都是调用了下面的这个函数<code>indexOf(source,sourceOffset，sourceCount，target，tagetOffset，targetCount)</code>;其实可以看到就是源字符串，目标字符串，以及一些字符串的属性。这里一开始我觉得用四个参数就可以了，sourceCount貌似完全可以自己算出来。:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int indexOf(char[] source, int sourceOffset, int sourceCount,</span><br><span class="line">      char[] target, int targetOffset, int targetCount,</span><br><span class="line">      int fromIndex)</span><br><span class="line">  &#123;</span><br><span class="line">      if(fromIndex &gt;&#x3D; sourceCount)</span><br><span class="line">      &#123; &#x2F;&#x2F; 起始位置大于等于目标字符的长度</span><br><span class="line">          return (targetCount &#x3D;&#x3D; 0 ? sourceCount : -1); &#x2F;&#x2F; 目标字符长度是否为0，true，原来的长度，false，-1</span><br><span class="line">      &#125;</span><br><span class="line">      if(fromIndex &lt; 0)&#x2F;&#x2F; 设置从源字符串哪个位置开始查找</span><br><span class="line">      &#123;</span><br><span class="line">          fromIndex &#x3D; 0;&#x2F;&#x2F; 设置边界</span><br><span class="line">      &#125;</span><br><span class="line">      if(targetCount &#x3D;&#x3D; 0)&#x2F;&#x2F;如果目标字符长度小于0,长度为空</span><br><span class="line">      &#123;</span><br><span class="line">          return fromIndex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      char first &#x3D; target[targetOffset];&#x2F;&#x2F; 第一个查找字符为目标字符偏移量的第一个, 我们使用的时候targetOffset 默认为0</span><br><span class="line">      int max &#x3D; sourceOffset + (sourceCount - targetCount);&#x2F;&#x2F;源字符偏移量+（源字符串长度-目标字符的长度） 最大位置。保证源字符串不越界。</span><br><span class="line"></span><br><span class="line">      for(int i &#x3D; sourceOffset + fromIndex; i &lt;&#x3D; max; i++) &#x2F;&#x2F; sourceOffset 我们看到的也是0，默认设值。fromIndex 为从源字符串哪个位置开始</span><br><span class="line">      &#123;</span><br><span class="line">          &#x2F;* Look for first character. *&#x2F;</span><br><span class="line">          if(source[i] !&#x3D; first)</span><br><span class="line">          &#123;</span><br><span class="line">              while (++i &lt;&#x3D; max &amp;&amp; source[i] !&#x3D; first)&#x2F;&#x2F; 找到一个first字符为值，确定位置</span><br><span class="line">                  ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          &#x2F;* Found first character, now look at the rest of v2 *&#x2F;</span><br><span class="line">          if(i &lt;&#x3D; max)&#x2F;&#x2F;</span><br><span class="line">          &#123;</span><br><span class="line">              int j &#x3D; i + 1;</span><br><span class="line">              int end &#x3D; j + targetCount - 1;&#x2F;&#x2F; 设值找值不超过目标字符串的长度，已经找到第一个位置，所以减1</span><br><span class="line">              for(int k &#x3D; targetOffset + 1; j &lt; end &amp;&amp; source[j] &#x3D;&#x3D; target[k]; j++, k++)</span><br><span class="line">                  &#x2F;&#x2F;k为目标字符串偏移targetOffset之后的第二个字符位置（上一步已经找到第一个），确定字符。</span><br><span class="line">                          &#x2F;&#x2F; 开始找第二个字符，</span><br><span class="line">                  &#x2F;&#x2F; 假设这里是找到的，所以j++, k++ , 如果不是source[j]&#x3D;&#x3D;target[k],那么for跳出，执行外层for</span><br><span class="line">                  ;</span><br><span class="line"></span><br><span class="line">              if(j &#x3D;&#x3D; end)</span><br><span class="line">              &#123;</span><br><span class="line">                  &#x2F;* Found whole string. *&#x2F;</span><br><span class="line">                  return i - sourceOffset;&#x2F;&#x2F; 返回的是偏移量之后的位置</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">      public static void main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">      String no &#x3D; &quot;1234567890&quot;;</span><br><span class="line">      System.out.println(no.length());</span><br><span class="line">      int i &#x3D; no.indexOf(&quot;&quot;,110);</span><br><span class="line">      System.out.println(&quot;i&#x3D;&quot; + i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其实在indexOf这里打个断点，随便启动一个Java带main方法的程序，会发现在执行main之前都会,indexOf会被多次调用,应该是先加载了jdk里面的lib下的jar文件，用idea调试出来是可以看到路径的。</p>
<p>另外看到indexOf的方法级别上是<code>static int indexOf()</code> 非public，private，而是默认的限定符，附一张限定符的图,<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">accesscontrol.html</a></p>
<p><img src="/images/qiniu/2017-09-11-16-13-20.png" alt="2017-09-11-16-13-20"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程随笔</title>
    <url>/2018/03/23/java-thread-guidance/</url>
    <content><![CDATA[<h1 id="Java多线程随笔"><a href="#Java多线程随笔" class="headerlink" title="Java多线程随笔"></a>Java多线程随笔</h1><p>最近匆匆的看了一下多线程的知识，其实在我们现在的系统中，我只在一个地方用了多线程，异步刷缓存的时候使用到了。其它地方并没有使用。这个可能跟公司局限性业务有关系，毕竟大家都听过一句话，20%的人掌握着80%的财富。而我们服务的就是那20%里面的一部分。</p>
<span id="more"></span>

<h2 id="多线程的产生"><a href="#多线程的产生" class="headerlink" title="多线程的产生"></a>多线程的产生</h2><p>硬件的摩尔定律已经被打破了，所以现在多核处理器下使用多线程那是大大的提高效率啊。毕竟5个人同时赚钱，跟5个人轮流赚钱那可不是差的一点半点。所以为了<strong>合理</strong>的利用资源，那必须的挤榨一点机器性能啊。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>多线程未必一定比单线程快，为什么？每个东西都是有正反面的。多线程其实对于计算机来说是一种cpu时间切片。像《java并发编程艺术》里面说的，你在看英文书的时候，如果在某一页遇到不知道的单词，你停下来查字典，查完字典你还得返回去继续读。这个过程中读书，查字典就是两个线程，你就是cpu，你给每个线程一些时间让他们做自己的事情。但是在这个过程中，在你从看书切换到查字典再切换到看书这个过程中，你其实还需要记住看书的位置吧，这种从一件事切换到另一件事再从另一件事切回来，总的有耗费吧？术语称之为<strong>上下文切换</strong>。</p>
<p>减少上下问切换的方式：</p>
<ol>
<li>无锁并发编程。使用hash算法进行数据id取模分段，特定的线程处理不同段的数据</li>
<li>使用cas算法，java的atomic包，cas=compare and swap</li>
<li>使用最少线程，避免创建不必要的线程</li>
<li>使用协程，在单线程里面实现多任务调度，并在单线程里面维持多个任务间的切换。</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁的概念就是有两个线程A，B。线程A，B都需要a,b资源，线程A已经占有了a资源，需要b资源，线程B已经占有了b资源，需要a资源；所以A等待B，B等待A。这样就造成了死锁。这个就是那个著名的哲学家吃饭的问题，5个人，5根筷子，嗯就是这个问题。</p>
<h2 id="线程执行任务"><a href="#线程执行任务" class="headerlink" title="线程执行任务"></a>线程执行任务</h2><ol>
<li><p>runnable接口，不带返回值</p>
</li>
<li><p>Callable接口，返回Future对象</p>
</li>
</ol>
<p>定义任务：实现runnable，重写run方法。一个线程都需要使用Thread.start()进行启动。线程的运行由线程调度器来选择，线程调度机制非确定性的。</p>
<p>callable接口—-&gt;实现call()—-&gt;executorService.submit()—-&gt;Future&lt;—–访问Future的isDone()是否完成</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><code>FixedThreadPool</code>:一次性预先加载线程，限制线程的数量;<br><code>CachedThreadPool</code>:创建与所需数量相同的线程;<br><code>SingleThreadPool</code>:线程数量为1的fixedThreadPool;</p>
<h2 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h2><p>sleep()调用的时候不会释放锁，wait()是会阻塞当前线程同时释放锁。</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>优先级别主要是给线程调度器用，如果同一优先级也是随机的。建议使用<code>MAX_PRIORITY</code>,<code>NORM_PRIORITY</code>,<code>MIN_PRIORITY</code>。</p>
<p>线程让步：yield(),然后相同优先级的其它线程；<br>join()，自己会挂起，让join的线程先完成;</p>
<p>后台线程,在调用start方法之前设置daemon。</p>
<h2 id="java并发包"><a href="#java并发包" class="headerlink" title="java并发包"></a>java并发包</h2><p>java有个juc的并发包。要再仔细看看。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal 类解析</title>
    <url>/2017/09/28/java-thread-local/</url>
    <content><![CDATA[<h2 id="ThreadLocal-类解析"><a href="#ThreadLocal-类解析" class="headerlink" title="ThreadLocal 类解析"></a>ThreadLocal 类解析</h2><h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h3><p>JDK里面关于<code>ThreadLocal</code>的解释就是：它提供一个线程局部变量，很拗口对不对，没错就是这么拗口，所以你用的少，我们都用的少。它其实就是说，在一个类里面，这个类可以被很多线程访问，那么<code>ThreadeLocal</code>给这些线程，每一个分配一个他们自己私有的局部变量。还是拗口对不对？不着急，现在只要知道，它就是给多线程环境下，每个线程分配一个单独的变量。</p>
<h3 id="ThreadLocal-的组成"><a href="#ThreadLocal-的组成" class="headerlink" title="ThreadLocal 的组成"></a>ThreadLocal 的组成</h3><p>我们用idea看看<code>ThreadLocal</code>里面含有什么东西：<br><img src="/images/qiniu/2017-09-29-17-21-04.png" alt="2017-09-29-17-21-04"></p>
<p>初一看貌似挺多的。其实在这个里面它主要实现了一个Map，如果你还记得它是为每个线程分配一个独立的变量，那么也就不难理解，它其实就是往map里面给每个线程设置了一个变量给他们使用。<br>然后看看<code>ThreadLocal</code>，主要就是几个方法：<code>get()</code>,<code>set(T)</code>,<code>initialValue()</code>,<code>remove()</code>，其中<code>initialValue</code>是<code>protected</code>:</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它主要是提醒所有的继承者，它需要初始化值。</p>
<p>然后看看<code>get()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里就可以看到一个事情：get的时候它用到了<code>Thread.currentThread()</code>，然后又用<code>getMap(threade)</code>。为啥会这样？它貌似使用的<code>thread</code>做的键，对么？也就是当前线程。没错，一个<code>map</code>里面它用当前线程做<code>key</code>，然后取到当前<em>线程</em>的value，而不会影响到其它的线程。顺便看下<code>ThreadLocalMap</code>类,看到它是一个<code>static class ThreadLocalMap &#123;&#125;</code>,这是不是就是静态变量唯一了？</p>
<p>其它的set(),remove()就不多说了，肯定也是操作这个map。</p>
<h3 id="ThreadLocal-使用"><a href="#ThreadLocal-使用" class="headerlink" title="ThreadLocal 使用"></a>ThreadLocal 使用</h3><p>讲了一些简单的源码，貌似也没弄明白到底怎么用它，使用它又有什么效果？我们接下来看下实例，我们使用一个序列号生成器来看下实际效果。<br>首先我们定义一个序列号接口，主要用来获取序列号<code>Sequence.java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们写一个生成序列号任务类<code>ClientThread.java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sequence sequence;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(Sequence sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequence = sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; =&gt; &quot;</span> + sequence.getNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在在客户端A我们开启三个任务，首先不用<code>ThreadLocal</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceA</span> <span class="keyword">implements</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        number = number + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> SequenceA();</span><br><span class="line"></span><br><span class="line">        ClientThread t1 = <span class="keyword">new</span> ClientThread(sequence);</span><br><span class="line">        ClientThread t2 = <span class="keyword">new</span> ClientThread(sequence);</span><br><span class="line">        ClientThread t3 = <span class="keyword">new</span> ClientThread(sequence);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台结果为：<br><img src="/images/qiniu/2017-09-29-17-43-38.png" alt="2017-09-29-17-43-38"><br>可以看到每个线程对于number都是直接加的，这和static变量有关，但是我们如果想要每个线程都有单独的属性<code>number</code>了？只对我当前线程可以用，别人都不可以用了？<br>我们加上ThreadLocal看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceB</span> <span class="keyword">implements</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; number = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        number.set(number.get() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> number.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> SequenceB();</span><br><span class="line"></span><br><span class="line">        ClientThread t1 = <span class="keyword">new</span> ClientThread(sequence);</span><br><span class="line">        ClientThread t2 = <span class="keyword">new</span> ClientThread(sequence);</span><br><span class="line">        ClientThread t3 = <span class="keyword">new</span> ClientThread(sequence);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在看下结果:<br><img src="/images/qiniu/2017-09-29-17-46-34.png" alt="2017-09-29-17-46-34"></p>
<p>可以看到<code>number</code>的值在每个线程里面都是单独私有的，线程0不会影响线程1的<code>number</code>值。没错，这就是ThreadLocal了。</p>
<p>参考资料：<br><a href="https://my.oschina.net/xianggao/blog/77232">ThreadLocal 那点事</a><br><a href="http://my.oschina.net/huangyong/blog/159489">ThreadLocal 那点事-黄勇</a><br><a href="https://my.oschina.net/huangyong/blog/159725">ThreadLocal 那点事(续集)</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 事务处理（包括spring事务管理）</title>
    <url>/2018/03/14/java-transaction/</url>
    <content><![CDATA[<h1 id="Java-事务处理（包括spring事务管理）"><a href="#Java-事务处理（包括spring事务管理）" class="headerlink" title="Java 事务处理（包括spring事务管理）"></a>Java 事务处理（包括spring事务管理）</h1><h2 id="JDBC-的事务处理"><a href="#JDBC-的事务处理" class="headerlink" title="JDBC 的事务处理"></a>JDBC 的事务处理</h2><p>Java 中的事务处理有三部分：</p>
<ol>
<li>自动提交模式</li>
<li>事务隔离级别</li>
<li>保护点</li>
</ol>
<p>其实实际上java中的事务处理最终依赖的是各数据库的事务处理实现。如果使用的数据库不支持事务，或者提供的数据库驱动程序没有支持事务，那么也是巧妇难为无米之炊。</p>
<p>事务自动提交的方式有：DML（DML），DDL（create），select 查询后结果集关闭，储存过程执行后。</p>
<p>事务隔离级别有：脏读;不可重复读;幻读。</p>
<p>保护点：部分事务回滚;选择性释放。</p>
<p>DriverManager–&gt; Connection –&gt; Statement –&gt; ResultSet –&gt; ResultSetMetaData。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection connection = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    connection = DriverManager.getConnection(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//将事务的自动提交关系</span></span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    业务逻辑（操作数据库）处理</span></span><br><span class="line"><span class="comment">    doService();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交事务 </span></span><br><span class="line">    connection.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//还原自动提交事务</span></span><br><span class="line">        connection.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//关闭connection</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保护点，就是我们在处理一段逻辑中，不需要全部回滚回滚当前事务，只需要回滚到当前的保护点就好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Connection connection = <span class="keyword">null</span>;</span><br><span class="line">Savepoint savepoint = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    connection = DriverManager.getConnection(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    savepoint = connection.setSavepoint();</span><br><span class="line">    connection.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span>!=connection)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.rollback(savepoint);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Spring-的事务实现与原理"><a href="#Spring-的事务实现与原理" class="headerlink" title="Spring 的事务实现与原理"></a>Spring 的事务实现与原理</h2><p>手受了伤，一个手打字不便。稍等，别忘记了。记录到<br>gtd里面去</p>
<p>今日为2018年3月26日</p>
<p>spring 事务管理有以下一些有点&lt;摘自官网文档16节 Transaction Management&gt;：</p>
<ol>
<li>接口一致性编程模型，适用于Java Transaction API(JTA)，JDBC，Hibernate，Java Persistence API(JPA),Java Data Objects(JDO)</li>
<li>支持声明式事务管理</li>
<li>编程式事务api接口简单</li>
<li>与Spring的数据访问抽象的完美集成</li>
</ol>
<p>第一节还有全局事务管理和本地事务管理。还看到了EJB CMT（Container Managed Transaction）.Spring 事务抽象接口为PlatformTransactionManager接口，这个是用到了策略模式，可以看到传递transactionStatus为参数。<br><a href="/images/qiniu/2018-03-26-20-18-37.png">2018-03-26-20-18-37</a></p>
<p>很多英文没看懂，明天继续啃。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机（一）</title>
    <url>/2017/04/05/java-virtual-machine/</url>
    <content><![CDATA[<h2 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h2><h3 id="Java-运行时数据区"><a href="#Java-运行时数据区" class="headerlink" title="Java 运行时数据区"></a>Java 运行时数据区</h3><p>Java 虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。不同的区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有的则随着线程的启动和结束而建立和销毁。数据区分为5大区域：程序计数器，Java虚拟机栈，本地方法区，Java堆，方法区。</p>
<span id="more"></span>

<p><img src="/images/jvm-data.png"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>内存中较小的一块空间，可以当做是当前线程所执行的字节码的行号指示器。简单点其实应该算是空着着当前线程的下一步操作。Java虚拟机的多线程其实是线程轮流分配执行时间的方式来实现的，意思就是一个处理器在任何一个确定的时间，只会执行一条线程的指令。想想如果线程没执行完，cpu的时间没了，另一个线程占去了cpu，那么下次cpu如何知道当前线程执行到哪里了呢？要解决这个问题，是不是的有个区域必须的保持独立性，不能被非当前线程干扰？所以把程序计数器设置成***<code>线程私有</code><em><strong>，这样就完美解决这个问题了。如果线程执行的是Java方法，计数器就是记录的正在执行的虚拟机字节码指令地址。如果正在执行的是native方法，计数器的值就为空(undefined)。另外非常要注意的点就是程序计数器是</strong></em>唯一一个没有规定任何OutOfMemoryError***。</p>
<h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><p>虚拟机栈也是线程私有的，它的生命周期与线程相同。都跟线程同生共死了，当然虚拟机栈也是<em><strong>线程私有的</strong></em>。虚拟机栈描叙的是java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧，栈帧主要用来存储局部变量表、操作数栈、动态链接、方法出口的信息。每一个方法从调用到完成，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。经常说方法中的局部变量是线程安全的，从这里可以得到解释，局部变量定义在虚拟机栈中，那么它是属于线程私有的，就不会存在多线程中共享变量的情况，所以说局部变量在多线程环境下是线程安全的。栈的局部变量表存放了编译期（注意是<code>编译</code>，不是<code>编辑</code>）可知的各种基本数据类型（boolean,byte,char,short,int,float,long,double)、对象引用和returnAddress类型。<br>局部变量表的最小单位为局部变量空间（slot）。其中64位长度的long和double类型的数据会占用2个局部变量空间。局部变量表所需的内存空间在编译期间就完成分配，进入一个方法需要在栈中分配多大的局部变量空间是完全确定的，运行期间不会改变局部变量表的大小。<br>Java虚拟机规范中，如果这个区域线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常；如果虚拟机栈可以动态扩展，在扩展期间无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈所发挥的作用比较类型，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。很多Java的源代码中就有这种native方法。此区域也会抛出StackOverFlowError 和 OutOfMemoryError。</p>
<h4 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h4><p>Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。Java堆得唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的重要区域，因此也被称为<code>GC堆</code>（Garbage Collected Heap）堆中还细分为新生代和老年代。Java堆可以处于物理不连续的内存空间中，只要逻辑上是连续的就可以。如果堆中内存完成实例分配，并且堆也无法扩展的时候，将会抛出OutOfMemoryError异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于内存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。该区域除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。按照这一块的存在目的，主要是存储加载的类型信息，常量等信息。这块的回收主要是类型的写在和常量池的回收，回收的效益并不一定会很理想。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 使用 XStream 操作 XML</title>
    <url>/2017/04/21/java-xml-xstream/</url>
    <content><![CDATA[<h2 id="Java-使用-XStream-操作-XML"><a href="#Java-使用-XStream-操作-XML" class="headerlink" title="Java 使用 XStream 操作 XML"></a>Java 使用 XStream 操作 XML</h2><h3 id="XStream-简介"><a href="#XStream-简介" class="headerlink" title="XStream 简介"></a>XStream 简介</h3><p>XML 是一种严格的文本格式，我想大家都是知道的。XStream 的作用主要是操作 XML，当然JDK也有自己的方法来实现，但是今天我们用XStream来操作XML。</p>
<span id="more"></span>

<h3 id="XStream-基本使用"><a href="#XStream-基本使用" class="headerlink" title="XStream 基本使用"></a>XStream 基本使用</h3><p>XStream 可以将 Object 序列化成 XML。如果有包结构，那么序列化成xml的时候节点会带上包名。</p>
<p><code>Student.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czj.student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String major;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望生成的<code>xml</code>的文件为:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Student</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>小王<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">major</span>&gt;</span>英语专业<span class="tag">&lt;/<span class="name">major</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">age</span>&gt;</span>2<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果直接使用XStream来生成xml如下:</p>
<p><code>Main.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czj.student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by alvin on 4/21/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">&quot;小王&quot;</span>,<span class="string">&quot;英语专业&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;小李&quot;</span>,<span class="string">&quot;法学专业&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line">        String xml = xStream.toXML(student);</span><br><span class="line"></span><br><span class="line">        System.out.println(xml);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行后生成:<code>xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.czj.student.Student</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>小王<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">major</span>&gt;</span>英语专业<span class="tag">&lt;/<span class="name">major</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">age</span>&gt;</span>2<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.czj.student.Student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到如果是带有包名的Object(Studen.java)，那么生成的xml节点就会带上包名。这明显就不是我们所需要的XML。那么如何改变了？可以用到Annotation注解的形式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XStreamAlias(&quot;student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给所要改名的节点的类上加上<code>@XStreamAlias(&quot;student&quot;)</code>注解，貌似可以了？其实加上了注解之后，那么XStream怎么知道要取解析注解了？所以我们要指明一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xStream.processAnnotations(Student.class);</span><br></pre></td></tr></table></figure>

<p>所以原来的代码就变成:<code>Student.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czj.student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.annotations.XStreamAlias;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by alvin on 4/21/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@XStreamAlias(&quot;student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String major;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMajor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMajor</span><span class="params">(String major)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String major, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而<code>Main.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czj.student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.XStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by alvin on 4/21/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">&quot;小王&quot;</span>,<span class="string">&quot;英语专业&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line">        xStream.processAnnotations(Student.class);<span class="comment">//开启注解</span></span><br><span class="line">        String xml = xStream.toXML(student);</span><br><span class="line"></span><br><span class="line">        System.out.println(xml);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就能生成我们想要的<code>xml</code>结果了:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>小王<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">major</span>&gt;</span>英语专业<span class="tag">&lt;/<span class="name">major</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">age</span>&gt;</span>2<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="XStream-操作命名空间"><a href="#XStream-操作命名空间" class="headerlink" title="XStream 操作命名空间"></a>XStream 操作命名空间</h3><p>seo中通常要生成站点sitemap.xml.我们尝试去写一个对应的java类:Sitemap.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czj.sitemap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.annotations.XStreamAlias;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.annotations.XStreamAsAttribute;</span><br><span class="line"><span class="keyword">import</span> com.thoughtworks.xstream.annotations.XStreamImplicit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by alvin on 4/21/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@XStreamAlias(value=&quot;urlset&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sitemap</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XStreamImplicit</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Url&gt; url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XStreamImplicit</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ImageUrl&gt; imageUrl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@XStreamAsAttribute</span></span><br><span class="line">    <span class="meta">@XStreamAlias(&quot;xmlns&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String xmlns = <span class="string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XStreamAsAttribute</span></span><br><span class="line">    <span class="meta">@XStreamAlias(&quot;xmlns:image&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String image = <span class="string">&quot;http://www.google.com/schemas/sitemap-image/1.1&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Url&gt; <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(List&lt;Url&gt; url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getXmlns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xmlns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXmlns</span><span class="params">(String xmlns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.xmlns = xmlns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ImageUrl&gt; <span class="title">getImageUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imageUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageUrl</span><span class="params">(List&lt;ImageUrl&gt; imageUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imageUrl = imageUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImage</span><span class="params">(String image)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.image = image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到命名空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">urlset</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span> <span class="attr">xmlns:image</span>=<span class="string">&quot;http://www.google.com/schemas/sitemap-image/1.1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loc</span>&gt;</span>loc0<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">changefreq</span>&gt;</span>changefreq0<span class="tag">&lt;/<span class="name">changefreq</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span>lastmod0<span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">priority</span>&gt;</span>priority0<span class="tag">&lt;/<span class="name">priority</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">urlset</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="XStream-常用注解介绍"><a href="#XStream-常用注解介绍" class="headerlink" title="XStream 常用注解介绍"></a>XStream 常用注解介绍</h3><p><code>@XStreamAlias(value=&quot;urlset&quot;)</code>: 生成的节点别名</p>
<p><code>@XStreamImplicit</code> : 忽略节点生成，常用于List a ，a也是一个节点，而实际上a并不需要。</p>
<p><code>@XStreamAsAttribute     @XStreamAlias(&quot;xmlns&quot;)</code> : 属性，属性别名</p>
<p><strong>千万要记得如果采用注解形式，一定要将<code>xStream.processAnnotations(Student.class);</code>打开，否则无法运用注解</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>XStream</tag>
      </tags>
  </entry>
  <entry>
    <title>java性能优化</title>
    <url>/2018/03/12/java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Java性能优化"><a href="#Java性能优化" class="headerlink" title="Java性能优化"></a>Java性能优化</h1><p>今日在图书馆看java编程思想，看了一下午，就起身到处走走。没想到走到了《java性能优化》这本书这里，本来不想拿起来的，后来想着为啥不去看看呢。就拿起来读了一些感兴趣的章节。<br>前面一章主要讲了一些优化的大纲，已经四个测试。我记得有一个微基准测试。实在无奈，回到家，具体的是那几个测试也忘记了。当时额外看得只有几章，都是挑的感兴趣的读的。有一章讲的是jdbc，又想起之前别人为我的一个问题：spring的事务是怎么实现的？我当时有点懵逼，其实仔细一想，java中链接数据库不就是通过jdbc来操作的么？那我回答jdbc怎么控制事务的是不是就可以了？可那会脑袋一片空，神之尴尬。<br>java性能优化里面也提到了jpa，Java persistence api。谈到对它进行优化的时候，讲了一些点，预处理语句和语句池。比如使用PreparedStatement而不是直接使用Statement。对一些处理也可以进行批处理。jdbc的事务是基于Connection的。事务的隔离模式有，开销从大到小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transaction_Serializable</span><br><span class="line">Transaction_Repeatable_Read</span><br><span class="line">Transaction_Read_Commited</span><br><span class="line">Transaction_read_uncommited</span><br></pre></td></tr></table></figure>

<p>其实这些就是数据的事务隔离级别，当然java里面还有一个<code>NONE</code>。其实这些事务控制还是根据各数据库提供商来控制的。mysql就提供了上面的四种事务隔离级别。事务也会造成一些问题比如：脏读，幻读，不可重复读。</p>
<table>
<thead>
<tr>
<th align="center">事务隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交（read-uncommitted)</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">不可重复读（read-committed）</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">可重复读(repeatable-read)</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">串行化（serializable）</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p>JPA的性能直接受底层jdbc驱动程序的影响，可以尝试减少写入的字段，读取更少的数据或一次读取更多的数据(延时加载)(什么是延时加载？有什么好处？怎么实现？)</p>
<p>事务分为两种：声明式事务管理，编程式事务管理。（spring的事务怎么实现？）</p>
<p>JPA 缓存</p>
<p>缓存分为全局缓存和实体管理器缓存，实体管理器中的缓存通常称为一级缓存L1,全局缓存又称为二级缓存。（spring data jpa中是否也是这样实现？）</p>
<p>实体管理器实例都有自己的缓存，它会在本地缓存事务中取得数据，在本地缓存事务中写入的数据。只有在事务提交时，这些缓存的数据才会发送到数据库。</p>
<p>JPA缓存只在通过逐渐去访问实体的时候才有效。实体管理器通过主键查找数据时，会先从L2缓存中找。</p>
<p>任何时候用流都记得用缓存流。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jenkins对springboot进行CI</title>
    <url>/2017/08/10/jenkins-ci/</url>
    <content><![CDATA[<h2 id="写给小白看的jenkins-CI教程"><a href="#写给小白看的jenkins-CI教程" class="headerlink" title="写给小白看的jenkins CI教程"></a>写给小白看的jenkins CI教程</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>使用jenkins持续部署一个springboot项目,项目使用jar包发布.从安装jenkins的机器将jar包发布到指定的服务器目录,并且使用脚本运行springboot. (<em>前面几张图可能看不见,以后补上</em>)</p>
<h3 id="个人背景"><a href="#个人背景" class="headerlink" title="个人背景"></a>个人背景</h3><p>Java工程师毕业一年,Linux一般熟悉,Java初阶,所以不用担心难度,如果有疑问可以联系我:<code>vbookchen@gmail.com</code></p>
<h3 id="系统环境与准备"><a href="#系统环境与准备" class="headerlink" title="系统环境与准备"></a>系统环境与准备</h3><p><strong>jenkins就是相当于一个web服务,与环境没有太大关系</strong></p>
<ol>
<li><p>Linux/Windows 操作</p>
</li>
<li><p>jenkins.jar/jenkins.msi //安装就是了,其他的是系统可以下载war包在tomcat里面运行</p>
</li>
<li><p>gitlab.com 账号</p>
</li>
<li><p>gitlab 公有仓库放置 spring-boot 源码</p>
</li>
<li><p>maven // 可以用jenkins安装也可以用本地的</p>
</li>
<li><p>JDK 安装jenkins的主机必须要有jdk, docker版本除外</p>
</li>
<li><p>部署服务的Linux服务器</p>
</li>
</ol>
<span id="more"></span> 

<h3 id="基础搭建"><a href="#基础搭建" class="headerlink" title="基础搭建"></a>基础搭建</h3><p>安装好jenkins之后,windows是会在服务里面可以看到一个jenkins服务的.占用端口8080.Linux的没操作过,docker版本的jenkins镜像记得映射本地端口. mac版本应该也是在8080端口,可以看到服务.</p>
<p>登录<code>localhost:8080</code></p>
<p>看到一个初始化页面,页面会提示初始化密码的问题,一串很长的字符:</p>
<p><img src="/images/jenkins/img1.png" alt="初始密码"></p>
<p>输入密码之后会让我们选择安装模式,安装插件,我们选择默认模式:</p>
<p><img src="/images/jenkins/img2.png" alt="插件选择"></p>
<p>稍等一会,根据网速快慢不一样,等待时间不一样,之后选择创建用户密码:</p>
<p><img src="/images/jenkins/img3.png" alt="创建用户"></p>
<p><strong>ps:这里记得选择右边<code>Save And Finish</code>那个,左边的<code>continue as admin</code> 这个时候是没有创建的,默认账号密码为admin/初始密码</strong></p>
<p>安装成功后可以说第一步完成.</p>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>默认安装的插件是没有maven和ssh插件的,所以需要重新安装:</p>
<ol>
<li>安装maven插件,maven integration plugin:</li>
</ol>
<p><img src="/images/jenkins/img4.png" alt="安装maven插件"></p>
<ol start="2">
<li>安装ssh插件,publish over ssh:</li>
</ol>
<p><img src="/images/jenkins/img5.png" alt="安装ssh插件"></p>
<ol start="3">
<li><p>安装git插件,默认的插件安装列表已经安装了</p>
</li>
<li><p>如果插件安装不成功(gfw,国内有时候是这样),可以到<code>系统管理--插件管理--高级--上传插件</code>;插件下载地址:<a href="https://updates.jenkins-ci.org/download/plugins">jenkins插件下载地址</a>,找到对应的插件hpi文件下载后上传就可以了.</p>
</li>
</ol>
<p>安装之后第二步完成</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>配置好基本环境可以省很多时间,看到jenkin主页的左侧有很多选项:</p>
<ol>
<li>配置全局属性,<code>系统管理--&gt;系统设置</code>看到<code>Environment variables</code>,加入LANG=zh_CN.UTF-8,其实可以先去<code>系统管理--&gt;系统信息</code>找到file.encoding,看看属性是不是utf-8.</li>
</ol>
<p><img src="/images/jenkins/img6.png" alt="全局属性"></p>
<ol start="2">
<li>配置ssh信息,<code>系统管理--&gt;Publish over ssh</code> 如果没有<code>publish over ssh</code>那么是第二步中插件没有安装成功.</li>
</ol>
<p><img src="/images/jenkins/img7.png" alt="ssh信息"></p>
<ol start="3">
<li>配置JDK信息,<code>系统管理--&gt;Global Tool Configuration</code>,选中<code>jdk--jdk安装</code></li>
</ol>
<p><img src="/images/jenkins/img8.png" alt="jdk安装"></p>
<ol start="4">
<li>配置maven项目,<code>系统管理--&gt;Global Tool Configuration</code>,选中<code>maven--maven安装</code></li>
</ol>
<p><img src="/images/jenkins/img9.png" alt="maven安装"></p>
<h3 id="新建任务"><a href="#新建任务" class="headerlink" title="新建任务"></a>新建任务</h3><p>基础打好后,开始建楼</p>
<ol>
<li>jenkins主页左边栏:<code>新建</code>建立第一个CI任务.</li>
</ol>
<p><img src="/images/jenkins/img10.png" alt="新建任务"></p>
<ol start="2">
<li>对任务项做相关配置:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a) 任务名称&#x2F;介绍;</span><br><span class="line">b) 源码地址(git&#x2F;svn);</span><br><span class="line">c) 构建触发器;</span><br><span class="line">d) Build;</span><br><span class="line">e) PostSteps; 配置需要将生成的jar包等上传到哪个服务器,执行哪个脚本 ;</span><br><span class="line">f) 保存</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/jenkins/img11.gif" alt="任务项目配置"></p>
<p><strong>更正下配置,maven 构建那里跳过测试,应该是 -Dmaven.test.skip=true  -X</strong></p>
<ol start="3">
<li>成功后的页面:</li>
</ol>
<p><img src="/images/jenkins/img12.png" alt="成功的页面"></p>
<ol start="4">
<li>点击<code>立即构建---build history---console output</code>可以看到构建的输出</li>
</ol>
<p><em>ps 附录一段脚本</em></p>
<p>stop.sh:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#stop.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;Stopping SpringBoot Application&quot;</span><br><span class="line">pid&#x3D;&#96;ps -ef | grep girl-0.0.1-SNAPSHOT.jar | grep -v grep | awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">if [ -n &quot;$pid&quot; ]</span><br><span class="line">then</span><br><span class="line">   kill -9 $pid</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>start.sh:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.141-1.b16.el7_3.x86_64&#x2F;jre</span><br><span class="line">echo $&#123;JAVA_HOME&#125;</span><br><span class="line">echo &quot;start startup girl&quot;</span><br><span class="line">chmod 777 &#x2F;home&#x2F;girl&#x2F;girl-0.0.1-SNAPSHOT.jar</span><br><span class="line">echo &quot;grant right....&quot;</span><br><span class="line">cd &#x2F;home&#x2F;girl&#x2F;</span><br><span class="line">nohup $&#123;JAVA_HOME&#125;&#x2F;bin&#x2F;java -jar girl-0.0.1-SNAPSHOT.jar &gt; &#x2F;home&#x2F;girl&#x2F;server.log &amp;</span><br><span class="line"></span><br><span class="line">whatToFind&#x3D;seconds</span><br><span class="line">function watch()&#123;</span><br><span class="line"> </span><br><span class="line">    tail -1f server.log |</span><br><span class="line"></span><br><span class="line">        while IFS&#x3D; read line</span><br><span class="line">            do</span><br><span class="line">                echo &quot;buffering:&quot; &quot;$line&quot;</span><br><span class="line"></span><br><span class="line">                if [[ &quot;$line&quot; &#x3D;&#x3D; *&quot;$whatToFind&quot;* ]]; then</span><br><span class="line">                    echo $msgAppStarted</span><br><span class="line">                    pkill tail</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line">watch</span><br><span class="line"></span><br><span class="line">echo &quot;start success&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题：jenkin tail -f server.log的时候一直build unstable。 但是又想让控制台输出日志，所以在脚本里面加上一个watch方法，这样就可以查看到日志输出了。然后在jenkin job配置中添加<img src="/images/qiniu/2017-09-08-17-10-37.png" alt="2017-09-08-17-10-37-201798171037"></p>
<p>在执行脚本的时候添加<code>BUILD_ID=dontKillMe</code>;就在kill的时候保证jenkins主进程不被杀掉。</p>
<p> 如果是centos服务器,用的是<code>yum install java</code>安装的Java环境,查找<code>java_home</code>的方法:用<code>ls -al</code>一直找到软连接的真实指定位置:</p>
<p><img src="/images/jenkins/img14.png" alt="查找java_home"></p>
<p><strong>记得要给路径或者脚本赋权限,不然jenkins可能出现</strong><code>nohup: failed to run command java: No such file or directory</code>,<strong>这是没有权限造成的.</strong></p>
]]></content>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins-docker-plugin-error</title>
    <url>/2019/07/24/jenkins-docker-plugin-error/</url>
    <content><![CDATA[<h1 id="Jenkins-Docker-模块无法切换Registry-credentials"><a href="#Jenkins-Docker-模块无法切换Registry-credentials" class="headerlink" title="Jenkins Docker 模块无法切换Registry credentials"></a>Jenkins Docker 模块无法切换Registry credentials</h1><p>问题产生，一次公司Jenkins迁移过程中，发现一个问题，dockers模块选择不同用户的 Registry credentials 但就是无法推送到私有仓库上去。</p>
<p><img src="/images/qiniu/2019-07-24-18-28-43.png" alt="2019-07-24-18-28-43"></p>
<p>像上图一样，选择了用户，deployop 或者其它，但是Jenkins push的时候就是报没有权限：</p>
<p><img src="/images/qiniu/2019-07-24-18-30-05.png" alt="2019-07-24-18-30-05"></p>
<p>就算我选的的是harbor的admin账号也没用。</p>
<p>后来想到jenkins的机器我是都手动执行过<code>docker login</code>的，不知道会不会有影响，于是手动去机器上docker build –&gt; docker push 发现结果一样。也是没有权限。然后用docker login harbor.xxx.com 查看当前用户却不是admin账户，这就有点奇怪了，我当时在jenkins模块docker中选的就是admin啊。为什么docker 还是用之前的权限较小的账户了？然后我在~/.docker/config.json 查看到确实有两个账户，这个可以说明其实Docker 模块的Registry credentials其实际是起到了作用的。应该是我们一开始使用了docker login 所以造成了有”默认账户”。jenkins应该就是使用了默认账户才导致这个问题的。</p>
<p><img src="/images/qiniu/2019-07-24-18-35-44.png" alt="2019-07-24-18-35-44"></p>
<p>解决的方式很简单，一个是删除<code>~/.docker</code>这个文件夹；一个是使用<code>docker logout harbor.xxx.com</code>就可以了。再用Jenkins构建的时候就可以看到该文件内容：</p>
<p><img src="/images/qiniu/2019-07-24-18-39-09.png" alt="2019-07-24-18-39-09"> </p>
<p>如果你是删除了<code>~/.docker</code>文件夹，然后重启docker，那么你再次构建的时候应该会看到<code>~/.docker</code>文件夹变空了。但是在用户目录多出一个<code>~/.dockercfg</code>文件。里面的内容和config.json一致。如果你是使用docker logout，那么就还是会在<code>~/.docker/config.json</code>文件中看到你每次选择的用户。</p>
<p><img src="/images/qiniu/2019-07-24-18-43-39.png" alt="2019-07-24-18-43-39"></p>
<blockquote>
<p>ps 如果想在jenkins启动的时候就指定其工作目录，可以这样设置<code>export JENKINS_HOME=/data/jenkins/.jenkins</code> </p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>随笔20180306</title>
    <url>/2018/03/07/just-write-something/</url>
    <content><![CDATA[<h1 id="随笔20180306"><a href="#随笔20180306" class="headerlink" title="随笔20180306"></a>随笔20180306</h1><p>时间算算是真快啊，确实，转眼毕业快两年了。参加工作已经两年了。很多事情真是感觉像是昨天才发生的一样。<br>这几天静下心来想想自己。每日的计划做的很满，却是非常飘。很多时候我在对各种新技术去了解，去有想法，却忽略了一个很简单的事情，技术的更新特别快，今天有A，明天就有B，如果只是跟着潮流，那么未来的方向是哪里呢？我反思，我这一年里经历了很多，自己也在周末，下班都在弄一些技术相关的新的东西。然而，我却只教会了自己怎么用。没有教会自己为什么。过去的日子已经追不回来，努力的过好当下的日子才是最重要的。2018年立了很多的flag，其实最大的flag就只有一个，那就是-行动。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>klook-508-problem</title>
    <url>/2017/05/08/klook-508-problem/</url>
    <content><![CDATA[<h2 id="5月8日问题"><a href="#5月8日问题" class="headerlink" title="5月8日问题"></a>5月8日问题</h2><h3 id="MySQL二进制运算"><a href="#MySQL二进制运算" class="headerlink" title="MySQL二进制运算:"></a>MySQL二进制运算:</h3><p>mysql可以直接使用位运算。我们现在是否支持多平台<code>platform</code>使用的就是位运算的方式。</p>
<table>
<thead>
<tr>
<th align="center">web</th>
<th align="center">mobile web</th>
<th align="center">ios</th>
<th align="center">Android</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>这种设置的好处是以后扩展起来可以加位就可以了。其实我觉得很蛋疼，可读性真的差，但是想想linux的权限控制系统rwx其实感觉也还可以接受。不过要是位数异常多的话~GG吧。这种其实也有好处，平常设计表中可能需要多条记录，或者用另一个表关联，这种位运算就可以直接在一个表里面做选择了。那么如何操作位运算了？ 只要记着，你想要那个平台，比如<code>web</code>，它就是<code>8</code>，因为它指代的是二进制的<code>1000</code>,如果你想找出支持<code>web</code>平台的记录，那么只要用<code>platform&amp;8</code>那么就可以找出所有<code>web</code>位是<code>1</code>的记录。<code>select * from tbl_aa where platform&amp;8</code> 千万别写成<code>select * from tbl_aa where platform=platform&amp;8</code> 这样的结果，是将platform进行了赋值，将位运算的结果赋值给了platform再去做查找筛选。<span id="more"></span><br>补充一些，位运算还有两个运算符号: 或:<code>|</code> ;异或；<code>^</code>，下面的代码在数据库中会显示成:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 1^4,4^4,4^12,1|4,1&amp;4</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">1^4</th>
<th align="center">4^4</th>
<th align="center">4^12</th>
<th align="center">0^0</th>
<th align="center">1l4</th>
<th align="center">1&amp;4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">8</td>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>所有的数字对于计算机来说都是0101，那么<code>&amp;</code>它认为的就是相同的位子都是1才是1（可以看成是一条河流有两个闸门，只有两个闸门都打开==1，水才能一直流如江河，不会断流），<code>|</code>它只要当有一个1的时候就认为是对的（相当于一个分流闸门，左边可以走，右边可以走，都可以走，走的通就行），<code>^</code>它是只有当两个不相同的时候才为1，相同的时候为0(这就是叫人道理了，凡事不要想着一刀切走极端，凡事有好有坏才是1。哈哈)</p>
<h3 id="MySQL插入的时候max-num-1"><a href="#MySQL插入的时候max-num-1" class="headerlink" title="MySQL插入的时候max(num)+1"></a>MySQL插入的时候max(num)+1</h3><p>遇到了一种情况，就是排序的时候默认是max+1，之前想过一种就是先将max取出来，然后再插入，这种情况就是要先查一次数据库，最近用golang语言做后台开发，没少因为调用多个接口多次访问数据库被前辈们教育。我也知道他们是为我好，所以尝试改动。所以想着能少执行一次SQL就开始写了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into tbl_myname (id,name,priority)</span><br><span class="line">			values (null,?,(</span><br><span class="line">			select case  when max(temp.priority) IS NULL then &#39;1&#39; else max(priority)+1 end from (</span><br><span class="line">			SELECT priority,id FROM tbl_myname</span><br><span class="line">			) temp</span><br><span class="line">			))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select case  when max(temp.priority) IS NULL then &#39;1&#39; else max(priority)+1 end from (</span><br><span class="line">			SELECT priority,id FROM tbl_myname</span><br><span class="line">			) temp</span><br></pre></td></tr></table></figure>
<p>可以看到这里做了两次查询，难道直接<code>select max(priority)+1</code>不行么？还真的不行。 如果不做临时表直接选择<code>max(priority)+1</code>数据库执行的时候将会报错<code>You can&#39;t specify target table &#39;tblmyname&#39; for update in FROM clause</code>。当然这种插入数据库的方式并不推荐，为啥？因为如果高并发的情况下，我相信，肯定会出现priority相同的情况，如果对priority控制的很严的情况那么是不能出现这种情况的。我能想到的是在进入这个方法的时候加锁，尽量避免并发的情况。</p>
<h3 id="golang枚举操作"><a href="#golang枚举操作" class="headerlink" title="golang枚举操作"></a>golang枚举操作</h3><p>golang是没有枚举这种说法的。但是它有一个关键字<code>iota</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Test_enum(t *testing.T) &#123;</span><br><span class="line">	fmt.Println(ALL)</span><br><span class="line">	fmt.Println(th_TH)</span><br><span class="line">	fmt.Println(ko_KR)</span><br><span class="line">	fmt.Println(zh_TW)</span><br><span class="line">	fmt.Println(zh_CN)</span><br><span class="line">	fmt.Println(en_US)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;fmt.Println(ALL|b|c|d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	&#x2F;&#x2F;英语，中文简体，繁体，韩文，泰文,ALL</span><br><span class="line">	ALL   &#x3D; iota &#x2F;&#x2F;0</span><br><span class="line">	th_TH 			&#x2F;&#x2F;1</span><br><span class="line">	ko_KR 			&#x2F;&#x2F;2</span><br><span class="line">	zh_TW&#x3D;&quot;test&quot; &#x2F;&#x2F;3</span><br><span class="line">	zh_CN			&#x2F;&#x2F; 值为test， iota为 4</span><br><span class="line">	en_US&#x3D;iota   &#x2F;&#x2F;5</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用了之后发现，跟我想的不一样。之前在Java里面我可以定义一个value，然后用enum.name()获取名字，就相当于一个key-value键值对，而golang里面貌似这样的做法没有。不知道是是什么原因，不过此路不同总有一条其它的路能通的。</p>
<h3 id="golang-判断是否为数字"><a href="#golang-判断是否为数字" class="headerlink" title="golang 判断是否为数字"></a>golang 判断是否为数字</h3><p>golang里面一开始以为可以直接找一个包或者类来判断传入的字符是否是数字，一开始以为可以用<code>unicode.IsDigit(r rune)</code>,后来发现rune其实是一个unit32类型，byte就是一个unit8类型，我的想法仅仅是一个接口然后直接传入string，看来是不行了。所以就想了个注意，自己写。怎么写？第一个想的就是正则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func isDigit(str string) bool &#123;</span><br><span class="line">	if len(str) &gt; 0 &#123;</span><br><span class="line">		var regexp &#x3D; regexp.MustCompile(&quot;^\\d+$&quot;)</span><br><span class="line"></span><br><span class="line">		matchResult :&#x3D; regexp.MatchString(str)</span><br><span class="line"></span><br><span class="line">		if matchResult &#123;</span><br><span class="line">			return true</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单方便，直接传入string，就能得到想要的值了？以前Java写的顺手，因为很完善，做业务很方便，如今用go，很多东西也不是很熟悉，所以自己动手丰衣足食。</p>
<hr>
<p>ps:今天还看到了Java Integer源码里面一个sizeTable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final static int [] sizeTable &#x3D; &#123; 9, 99, 999, 9999, 99999, 999999, 9999999,</span><br><span class="line">                                      99999999, 999999999, Integer.MAX_VALUE &#125;;</span><br></pre></td></tr></table></figure>
<p>觉得好可爱的写法。哈哈判断位数倒是可以了嘿嘿。</p>
]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>Question</tag>
      </tags>
  </entry>
  <entry>
    <title>klook-607-problem</title>
    <url>/2017/06/07/klook-607-problem/</url>
    <content><![CDATA[<blockquote>
<p>年度问题日结,将今年每天遇到的问题做一个记录: &lt;月.日 问题&gt;</p>
</blockquote>
<h2 id="6-7-问题"><a href="#6-7-问题" class="headerlink" title="6.7 问题"></a>6.7 问题</h2><ol>
<li><p>Hashmap寻找的时间复杂度</p>
<p> hashmap的实现是”数组+链表”的形式，</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 先根据key值计算出hash值以及h值（h值是java实现中处理得到的更优的index索引值）</span><br><span class="line">2. 查找table数组中的h位置，得到相应的键值对链表</span><br><span class="line">3.	根据key值，遍历键值对链表，找到相应的键值对，</span><br><span class="line">4. 从键值对中取出value值。</span><br></pre></td></tr></table></figure></li>
<li><p>Golang 反射将数字转成float64</p>
<p> <code>value.(float64)</code></p>
</li>
<li><p>Golang map判断是否有键值</p>
<p> if val,ok:=map[key];ok{</p>
<pre><code> // 有值
</code></pre>
<p> }</p>
</li>
</ol>
<span id="more"></span>

<h2 id="5-25-问题"><a href="#5-25-问题" class="headerlink" title="5.25 问题"></a>5.25 问题</h2><ol>
<li><p>数据库无记录时插入，有记录时（设置的主键重复）更新</p>
<p> <code>insert into city_th_tbl (id,name_col) values (8,&#39;名字&#39;) on duplicate key update name_col=&#39;名字1&#39;;</code> ，当id=8插入的时候有重复的值的时候，将<code>name_col</code>更新为<code>名字1</code>，只针对于MySQL。</p>
</li>
<li><p>将<code>docker info</code>之后显示的data space 修改大小<code>truncate -s 200G /var/lib/docker/devicemapper/devicemapper/data</code></p>
</li>
<li><p>一键停止所有正在运行的docker容器,<code>docker stop $(docker ps -a -q)</code> ,开启：<code>docker start $(docker ps -a -q) </code></p>
</li>
<li><p><code>grep “查的内容” “文件位置” -C 10</code> ; 使用grep查找的时候把匹配内容的上下10行也显示出来</p>
</li>
</ol>
<!--more-->


<h2 id="5-18-问题"><a href="#5-18-问题" class="headerlink" title="5.18 问题"></a>5.18 问题</h2><ol>
<li><p>查看linux centos 某个软件是否安装</p>
<p> 答案:<code>rpm -qa | grep software</code></p>
</li>
<li><p>启动某个软件</p>
<p> 答案: 设置开机启动<code>sudo systemctl enable docker</code>，设置立即启动<code>sudo systemctl start docker</code></p>
</li>
<li><p>查看系统内核信息 <code>uname -a</code></p>
</li>
<li><p>ubuntu安装软件出错，“Ubuntu unable to locate package”</p>
<p> 答案 `先更新 apt-get update ;</p>
<pre><code>  之后 apt-get upgrade`
</code></pre>
</li>
<li><p>vim 替换</p>
<p> 答案：<code>:s/old/new/g</code>,替换一行的所有old为new.<code>:</code>命令模式，<code>s</code>是指本行，<code>g</code>是指所有</p>
</li>
<li><p>查看磁盘大小</p>
<p> 答案：<code>df -lh</code>,<code>fdisk -l</code></p>
</li>
<li><p>virtual box 安装Ubuntu，之后使用本地命令行登录。</p>
<p> 答案： Ubuntu 装一个openssh-server . vb里面加一个hostonly-adapter. 之后将nat 端口转发</p>
</li>
<li><p>查看当前电脑时区</p>
<p> 答案：<code>date</code></p>
</li>
<li><p>使用nginx ,实现多个tomcat 负载均衡。</p>
<p> <a href="http://www.cnblogs.com/fengzheng/p/4995513.html">原文地址</a>;参考了这个博客，我也实现了。 不过我做了一些小改动。在tomcat上我直接<code>docker pull tomcat</code>镜像，之后根据tomcat镜像生成的容器，来做的实现。没有那么麻烦。nginx 主要在http模块增加了配置:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	server&#123;</span><br><span class="line">		listen 80;</span><br><span class="line">		server_name localhost;</span><br><span class="line">		location &#x2F; &#123;</span><br><span class="line">			proxy_pass http:&#x2F;&#x2F;blance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	upstream blance&#123;</span><br><span class="line">		server localhost:3280 weight&#x3D;5;</span><br><span class="line">		server localhost:3380 weight&#x3D;5;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">	include &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;*;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 5.17 问题</span><br><span class="line">1. 怎么给mysql 唯一key 取名</span><br><span class="line"></span><br><span class="line"> 	答: index,key在MySQL指代的是同一个东西，不过在key有一个unique key 它会限制多行的该列不会有相同值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  – 建表语句</p>
<p>  create table language_tbl(</p>
<pre><code>   id int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;语言的数字id&#39;,
   language_code varchar(20) NOT NULL COMMENT &#39;语言显示名:en_US;zh_CN;zh_TW;ko_KR;th_TH&#39;,
    create_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
   last_modify_time datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ,
   flag int(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;&#39;,
   PRIMARY KEY (id),unique key `idx_language_code_flag` (language_code,flag)
</code></pre>
<p>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以看到我们自定义的unique key 名为&#96;idx_language_code_flag &#96;,可以用&#96;show index from language_tbl;&#96;查看一下表的index。另外如果表已经建立好:&#96;create index idx_language_code on language_tbl(language_code);&#96;，其中idx_langauge_code是自定义的名字。</span><br><span class="line"></span><br><span class="line">2. 删除表</span><br><span class="line"></span><br><span class="line">	答:&#96;drop table  if EXISTS language_tbl;&#96; 删除表,包括表数据。</span><br><span class="line">		&#96;delete from language_tbl;&#96;删除表的所有已有数据。</span><br><span class="line"></span><br><span class="line">3. 当访问一个URL时报404，nginx&#x2F;1.10.2，这种情况查看 nginx 日志判断看是否Nginx访问到了。</span><br><span class="line">   答: 查看日志，第一步要确定我们要查看的那个日志在那个位置，进入到&#96;&#x2F;etc&#x2F;nginx&#96;目录使用&#96;grep&#96;，找到log目录。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>grep ‘log’ nginx.conf<br>error_log  /var/log/nginx/error.log warn;<br>log_format  main  ‘$remote_addr - $remote_user [$time_local] $request_time “$request” ‘<br>access_log  /var/log/nginx/access.log  main;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 5.15 问题</span><br><span class="line">1. Mysql 使用&#96;group by&#96;是否可以将多行中同列的不同值合并成一条</span><br><span class="line"></span><br><span class="line">	答: 主要使用group_concat()函数，可以将同组id相同的值合并到一个值当中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> SELECT genenic_id,</p>
<pre><code>    group_concat(LANGUAGE)
</code></pre>
<p> FROM genenic_language_tbl<br> GROUP BY genenic_id;</p>
<p> SELECT genenic_id,</p>
<pre><code>    group_concat(LANGUAGE separator &#39;;&#39;)
</code></pre>
<p> FROM genenic_language_tbl<br> GROUP BY genenic_id;                                </p>
<p> SELECT genenic_id,</p>
<pre><code>    group_concat(LANGUAGE
                 ORDER BY id DESC)
</code></pre>
<p> FROM genenic_language_tbl<br> GROUP BY genenic_id;                                </p>
<p> SELECT genenic_id,</p>
<pre><code>    group_concat(DISTINCT LANGUAGE)
</code></pre>
<p> FROM genenic_language_tbl<br> GROUP BY genenic_id;</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">2. 一条SQL更新两个表</span><br><span class="line"></span><br><span class="line">	答: &#96;update tbl_name1 a, tbl_name2 b set a.xx&#x3D;&#39;&#39;,b.xx&#x3D;&#39;&#39;;&#96;这样有个不好的地方。这两个表的所有字段都会更新。所以这种情况的使用场景是两个表有唯一主键关联，一定要仔细检查。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> begin;<br>update city_ch_tbl a,city_en_tbl b<br> set a.desc_col = ‘adsf’,b.desc_col=’testsss2’<br>where a.id = 2 or b.id=21231;<br>rollback;<br>commit;<br>update city_tbl a, city_detail_tbl b<br>set a.displayType_col=1 ,b.publish_status=?,     a.publish_time=current_timestamp<br>where a.id =b.cityId_col and a.id=?</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">3. redis Key 加密登录  </span><br><span class="line"></span><br><span class="line">	答:如果redis配置了密码，修改了redis.cnf 的&#96;requirepass chen&#96;；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> src/redis-server redis.conf<br> auth password chen</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 5.13 问题</span><br><span class="line"></span><br><span class="line">1. mysql 替换数据库的某些值</span><br><span class="line"></span><br><span class="line">	答案: 使用MySQL的&#96;replace()&#96;函数</span><br><span class="line">	&#96;update city_en_tbl set desc_col &#x3D; REPLACE(desc_col, &#39;ne&#39;, &#39;ne1&#39;) where id &#x3D; 3;&#96;</span><br><span class="line"></span><br><span class="line">2. mysql 字符相加</span><br><span class="line"></span><br><span class="line">	答: 使用MySQL的&#96;CONCAT(str1, str2, str3, ...)&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5.12 问题</span><br><span class="line"></span><br><span class="line">1. mysql 增加唯一键</span><br><span class="line">	&#96;alter table tbl_name add unique key(col_name)&#96;</span><br><span class="line">	&#96;alter table city_en_tbl add unique key(cityId_col)&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. nginx 反向代理</span><br><span class="line"></span><br><span class="line">3. robots.txt是啥？</span><br><span class="line"></span><br><span class="line">	谷歌爬虫会根据robots的文件内容确定哪些爬，哪些不爬，可以减少网站的带宽。</span><br><span class="line">4. Linux 查看软连接</span><br><span class="line"></span><br><span class="line">	Linux增加软连接为&#96;ln -s afile bfile&#96;,查看为&#96;ls -il&#96;</span><br><span class="line">5. nginx site-ennable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	## 5.10 问题</span><br><span class="line"></span><br><span class="line">1. Curl 命令</span><br><span class="line"></span><br><span class="line">	&#96;curl [option] [url]&#96;,平常使用最多的是前后端分离后，我们使用post，get请求某个接口。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> – 头信息<br> curl -H “Token:aadfdwd29b568918db” <a href="http://www.baidu.com/test/schedule_rule/autoextend">http://www.baidu.com/test/schedule_rule/autoextend</a><br> – 一个比较全面的例子 post请求<br> curl -X POST <br><a href="http://mywebsite.com/project/url/query">http://mywebsite.com/project/url/query</a> \</p>
</li>
</ol>
<p> -H ‘cache-control: no-cache’<br> -H ‘content-type: application/json’<br> -H ‘token: ce15-fba-ead1-e9d2-2a03041c9’<br> -d ‘{<br>       “id”: “22,23,76,12”,<br>       “language”: “”</p>
<p>   }’</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>Question</category>
      </categories>
      <tags>
        <tag>Question</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 基础 一（简介与核心组件介绍）</title>
    <url>/2022/11/07/kubernetes-basic-1-base-concepts/</url>
    <content><![CDATA[<h1 id="kubernetes-基础-一（简介与核心组件介绍）"><a href="#kubernetes-基础-一（简介与核心组件介绍）" class="headerlink" title="kubernetes 基础 一（简介与核心组件介绍）"></a>kubernetes 基础 一（简介与核心组件介绍）</h1><h2 id="Kubernetes-是什么？"><a href="#Kubernetes-是什么？" class="headerlink" title="Kubernetes 是什么？"></a>Kubernetes 是什么？</h2><p>Kubernetes 是一个用于编排容器化服务的的开源平台。我们通常会将 Kubernetes 简称为 K8s。Kubernetes 通常也被大家当做容器编排引擎，可以这样说，目前市面上很多的 PaaS 平台基本都是使用 k8s 作为其底层支持。</p>
<span id="more"></span> 

<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><p>如果了解到 kubernetes 是什么，那么 kubernetes 为什么我们要使用了？它提供了我们什么能力而让其这么火？</p>
<h3 id="应用编排与服务发现"><a href="#应用编排与服务发现" class="headerlink" title="应用编排与服务发现"></a>应用编排与服务发现</h3><p>kubernetes 能够帮助我们管理我们的业务应用系统，并且在内部可以基于dns 和 ip 来进行通信访问，对外可以提供 service 和 loadbalance 两种方式提供服务访问。</p>
<h3 id="储存管理"><a href="#储存管理" class="headerlink" title="储存管理"></a>储存管理</h3><p>kubernetes 提供多种方式来进行数据的持久化管理，比如本地卷，ceph，第三方公有云的存储等</p>
<h3 id="自动发布与回滚"><a href="#自动发布与回滚" class="headerlink" title="自动发布与回滚"></a>自动发布与回滚</h3><p>kubernetes 可以工具你配置的应用的desired 来以可控的方式控制应用的发布与回滚</p>
<h3 id="应用自愈"><a href="#应用自愈" class="headerlink" title="应用自愈"></a>应用自愈</h3><p>kubernetes 可以在服务状态不对时，进行服务自愈。比如健康检查</p>
<h3 id="秘钥与配置管理"><a href="#秘钥与配置管理" class="headerlink" title="秘钥与配置管理"></a>秘钥与配置管理</h3><p>可以在应用无需重启就能更新服务的 secret 和配置 config。这个功能其实可以做比如动态更新配置，多环境配置等。</p>
<h2 id="核心控制平面组件"><a href="#核心控制平面组件" class="headerlink" title="核心控制平面组件"></a>核心控制平面组件</h2><p><img src="/images/qiniu/2020-06-07-17-19-38.png" alt="2020-06-07-17-19-38"></p>
<p>kubernetes 集群中机器分为两个类型，控制节点和工作节点；kubernetes 组件又分为控制面组件和节点组件。比如控制平面组件为：kube-apserver,kube-scheduler,kube-controller-manager，ETCD；这些控制平面的组件只会运行在 master 节点上。而节点组件：kubelet，kube-proxy 则会运行在集群所有节点上（包括 master 和 worker）。接下来我么来了解下每个组件的功能是做什么的。</p>
<h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><p>kube-apiserver 是控制平面的组件。主要用来暴露 kubernetes 的 api。kube-apiserver 设计成可水平扩展的应用，用一个 loadbalance 就可以对其所有 apiserver 的实例进行负载。</p>
<h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><p>主要用来监听所有没有调度主机的新创建的 pod，并且将 pod 调度到主机上。scheduler 调度规则包含了很多因素：独立和集群需要的资源，硬件、软件、策略约束，亲和性和非亲和性，数据约束，业务干扰，调度时间等</p>
<h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><p>kubernetes 的主要控制器，通过 apiserver 来监控整个集群的状态，并且确保集群处于预期的工作状态。它由一系列独立的 controller 组成。为了减少复杂性，他们封装进了一个二进制文件中，并且运行一个进程。</p>
<p>这些 controller 包括：Node controller，Replication controller，Endpoints controller，Service Account &amp; Token controllers等等。</p>
<h3 id="ETCD"><a href="#ETCD" class="headerlink" title="ETCD"></a>ETCD</h3><p>etcd 本身是一个高可用的键值数据库，kubernetes 用其来进行集群的数据存储。</p>
<h2 id="核心节点组件"><a href="#核心节点组件" class="headerlink" title="核心节点组件"></a>核心节点组件</h2><h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>在集群中的每个主机上都会运行的一个 agent，确保容器在 pod 中运行。kubelet 通过PodSpec来管理容器，并且确保他们运行正常。注意：如果是主机原来的容器，kubelet 并不会进行管理。</p>
<h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>kube-proxy 是每个主机上都会有的一个网络代理，是 service 的主要实现方式。kube-proxy 包含主机上的网络规则，这些规则在集群中定了集群内部的访问和外部的网络会话访问方式。</p>
<h2 id="集群插件"><a href="#集群插件" class="headerlink" title="集群插件"></a>集群插件</h2><p>集群插件都是属于集群级别的组件，以deployment，daemonset等方式运行在 kube-system 的命名空间下，用来实现集群级别的一些功能。</p>
<h3 id="DNS-插件"><a href="#DNS-插件" class="headerlink" title="DNS 插件"></a>DNS 插件</h3><p>DNS 是集群中的必须安装的插件，在集群中很多功能都会依赖 dns 。kubernetes 创建的容器会自动包含这个 dns 服务器在容器的 dns 搜索域中。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>容器的网络基础</title>
    <url>/2023/02/11/kubernetes-container-network/</url>
    <content><![CDATA[<h1 id="容器的网络基础"><a href="#容器的网络基础" class="headerlink" title="容器的网络基础"></a>容器的网络基础</h1><p>容器的网络基础是主机的网络，在理解容器的网络前我们先来看一下主机的网络。</p>
<blockquote>
<p>想象一个场景，你在湖南，你的爱人在湖北，有一天，你们两觉得恋爱的时间差不多了，该结婚了。结婚之前是不是要先见一下家长。但是湖南和湖北之间隔着长江。那你现在要去湖北的话，怎么办呢？你会想，我有车，只需要开车过“长江大桥”去对方父母家就行。</p>
</blockquote>
<p>换一下，现在你有两台电脑，你想让两台电脑能够互相传递文件或者文本信息，那该怎么做呢？我想刚刚的例子中，你会想到，只要建一个桥就行了。那两台电脑直接的桥怎么建？首先你是需要将两台电脑用线”连”起来。正常来说，有了这条传输的线，两台机器之间互相通信的基础条件就具备了。然后再进一步，你家里又买了几台电脑，这几台电脑互相之间也需要通信，那电脑只有一个插口，总不能与谁通信的时候，就插谁的网线吧，这要是都在同一时间通信，那不就的乱了？所以家里一般会有个路由设备，大家都在路由设备插入，然后要发的消息就先发个路由器，路由器再转发。那路由器怎么分清是哪台电脑？所以是不是大家要有个唯一标识符号（mac地址）。你看OSI七层模型就出来了。具体的化大家可以参考一下这个(<a href="https://www.lifewire.com/layers-of-the-osi-model-illustrated-818017)%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%BB%E8%A6%81%E6%98%AF%E8%B0%88%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E3%80%82">https://www.lifewire.com/layers-of-the-osi-model-illustrated-818017)，我们主要是谈容器网络。</a></p>
<p>前面这些铺垫，其实主要还是为了主题容器网络。</p>
<span id="more"></span>
<p>容器的本质是一种特殊的进程。容器里面最大的三个相关技术：限制、隔离、根文件，分别对应Cgroups、Namespace、RootFS。 而我们今天主题中，就需要先从 Network Namespace 讲起。</p>
<p>容器运行的时候的，它能看到的”网络栈” ，实际就是被隔离到它自己的 Network Namespace  中。网络栈应该包含有网卡（network interface)、回环设备（loopback device）、路由表（routing table）和 iptables规则。对于一个进程来说，这些要素就构成了它发起和响应网络请求的基本环境。</p>
<p>容器其实也可以直接使用宿主机的网络栈，只需要使用<code>-net=host</code> 就行。像这样容器直接使用宿主机网络栈的方式，可以为容器带来良好的网络性能，但是也不可避免的带来了共享网络资源的问题，比如端口冲突。所以我们希望的是，每个容器进程都使用自己的Network Namespace里面的网络栈，有自己独立的IP地址和端口。那这个时候就有一个情况出现，如果启动了两个容器，两个容器之间怎么互相通信呢？</p>
<p>如果你把容器看成一个主机，那就会想到，能否给两个容器插一根网线呢？让我们把视角切换到一台服务器上，你在服务器上安装了docker， 然后使用docker创建很多容器。你现在想让容器直接能够互相通信，那我们就需要有一个”交换机”，而容器是在服务器里面的，那我们能否也在服务器里面创建一个交换机了？在Linux设备中，起到虚拟交换机作用的网络设备，就是网桥（Bridge），Docker 项目会在宿主机上创建一个默认的 docker0 的网桥。那OK，交换机的问题解决了，那把容器和网桥进行连接的”线”呢？嗯，这个时候我们就要用到一个叫做Veth Pair 的虚拟设备了。Veth Pair 设备的特点是，它被创建出来后，总是以两张虚拟网卡(veth peer)的形式成对出现的。并且，从其中一个”网卡”的发出的数据包，可以直接出现在对应的另一张”网卡”上，哪怕这两个”网卡”在不同的Network Namespace 里面。</p>
<p><img src="/images/qiniu/0ab069ed6faece0688e7129f9dc879434094c8fe13122838c14bb6885a87ebfc.png" alt="图 2">  </p>
<p>OK，那我们现在就能让同一台主机上的不同容器直接互相通信了。那如果是不同主机上的不同容器直接怎么访问呢？比如K8S集群中，多台机器上，有多个容器，容器间的网络互相访问应该怎么弄？这就是我们常说的容器跨主机网络访问了。说到容器的跨主机通信，就有一个用的非常广的容器网络项目：Flannel。</p>
<p>Flannel提供了三种后端实现：1、VXLAN；2、Host-GW；3、UDP。</p>
<p>3种实现中，我们先看最早的一种方式：UDP。 </p>
<p>假设有两台主机：10.59.100.36、10.59.100.37。</p>
<p>Flannel 安装完之后，会在主机上创建一个Flannel0的设备，它是一个TUN设备(Tunnel 设备)。TUN设备是一个工作在三层的虚拟网络设备。它的功能非常简单，在操作系统内核和用户程序中传递IP包。 </p>
<p>当操作系统将一个IP包发送给flannel0设备后，flannel0就会把这个包转给创建它的flannel进程，这是一个从内核态到用户态的的流动方向；相反的如果flannel进程向flannel0发送一个ip包，那这个包就出现在了宿主机网络栈中，然后根据宿主机的路由表进行下一步处理，这是一个从用户态到内核态的流动方向。</p>
<p>那当flanneld收到flannel0转过来的IP包，然后怎么转发到这个IP了？这就是我们在flannel中的主要配置：子网的功劳了。主网与宿主机的关系保存在etcd中：<code>etcdctl ls /coreos.com/network/subnets</code> 所以我们可以看到，当a主机的flanneld收到ip包之后，只要将ip进行匹配就能知道要转发到那个主机上。这个流程能完成的原因就是每个主机上都启动了一个flanneld，都监听这8285的一个端口，，所以flanneld只要把udp包发往b主机的8285端口就行。而接下来，flanneld再把这个IP包发送给它管理的TUN设备，也就是flannel0设备，就可以找到对应的容器了。以下为示意图：</p>
<p><img src="/Users/chenzhijun916/Documents/doc/flannel-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1-udp.png" alt="img"></p>
<p>但是为什么udp模式最后被放弃了？其实tun设备还是一个在三层的Overlay网络，比起两台宿主机的直接通信，flannel还做了一个通过flanneld进程进行封装的过程，这也导致flannel性能不好的直接原因，它需要在用户态和内核态直接进行3次转换。</p>
<p><img src="/Users/chenzhijun916/Documents/doc/flanned-udp-%E5%BA%9F%E5%BC%83%E7%9A%84%E5%8E%9F%E5%9B%A0.png" alt="img"></p>
<p>所以flannel后续支持VXLAN，即：Virtual Extensible LAN（虚拟可扩展局域网），是Linux内核本身就支持的一种网络虚拟化技术。VXLAN的设计思想是在现有的三层网络之上，覆盖一层虚拟的、由内核VXLAN模块负责维护的二层网络，使得这个二层网络上的虚拟机或者容器，可以像局域网一样自由通信。而为了能够在二层网络上打通隧道，VXLAN 会在宿主机上设置一个特殊的网络设备作为”隧道”的两端，这个设备就叫做VTEP，即：VXLAN Tunnel End Point（虚拟隧道端点）。</p>
<p>VTEP设备其实有点类似之前说的TUN设备，不过它是作用在二层上，对二层的数据帧进行封装和解封，而且这个工作全部是在内核里完成的。</p>
<p><img src="/Users/chenzhijun916/Documents/doc/flannel-vxlan%E6%A8%A1%E5%BC%8F.png" alt="img"></p>
<p>可以看到每个主机都有一个flannel.1的设备，就是vxlan所需的vtep设备，它既有IP地址，也有mac地址。</p>
<p>现在容器 A 要访问容器 B，流程是怎样的呢？</p>
<p>首先 A 发出的IP 包，会先出现在docker0网桥，然后被路由到本机设备 flannel.1 进行处理，这个我们可以叫它原始包。</p>
<p>在到达 flannel.1之后，flannel.1 的作用就是要将这个原始包发送到正确的 目的宿主机的 vtep 设备上。</p>
<p>那怎么找到 vtep 设备呢？ 根据<code>route -n</code> 路由记录，我们可以知道目的主机的 vtep 设备的 IP 地址，而根据三层的 IP 地址查询对应的二层 MAC 地址信息，则恰好是ARP 表的功能。这里的 arp 记录，每个主机的 flannel.1 进程维护的，一台主机新加入到集群，就会把相应的 vtep 设备对应的 arp 记录下发到所有宿主机上。现在有了 MAC 地址，Linux 内核就可以开始二层封包操作，它会把容器的 IP和目的 VTEP 设备的 mac 地址组装成一个新的二层数据帧。封包过程只是增加二层头，不会改变原始包。</p>
<p>但是吧，这次的封包，其实对于宿主机的网络来说，并没有意义。Linux 内核还需要将这个二次封包的数据帧进行再一次封包成普通数据帧，这样才能让它把二次封包的数据帧，通过宿主机的 eth0 网卡进行传输。在内核进行封包成普通数据帧的时候，会将 VXLAN 的数据表进行标记，增加一个特殊的 vxlan 头，里面的重要标识 VNI ，它是 VTEP 设备识别某个数据帧是否应该归自己处理的标识。在 Flannel 中，VNI 的默认值就是 1， 这也就是为什么 flannel 的 vtep 设备叫 flannel.1的原因，这里的 1，就是 VNI 的值。不过在这里，flannel.1设备只知道另一个 flannel.1设备的mac 地址，却不知道对应的宿主机地址是啥。也就是说，这个 UDP的包应该发给哪台机器呢？在我们这种场景下，flannel.1 设备实际就扮演了一个网桥的设备的角色，在二层网络进行 udp 包的转发。而在Linux 内核里面，“网桥”设备进行转发的依据是根据FDB （Forwading Database）库来的。不难想象，这个 FDB 是由 flanneld 进程维护的:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Node 1上，使用“目的VTEP设备”的MAC地址进行查询</span></span><br><span class="line">bridge fdb show flannel.1 | grep 5e:f8:4f:00:e3:37</span><br></pre></td></tr></table></figure>
<p>这样找到了目的宿主机的IP，然后宿主机再知道 arp 表要学习的内容知道 宿主机 ip 的 mac 地址， 之后就只需要进行正常 UDP 封包操作流程就行。接下来，node1 上的 flannel.1 设备就可以把这个数据帧从 node1 的 eth0 网卡上发出去，来到 node2 的 eth0 网卡。在 node2 的内核网络栈会发现这个数据帧里有 vxlan header，并且 VNI =1。所以 linux 内核会对它进行拆包，拿到内部二次封包后的数据帧，然后根据 VNI=1，将其交给 node2 的 flannel.1 设备进行处理。而 flannel.1 会进行进一步的拆包，取出原始数据包，流程跟之前一样，最后 原始数据包 进入到 container-2 的 network namespace 中。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 第一天</title>
    <url>/2019/04/03/kubernetes-day1/</url>
    <content><![CDATA[<h1 id="Kubernetes-day1"><a href="#Kubernetes-day1" class="headerlink" title="Kubernetes day1"></a>Kubernetes day1</h1><h2 id="Kubernetes是什么？"><a href="#Kubernetes是什么？" class="headerlink" title="Kubernetes是什么？"></a>Kubernetes是什么？</h2><p>Kubernetes简称k8s。最直观的解释它是用将资源进行整合，将应用与底层隔离。因此，搞业务开发的，专心搞好业务逻辑。搞底层机器，网络资源的安心搞好底层网络资源。而k8s就是这中间的一层，承上启下。也就是传说中的PaaS。现在可以说没有那个Paas或者Caas不是基于k8s搞的。不过我觉得理解的不深，k8s的作用其实还有很多，如果你用过docker或者直接开发业务就会有比较深的感知。</p>
<h2 id="Kubernetes-关键组件"><a href="#Kubernetes-关键组件" class="headerlink" title="Kubernetes 关键组件"></a>Kubernetes 关键组件</h2><p>安装一个K8S集群需要哪些组件了？一个完整的小集群里面，需要有一个master，一个node，两台机器。master和node上分别有哪些组件了？master上有kube-apiserver,kube-scheduler,kube-controller-manager; node上有kubelet,kube-proxy,docker;另外需要在master上安装一个etcd数据库。如果是非二进制安装，master和node上都需要有kubeadm。安装完这些之后需要在master节点上使用’kubectl apply -f [kubelet-network].yaml’也就是如果你使用flannel网络，就可能需要安装flannel的网络插件。这个插件是已pod的方式创建的。</p>
<h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><h3 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h3><p>键值数据库，这个没有什么特别好说的。要在安装k8s集群前先启动，保存k8s所有资源对象数据</p>
<h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><p>集群控制的入口进程，提供HTTP Rest接口的关键服务进程，是k8s里面所有资源操作的唯一入口。</p>
<h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><p>k8s所有资源对象的自动化控制中心</p>
<h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><p>k8s的资源调度进程</p>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>负责pod对应的容器的创建，启停等任务，同时与Maser节点密切协作，实现集群管理的基本功能</p>
<h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>实现kubernetes Service的通信与负载均衡机制的重要组件</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot&amp;SpringCloud 组件容器化方案</title>
    <url>/2022/08/08/kubernetes-springboot-cloud/</url>
    <content><![CDATA[<h1 id="SpringBoot-amp-SpringCloud-组件容器化方案"><a href="#SpringBoot-amp-SpringCloud-组件容器化方案" class="headerlink" title="SpringBoot&amp;SpringCloud 组件容器化方案"></a>SpringBoot&amp;SpringCloud 组件容器化方案</h1><p>该方案为 Java 开发人员在使用 springboot 开发以及是用 springcloud 组件时，将 组件/服务 进行容器化部署运行的方案。</p>
<span id="more"></span> 
<h2 id="0-前置约定"><a href="#0-前置约定" class="headerlink" title="0. 前置约定"></a>0. 前置约定</h2><pre><code>对 Java 开发时使用到的相关开发基础组件版本约定：
</code></pre>
<ol>
<li>Java Version: 1.8+</li>
<li>SpringBoot Version: 2.3.5.RELEASE</li>
<li>SpringCloud Version: Hoxton.SR9 （请注意，springcloud 版本有 springboot 版本要求）</li>
<li>Openshift Version: 3.11，4.6</li>
<li>Kubernetes Version: 1.11（对应 ocp3），1.19（对应 ocp4）</li>
</ol>
<h1 id="1-SpringBoot-服务容器化"><a href="#1-SpringBoot-服务容器化" class="headerlink" title="1. SpringBoot 服务容器化"></a>1. SpringBoot 服务容器化</h1><pre><code>目前 Java 项目开发多基于 springboot ，开发完成后多以嵌入 web 服务器的方式构建成 jar 包方式运行服务。容器化过程中，我们需要将其进行容器化。下面将以一个用户服务`user-app`进行示例：
</code></pre>
<ol>
<li><p>项目结构；</p>
<p> 其中 src 为我们的源代码目录；Dockerfile 文件可以存放到项目根路径下，也可以自定义，自定义目录时，请注意在构建时需要指定文件路径。</p>
<p> <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6baf9b1-9002-41c1-b721-702ce15208ea/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6baf9b1-9002-41c1-b721-702ce15208ea/Untitled.png"></p>
</li>
<li><p>业务镜像构建；</p>
<p> 通过在项目中增加 <code>Dockerfile</code> 文件可以将业务服务制作成一个业务镜像，<code>Dockerfile</code>模板内容为：</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># registry-c.chenzhijun.top 为金科提供的镜像仓库服务</span></span><br><span class="line"><span class="comment"># openjdk:11.0.10-jdk-oracle 为原生 Java 基础镜像，可按需求定制</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">registry-c.chenzhijun.top/base/openjdk:11.0.10-jdk-oracle</span></span><br><span class="line"><span class="comment"># 业务镜像构建指令</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">target/*.jar</span> <span class="string">/home/</span></span><br><span class="line"><span class="comment"># 容器运行时的默认启动命令，实际运行中可覆盖</span></span><br><span class="line"><span class="comment"># user-app-0.0.1-SNAPSHOT.jar 请替换为实际maven、gradle 构建时的 jar 包名称</span></span><br><span class="line"><span class="string">CMD</span> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/home/user-app-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></pre></td></tr></table></figure>
<p> 请注意：在构建镜像前需要先生成 jar 包，之后再使用 <code>docker build -t [YOUR_IMAGE_NAME] .</code> 来生成业务镜像。</p>
</li>
<li><p>业务部署</p>
<p> 在通过步骤 2 生成业务基础镜像后，接下来需要将其进行业务部署。业务部署的deployment 模板内容：<code>user-app.yaml</code></p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">user-app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">user-app</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">springcloud</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">user-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">user-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">java</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;-jar&#x27;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/home/user-app-0.0.1-SNAPSHOT.jar</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;--spring.config.additional-location=file:./config/&#x27;</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROFILE_ACTIVE</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">prod</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">&#x27;registry-c.chenzhijun.top/czj/user-app:latest&#x27;</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">user-app</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/home/config</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">volume-config</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">      <span class="attr">securityContext:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">userapp-config</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">volume-config</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">application-dev.yml:</span> <span class="string">|-</span></span><br><span class="line">    <span class="attr">spring:</span></span><br><span class="line">      <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">config:</span> <span class="string">uat-config</span></span><br><span class="line">    <span class="attr">eureka:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">serviceUrl:</span></span><br><span class="line">          <span class="attr">defaultZone:</span> <span class="string">http://eureka-1:8761/eureka/,http://eureka-2:8762/eureka/,http://eureka-3:8763/eureka/</span></span><br><span class="line">      <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">application-prod.yml:</span> <span class="string">|-</span></span><br><span class="line">    <span class="attr">spring:</span></span><br><span class="line">      <span class="attr">profiles:</span> <span class="string">prod</span></span><br><span class="line">    <span class="attr">config:</span> <span class="string">uat-config</span></span><br><span class="line">    <span class="attr">eureka:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">serviceUrl:</span></span><br><span class="line">          <span class="attr">defaultZone:</span> <span class="string">http://eureka-1:8761/eureka/,http://eureka-2:8762/eureka/,http://eureka-3:8763/eureka/</span></span><br><span class="line">      <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">application-uat.yml:</span> <span class="string">|-</span></span><br><span class="line">    <span class="attr">spring:</span></span><br><span class="line">      <span class="attr">profiles:</span> <span class="string">uat</span></span><br><span class="line">    <span class="attr">config:</span> <span class="string">uat-config</span></span><br><span class="line">    <span class="attr">eureka:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">serviceUrl:</span></span><br><span class="line">          <span class="attr">defaultZone:</span> <span class="string">http://eureka-1:8761/eureka/,http://eureka-2:8762/eureka/,http://eureka-3:8763/eureka/</span></span><br><span class="line">      <span class="attr">instance:</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">userapp-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">springcloud</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">user-app</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">user-app</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">springcloud</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-app</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">user-app</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p> 通过 <code>configmap</code> 来控制相关的配置时，我们需要制定以下 config 的位置。实际运行中的文件目录结构如下：</p>
<p> <img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/328e4f73-992b-49a3-8e50-6a7c368f8438/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/328e4f73-992b-49a3-8e50-6a7c368f8438/Untitled.png"></p>
</li>
<li><p> 检查部署结构</p>
</li>
</ol>
<pre><code>单体的 springboot 服务结合 kubernetes 的 configmap 其实际效果不是特别大，因为明文的 configmap 可以直接在 springboot 项目中多放置配置文件使用。但在实际中，我们也可以使用 kubernetes 的 secret 来进行配置的简单加密，部署方式也是类似，只是将 configmap 改为 secret 即可。

完整示例代码可以参考：[http://git.dev.cmrh.com/springcloud/user-app.git](http://git.dev.cmrh.com/springcloud/user-app.git)
</code></pre>
<h2 id="2-SpringCloud-组件的容器化"><a href="#2-SpringCloud-组件的容器化" class="headerlink" title="2. SpringCloud 组件的容器化"></a>2. SpringCloud 组件的容器化</h2><pre><code>SpringCloud 全家桶中有非常多的组件，有些组件需要结合客户端使用，有些是属于独立中间件，现挑选其中常见组件进行容器化示例。示例组件包含：注册中心 Eureka，网关 Zuul，熔断监控 Hystrix、Turbine，微服务管理 SpringCloud Admin，客户端负载均衡器 Robbin。

 请注意，示例中 SpringCloud 版本为：Hoxton.SR9；对应的 Springboot 版本为：2.3.5.RELEASE。
</code></pre>
<h3 id="2-1-Eureka-服务容器化"><a href="#2-1-Eureka-服务容器化" class="headerlink" title="2.1 Eureka 服务容器化"></a>2.1 Eureka 服务容器化</h3><ol>
<li>Eureka 高可用架构；<pre><code> Eureka 原生高可用方案为部署三个 Eureka 节点，节点直接互相注册来达成高可用；在容器化过程中，我们通过部署独立的三个 Eureka 实例：eureka-1，eureka-2，eureka-3；三实例互相注册来达成高可用。
</code></pre>
</li>
<li>Eureka 高可用部署；<pre><code> Eureka 作为通用的组件，可以使用通用的部署方式：
</code></pre>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-1</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eureka-1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">springcloud</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">eureka-1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">eureka-1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROFILE_ACTIVE</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">eureka-1</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">&#x27;registry-c.chenzhijun.top/czj/eureka-server:latest&#x27;</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">eureka-1</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-2</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eureka-2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">springcloud</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">eureka-2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">eureka-2</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROFILE_ACTIVE</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">eureka-2</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">&#x27;registry-c.chenzhijun.top/czj/eureka-server:latest&#x27;</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">eureka-2</span></span><br><span class="line">          <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">          <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">          <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-3</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eureka-3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">springcloud</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">eureka-3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">eureka-3</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROFILE_ACTIVE</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">eureka-3</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">&#x27;registry-c.chenzhijun.top/czj/eureka-server:latest&#x27;</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-1</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eureka-1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">springcloud</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8761</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-1</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-2</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eureka-2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">springcloud</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8762</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8762</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-2</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-3</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eureka-3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">springcloud</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8763</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8763</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-3</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>Eureka 访问验证<pre><code> 在 ocp 平台通过创建 route 来将 Eureka 服务暴露给业务使用。具体创建方式参考《OpenShift 基础服务操作指南-金科》[http://confluence.cmrh.com/pages/viewpage.action?pageId=81213827](http://confluence.cmrh.com/pages/viewpage.action?pageId=81213827)
</code></pre>
</li>
<li>项目使用 Eureka <pre><code> 在与 Eureka 同 Namespace 下的服务中，在springboot 项目中增加如下配置：
</code></pre>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka-1:8761/eureka/,http://eureka-2:8762/eureka/,http://eureka-3:8763/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">user-app</span> <span class="comment">#需要改动</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">cmft-user-app</span> <span class="comment">#与 project 保持一致</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">user-app</span> <span class="comment">#跟metadata.name保持一致</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">user-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">user-app</span> <span class="comment">#修改为项目名就行</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry-c.chenzhijun.top/czj/user-app:latest</span> <span class="comment">#修改为实际的 image-name</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROFILE_ACTIVE</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">prod</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http_proxy</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">proxy_url</span></span><br><span class="line">          <span class="attr">ports:</span> <span class="comment">#修改为实际的监听端口</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span> </span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-xmx&quot;</span>,<span class="string">&quot;-xms&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/home/user-app-0.0.1-SNAPSHOT.jar&quot;</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>ops 操作手册</title>
    <url>/2019/12/01/kubernetes-tips/</url>
    <content><![CDATA[<h2 id="给命令行增加快捷操作提示符"><a href="#给命令行增加快捷操作提示符" class="headerlink" title="给命令行增加快捷操作提示符"></a>给命令行增加快捷操作提示符</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source &lt;(kubectl completion bash) # setup autocomplete in bash into the current shell, bash-completion package should be installed first.echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc # add autocomplete permanently to your bash shell.</span><br><span class="line">alias k=kubectl</span><br><span class="line">complete -F __start_kubectl k</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="快速删除kubernetes资源"><a href="#快速删除kubernetes资源" class="headerlink" title="快速删除kubernetes资源"></a>快速删除kubernetes资源</h2><p>删除Terminating的pods</p>
<p><code>kubectl get pods --all-namespaces|grep Termi|awk &#39;&#123;print &quot;kubectl -n &quot;$1&quot; delete pods &quot;$2&quot; --force --grace-period=0&quot;&#125;&#39;|xargs -i echo &#123;&#125; &gt;delete.sh</code></p>
<p>缩容：</p>
<p><code>kcc scale --current-replicas=3 --replicas=0 deployment/orche</code></p>
<p>禁止主机调度：</p>
<p><code>kubectl uncordon NODE_NAME</code></p>
<p>显示节点ip：</p>
<p><code>kubectl get nodes -o wide --show-labels|awk &#39;&#123;print $1&quot;\t&quot;$2&quot;\t&quot;$6&#125;&#39;</code></p>
<p>删除标签：</p>
<p> <code>kubectl label node cnsz12.company.cn bad-</code></p>
<p>快速启动一个容器：</p>
<p> <code>kc run -i --tty --image harbor.com/library/busybox:1.28.4 dns-test --restart=Never --rm /bin/sh</code></p>
<h2 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">https://github.com/buger/goreplay</span><br><span class="line"></span><br><span class="line">./gor --input-raw :8080 --input-raw-track-response --output-stdout</span><br><span class="line"></span><br><span class="line">./gor --input-raw :8080 --output-stdout --http-allow-url RH_SSO/SeqSso.sso</span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 dst host 10.70.1.76 and dst port 4410</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文件底层无法编辑"><a href="#文件底层无法编辑" class="headerlink" title="文件底层无法编辑"></a>文件底层无法编辑</h2><p>chattr</p>
<h2 id="docker-容器网络工具镜像"><a href="#docker-容器网络工具镜像" class="headerlink" title="docker 容器网络工具镜像"></a>docker 容器网络工具镜像</h2><p><code>docker run -ti --net container:a967 nicolaka/netshoot:latest bash</code></p>
<!--
jdk8u202之后，jvm获取cgroup的内存限制。
kubectl get pods --all-namespaces|grep Termi|awk '{print "kubectl -n "$1" delete pods "$2" --force --grace-period=0"}'|xargs -i echo {} >delete.sh





网络模型：ovs open vswitch ,daemonset启动
openshift本身使用static pod
find /sys/fs/cgroup/memory -type d | wc -l

The node was low on resource: memory. Container rdspm-app was using 2159200Ki, which exceeds its request of 0


https://www.cnblogs.com/duanxz/p/10247494.html

https://blog.csdn.net/weixin_33744141/article/details/86251459


find . -amin -10 # 查找在系统中最后10分钟访问的文件
find . -atime -2 # 查找在系统中最后48小时访问的文件
find . -empty # 查找在系统中为空的文件或者文件夹
find . -group cat # 查找在系统中属于 groupcat的文件
find . -mmin -5 # 查找在系统中最后5分钟里修改过的文件
find . -mtime -1 #查找在1天以内修改过的文件
find . -mtime +7 #查找在7天以外修改过的文件
find . -nouser #查找在系统中属于作废用户的文件
find . -user fred #查找在系统中属于FRED这个用户的文件
find . -type -f # 查找文件类型为普通文件的文件


nginx 会话粘贴


http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive
https://stackoverflow.com/questions/24453388/nginx-reverse-proxy-causing-504-gateway-timeout
https://superuser.com/questions/1489355/website-shows-a-blank-page-when-opened-from-search-engines-or-href-links-but-wo


应用频繁启动，导致k8s node节点not ready

100.70.88.44


PLEG unhealth   https://github.com/kubernetes/kubernetes/issues/45419
https://github.com/kubernetes/kubernetes/issues/61117


CREATE USER 'monitor'@'100.69.224.39' IDENTIFIED BY 'monitor1875' WITH MAX_USER_CONNECTIONS 3;
GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'monitor'@'100.69.224.39';
GRANT SELECT ON performance_schema.* TO 'monitor'@'100.69.224.39';

go mod

haproxy 支持websocket

sed -i '/120/d’ known_hosts 替换120的行

sed -n ‘/120/p' known_hosts  查找ruby的行

git log --graph --pretty=oneline --abbrev-commit

Control a 最开始，control e 最末尾

nodeport,hostport
-->]]></content>
  </entry>
  <entry>
    <title>重启Linux主机后自动运行任务或者脚本</title>
    <url>/2018/10/30/linux-auto-excute-shell-script-after-rebooting/</url>
    <content><![CDATA[<h1 id="重启Linux主机后自动运行任务或者脚本"><a href="#重启Linux主机后自动运行任务或者脚本" class="headerlink" title="重启Linux主机后自动运行任务或者脚本"></a>重启Linux主机后自动运行任务或者脚本</h1><p>有时候我们在主机上做了一些agent应用，这些应用平常都是主机启动，agent就需要启动。相当于“伴生”。尽管第一次或者第二次我们能依靠记忆或者自我约束来启动这些agent，但是有时候还是会免不了忘记。那么有没有办法让这种agent做成开机启动呢？下面提供两种Linux设置开机启动应用的方法。</p>
<span id="more"></span>
<h2 id="1-crontab-实现脚本-应用-开机启动"><a href="#1-crontab-实现脚本-应用-开机启动" class="headerlink" title="1. crontab 实现脚本(应用)开机启动"></a>1. crontab 实现脚本(应用)开机启动</h2><p>crontab的介绍在我的另一个博客里面<a href="http://chenzhijun.top/2018/10/29/linux-crontab-clean-ndays-log/">crontab使用linux crontab定时清理n天前的日志文件</a>，这里我们介绍一个使用它来实现开机启动的用法。</p>
<p>使用<code>crontab -e</code>，在crontab的编辑页面增加下面的内容:<code>@reboot sleep 10 &amp;&amp; bash /root/test.sh</code>，sleep 10 是指在开机10秒后启动，启动的脚本是<code>/root/test.sh</code>。里面的内容，可以自己根据需要编写。最后要记住 <strong>将test.sh脚本设置为可执行权限 744 或者 777 或者 a+x</strong>。这样一个简单的开启启动任务就完成了。</p>
<h2 id="2-systemd-服务实现脚本-应用-开机启动"><a href="#2-systemd-服务实现脚本-应用-开机启动" class="headerlink" title="2. systemd 服务实现脚本(应用)开机启动"></a>2. systemd 服务实现脚本(应用)开机启动</h2><p>systemd 是linux机器的一个daemon服务。主要是创建一个<code>.service</code>文件，然后进行开机启动。下面来看一下实际使用过程。</p>
<p><code>vi /etc/systemd/system/auto_exe.service</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;auto exec after reboot</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;oneshot</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;auto.sh</span><br><span class="line">RemainAfterExit&#x3D;yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个systemd的<code>service</code>由三部分构成:Unit,Service,Install。详细的内容或者介绍可以使用man，或者google。</p>
<p>我这里表示的是在机器启动后，执行<code>/usr/local/bin/auto.sh</code>。</p>
<p>auto.sh，记得将权限赋值为<code>a+x</code>，777，或者744</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello&quot; &gt;&gt; /home/auto_exe.log</span><br></pre></td></tr></table></figure>

<p>之后使用<code>systemctl daemon-reload</code>刷新service，我们可以使用<code>systemctl start auto_exe</code> 进行调试，看脚本是否执行。<br>使用<code>systemctl status auto_exe</code>查看服务状态。如果成功，那么就可以加入确保启动执行脚本，使用<code>systemctl enable auto_exe</code>，这样就设置好了。</p>
<p>简单的linux应用开机启动就设置好了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的 Linux 基础命令</title>
    <url>/2017/04/18/linux-command-ls/</url>
    <content><![CDATA[<h3 id="常用-Linux-命令"><a href="#常用-Linux-命令" class="headerlink" title="常用 Linux 命令"></a>常用 Linux 命令</h3><p><code>man</code>: 查询帮助</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man info</span><br><span class="line">man ls</span><br></pre></td></tr></table></figure>

<p><code>ls</code>: 列出目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls 目录1 目录2  -&gt; 同时列出目录1，2的文件夹下的文件</span><br><span class="line">ls -R 目录名    -&gt; 递归列出目录下的所有目录和文件</span><br></pre></td></tr></table></figure>

<p><code>find</code>: 查找文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	find 目录 -name 文件名 </span><br><span class="line">	find .&#x2F;blog&#x2F;chenzhijun.github.com -name &quot;*.md&quot; | xargs grep &quot;Life&quot;</span><br><span class="line">	| xargs 传递命令查找出.&#x2F;blog&#x2F;chenzhijun.github.com目录下所有md 为结尾的文件，</span><br><span class="line">	并且在在文件中查找内容包含 Life 字符串的内容&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">&#96;grep&#96;: 根据条件查找文件内容，配合find找更牛逼</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>grep PATTERN filename -&gt; 在文件filename中找到pattern ```
</code></pre>
<p><code>pwd</code>: 当前工作目录的全路径</p>
<p><code>rm</code>: 移除文件，主要参数-rf ，强制递归删除</p>
<p><code>mv</code>: 移动文件</p>
<p><code>cat</code>: 查看全部文件内容</p>
<p><code>more</code>: 查看文件内容，逐行显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more +100 filename</span><br></pre></td></tr></table></figure>

<p><code>less</code>: 查看文件内容，上下滚动查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less +100 filename</span><br></pre></td></tr></table></figure>

<p><code>vim/vi</code>:编辑文件，如果不存在就创建</p>
<p><code>ping</code>: 测试网络连通</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>

<p><code>tar</code>: 文件解压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c 创建归档</span><br><span class="line">-x 解压归档</span><br><span class="line">-v 显示处理过程</span><br><span class="line">-f 目标文件，后面必须跟目标文件</span><br><span class="line">-j 调用bzip2 进行解压缩</span><br><span class="line">-z 调用gzip 进行解压缩</span><br><span class="line">-t 列出归档中的文件</span><br><span class="line">	</span><br><span class="line">tar -cvf filename.tar .       ### 将当前目录所有文件归档，但不压缩，注意后面有个’.‘ ，不可省略，代表当前目录的意思 </span><br><span class="line">tar -xvf filename.tar         ### 解压 filename.tar 到当前文件夹</span><br><span class="line">tar -cvjf filename.tar.bz2 .  ### 使用 bzip2 压缩</span><br><span class="line">tar -xvjf  filename.tar.bz2   ### 解压 filename.tar.bz2 到当前文件夹</span><br><span class="line">tar -cvzf filename.tar.gz     ### 使用 gzip  压缩</span><br><span class="line">tar -xvzf filename.tar.gz     ### 解压 filename.tar.gz 到当前文件夹</span><br><span class="line">tar -tf   filename            ### 只查看 filename 归档中的文件，不解压</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ln</code>: 两个文件中创建链接，硬链接，软链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln source dest       ### 为 source 创建一个名为 dest 的硬链接</span><br><span class="line"></span><br><span class="line">ln -s source dest    ### 为 source 创建一个名为 dest 的软链接</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>chmod</code>: 改变文件权限，读，写，执行；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -al 可以查看文件的详情，其中 所有者 、 用户组 、 其他都占3个</span><br><span class="line"></span><br><span class="line">-rwxr--r-- 1 locez users   154 Aug 30 18:09 filename</span><br><span class="line"></span><br><span class="line">r&#x3D;read,w&#x3D;write,x&#x3D;execute</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"> chmod +x filename        ### 为 user ，group ，others 添加执行权限</span><br><span class="line"> chmod -x filename        ### 取消 user ， group ，others 的执行权限</span><br><span class="line"> chmod +w filename        ### 为 user 添加写入权限</span><br><span class="line"> chmod ugo&#x3D;rwx filename   ### 设置 user ，group ，others 具有 读取、写入、执行权限</span><br><span class="line"> chmod ug&#x3D;rw filename     ### 设置 user ，group 添加 读取、写入权限</span><br><span class="line"> chmod ugo&#x3D;--- filename   ### 取消所有权限</span><br><span class="line"> </span><br><span class="line"> rwx对应111，如果赋予rwx三个权限，就是7，如果给所有者，用户组，其它都赋予rwx的权限，那么就是777</span><br></pre></td></tr></table></figure>

<p><code>wget</code>: 下载工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O newname.md https:&#x2F;&#x2F;github.com&#x2F;LCTT&#x2F;TranslateProject&#x2F;blob&#x2F;master&#x2F;README.md     ### 下载 README 文件并重命名为 newname.md</span><br><span class="line">wget -c url     ### 下载 url 并开启断点续传</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux cron clean log files older than N days</title>
    <url>/2018/10/29/linux-crontab-clean-ndays-log/</url>
    <content><![CDATA[<h1 id="使用linux-crontab定时清理n天前的日志文件"><a href="#使用linux-crontab定时清理n天前的日志文件" class="headerlink" title="使用linux crontab定时清理n天前的日志文件"></a>使用linux crontab定时清理n天前的日志文件</h1><p>最近有个需求，需要在linux机器上定时执行清理n天前的日志文件。其实我开始做了个更有意思的清理工具，根据alertmanager做webhook，然后在每个Linux机器上开启一个agent，收到请求再执行清理。不过使用crontab也是一个非常有用的工具。</p>
<p>crontab是Linux的一个守护进程，定时执行的工具。详细的内容可以使用<code>man crontab</code>查看。废话不多说，直接来看怎么使用它。只有用起来，才是属于自己的。</p>
<span id="more"></span>
<h2 id="查看当前有哪些定时任务"><a href="#查看当前有哪些定时任务" class="headerlink" title="查看当前有哪些定时任务"></a>查看当前有哪些定时任务</h2><p><code>crontab -l</code> 查看当前已经存在的定时任务。</p>
<p><img src="/images/qiniu/2018-10-29-22-26-45.png" alt="2018-10-29-22-26-45"></p>
<p>可以看到，你需要的就是准备一个shell脚本（任务指令），一个定时时间（执行频率），一条触发指令（程序入口）。<br>准备好这三个东西就可以。</p>
<p>下面我们以一个简单的需求来演示。</p>
<p>需要删除 <em>/data</em> 目录下文件名存在的带 <em>log</em> 的文件，修改这些文件的大小为0。</p>
<h2 id="设置一个新的定时任务"><a href="#设置一个新的定时任务" class="headerlink" title="设置一个新的定时任务"></a>设置一个新的定时任务</h2><p><code>crontab -e</code> 可以进入crontab编辑页面。将带‘*’的那行复制成新的行，如下：</p>
<p><img src="/images/qiniu/2018-10-29-22-33-33.png" alt="2018-10-29-22-33-33"></p>
<p>可能会问，前面的‘*’的时间怎么设置。可以使用<code>cat /etc/crontab</code>查看解释：</p>
<p><img src="/images/qiniu/2018-10-29-22-35-12.png" alt="2018-10-29-22-35-12"></p>
<p>之前的需求，我将<code>clean3dayslog.sh</code>文件放到<code>/root</code>目录下，然后执行文件，clear3dayslogs.sh的内容为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">find /data -mtime +3 -name &quot;*.log*&quot;|grep rtlog|xargs -i truncate -s 0 &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个demo比较简单，不过用处确实很大，一般清除的都在开发环境上，日志输出。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 日志管理工具 - Logrotate</title>
    <url>/2021/05/20/linux-log-tool-logrotate/</url>
    <content><![CDATA[<h1 id="Linux-日志管理工具-Logrotate"><a href="#Linux-日志管理工具-Logrotate" class="headerlink" title="Linux 日志管理工具 - Logrotate"></a>Linux 日志管理工具 - Logrotate</h1><p>最近在使用 openresty(nginx) 作为容器平台 kubernetes 的入口路由服务；流程大致为前端新建一个路由规则的时候，获取到 svc 的 endpoint 然后将其作为 nginx 的后端服务。实时监听 svc 的状态然后更新 ep 到 nginx；这里遇到一个问题，nginx 本身没有做到日志切割，在上线一段时间之后，nginx 的 vhost_access.log 日志文件竟然达到了 50G ，导致出现系统磁盘告警。google 一下没发现 nginx 有自带的日志轮转的功能（其实也有，只是要装插件和重新编译）；在线上最好的方式是什么了？最后采用了 Logrotate 来做日志切割。</p>
<span id="more"></span>
<p>logrotate 的主要功能为定时对增长中的日志文件进行自动切割，压缩，删除等操作；可以将定时任务设置为日，周，月，也可以自定义 crontab 的时间执行。</p>
<h2 id="Logrotate-安装与配置文件"><a href="#Logrotate-安装与配置文件" class="headerlink" title="Logrotate 安装与配置文件"></a>Logrotate 安装与配置文件</h2><p>首先需要安装 Logrotate： <code>yum install -y logrotate</code>; 安装完之后可以看到，默认是在<code>/etc/cron.daily/logrotate</code> 有一个定时执行任务。<code>/etc/cron.daily/logrotate</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf</span><br><span class="line">EXITVALUE=$?</span><br><span class="line">if [ $EXITVALUE != 0 ]; then</span><br><span class="line">    /usr/bin/logger -t logrotate &quot;ALERT exited abnormally with [$EXITVALUE]&quot;</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>另外我们可以看到它的配置文件:</p>
<p><img src="/images/qiniu/2020-05-20-22-59-26.png" alt="2020-05-20-22-59-26"></p>
<p>它的配置主要在<code>/etc/logrotate.conf</code>文件以及<code>/etc/logrotate.d/</code>目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># see &quot;man logrotate&quot; for details</span><br><span class="line"># rotate log files weekly</span><br><span class="line">weekly</span><br><span class="line"></span><br><span class="line"># keep 4 weeks worth of backlogs</span><br><span class="line">rotate 4</span><br><span class="line"></span><br><span class="line"># create new (empty) log files after rotating old ones</span><br><span class="line">create</span><br><span class="line"></span><br><span class="line"># use date as a suffix of the rotated file</span><br><span class="line">dateext</span><br><span class="line"></span><br><span class="line"># uncomment this if you want your log files compressed</span><br><span class="line">#compress</span><br><span class="line"></span><br><span class="line"># RPM packages drop log rotation information into this directory</span><br><span class="line">include &#x2F;etc&#x2F;logrotate.d</span><br><span class="line"></span><br><span class="line"># no packages own wtmp and btmp -- we&#39;ll rotate them here</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;wtmp &#123;</span><br><span class="line">    monthly</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">	minsize 1M</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;log&#x2F;btmp &#123;</span><br><span class="line">    missingok</span><br><span class="line">    monthly</span><br><span class="line">    create 0600 root utmp</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开它的主配置文件<code>/etc/logrotate.conf</code>可以看到它的一个配置：<code>include /etc/logrotate.d</code>，所以我们的配置基本上可以放到这个<code>logrotate.d</code>目录下。</p>
<h2 id="Logrotate-实际配置与操作"><a href="#Logrotate-实际配置与操作" class="headerlink" title="Logrotate 实际配置与操作"></a>Logrotate 实际配置与操作</h2><p>在<code>/etc/logrotate.d</code>目录下我们可以新建一个<code>ingress</code>文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x2F;data&#x2F;caas&#x2F;ingress-gateway 目录下的 *log 文件都会进行正则匹配</span><br><span class="line">&#x2F;data&#x2F;caas&#x2F;ingress-gateway&#x2F;*log &#123;</span><br><span class="line">    # 先进行 copy,然后进行 truncate，这里注意，在 truncate 的时间可能有一部分无法 copy 所以导致丢失数据。</span><br><span class="line">    copytruncate</span><br><span class="line">    # 服务&#x2F;etc&#x2F;</span><br><span class="line">    daily</span><br><span class="line">    # 创建新文件</span><br><span class="line">    create</span><br><span class="line">    # 保留切割的历史文件</span><br><span class="line">    rotate 100</span><br><span class="line">    # 正则匹配下一个 log 切割出错，继续执行，不然会中断</span><br><span class="line">    missingok</span><br><span class="line">    # 非空才执行</span><br><span class="line">    notifempty</span><br><span class="line">    # 对切割的日志进行压缩</span><br><span class="line">    compress</span><br><span class="line">    # 对于满足条件的 log，只运行一次脚本</span><br><span class="line">    sharedscripts</span><br><span class="line">    # 日志大小满足 400M 进行切割</span><br><span class="line">    size 400M</span><br><span class="line">    # 创建新目录用来存储旧的日志</span><br><span class="line">    createolddir</span><br><span class="line">    # 旧的日志目录</span><br><span class="line">    olddir &#x2F;data&#x2F;caas&#x2F;ingress-gateway&#x2F;bak</span><br><span class="line">    # 切割后的文件的带时间后缀，不然默认是log.1，log.2</span><br><span class="line">    dateext</span><br><span class="line">    # 使用 dateext 时候的日志格式</span><br><span class="line">    dateformat -%Y%m%d%H</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目录下的配置项如果没有的会使用 <code>/etc/logrotate.conf</code> 的默认配置，如果有的会覆盖掉全局配置使用自己定义的配置。在我上面定义的是一个将文件进行备份后进行 truncate 的操作，这种操作的好处就是容器与日志文件的句柄不会断。当然还有另一种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;data&#x2F;caas&#x2F;ingress-gateway&#x2F;*log &#123;</span><br><span class="line">    #copytruncate</span><br><span class="line">    daily</span><br><span class="line">    create</span><br><span class="line">    rotate 100</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    sharedscripts</span><br><span class="line">    size 400M</span><br><span class="line">    createolddir</span><br><span class="line">    olddir &#x2F;data&#x2F;caas&#x2F;ingress-gateway&#x2F;bak</span><br><span class="line">    dateext</span><br><span class="line">    dateformat -%Y%m%d%H</span><br><span class="line">    # 日志切割完之后进行执行脚本，必须空行</span><br><span class="line">    postrotate</span><br><span class="line">       docker ps|grep ingress-gateway|grep -v pause|awk &#39;&#123;print $1&#125;&#39;|xargs docker rm -f</span><br><span class="line">    endscript</span><br><span class="line">    # 和 postrotate 进行对应</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强制执行方式：</p>
<p><code>logrotate -fv /etc/logrotate.d/ingress3</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-f 强制执行</span><br><span class="line">-d debug 模式</span><br><span class="line">-v 显示输出</span><br><span class="line">-s 状态文件路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<!--
#config logrotate
cat > /etc/logrotate.d/ingress << EOF
/data/wisecloud/ingress-gateway/*log {
    copytruncate
    daily
    create
    rotate 15
    missingok
    notifempty
    compress
    sharedscripts
    size 1G
    createolddir
    olddir /data/wisecloud/ingress-gateway/bak
    dateext
    dateformat -%Y%m%d%H
}
EOF
-->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 Linux 命令</title>
    <url>/2017/04/18/linux-java-command/</url>
    <content><![CDATA[<h2 id="常用-Linux-命令"><a href="#常用-Linux-命令" class="headerlink" title="常用 Linux 命令"></a>常用 Linux 命令</h2><h3 id="1-查找文件"><a href="#1-查找文件" class="headerlink" title="1.查找文件"></a>1.查找文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name filename.txt 	根据名称查找&#x2F;目录下的filename.txt文件。</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.xml&quot; 		递归查找所有的xml文件</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.xml&quot; |xargs grep &quot;hello world&quot; 递归查找所有文件内容中包含hello world的xml文件</span><br><span class="line"></span><br><span class="line">grep -H &#39;spring&#39; *.xml 		查找所以有的包含spring的xml文件</span><br><span class="line"></span><br><span class="line">find .&#x2F; -size 0 | xargs rm -f &amp; 删除文件大小为零的文件</span><br><span class="line"></span><br><span class="line">ls -l | grep &#39;.jar&#39; 查找当前目录中的所有jar文件</span><br><span class="line"></span><br><span class="line">grep &#39;test&#39; d* 显示所有以d开头的文件中包含test的行。</span><br><span class="line"></span><br><span class="line">grep &#39;test&#39; aa bb cc 显示在aa，bb，cc文件中匹配test的行。</span><br><span class="line"></span><br><span class="line">grep &#39;[a-z]\&#123;5\&#125;&#39; aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</span><br></pre></td></tr></table></figure>

<h3 id="2-查看一个程序是否运行"><a href="#2-查看一个程序是否运行" class="headerlink" title="2.查看一个程序是否运行"></a>2.查看一个程序是否运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps –ef|grep tomcat 				查看所有有关tomcat的进程</span><br><span class="line"></span><br><span class="line">ps -ef|grep --color java 		高亮要查询的关键字</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="3-终止线程"><a href="#3-终止线程" class="headerlink" title="3.终止线程"></a>3.终止线程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure>

<h3 id="4-查看端口被占用的程序pid"><a href="#4-查看端口被占用的程序pid" class="headerlink" title="4.查看端口被占用的程序pid"></a>4.查看端口被占用的程序pid</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof -i:8080    8080 为端口号</span><br></pre></td></tr></table></figure>

<h3 id="5-复制文件"><a href="#5-复制文件" class="headerlink" title="5.复制文件"></a>5.复制文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp src taget</span><br><span class="line">cp -r src target</span><br><span class="line">scp srcFile remoteUserName@remoteIp:remoteFileAddress 将本地目录拷贝到远程目录 ； 加上-r参数 为文件夹拷贝</span><br><span class="line">scp remoteUserName@remoteIp:&#x2F;path&#x2F;filename &#x2F;local&#x2F;local_destination  将远程目录拷贝到本地目录 ；加上-r 为文件夹拷贝</span><br></pre></td></tr></table></figure>

<h3 id="6-创建和删除目录"><a href="#6-创建和删除目录" class="headerlink" title="6.创建和删除目录"></a>6.创建和删除目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir&#x2F;mkdir</span><br></pre></td></tr></table></figure>

<h3 id="7-查看结尾1000行"><a href="#7-查看结尾1000行" class="headerlink" title="7.查看结尾1000行"></a>7.查看结尾1000行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -1000f filename  查询动态日志文件的时候</span><br></pre></td></tr></table></figure>

<h3 id="8-查看端口占用情况"><a href="#8-查看端口占用情况" class="headerlink" title="8.查看端口占用情况"></a>8.查看端口占用情况</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -tln | grep 8080 查看8080的使用情况</span><br></pre></td></tr></table></figure>

<h3 id="9-端口属于哪个程序"><a href="#9-端口属于哪个程序" class="headerlink" title="9.端口属于哪个程序"></a>9.端口属于哪个程序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof -i:8080</span><br></pre></td></tr></table></figure>

<h3 id="10-查看进程"><a href="#10-查看进程" class="headerlink" title="10.查看进程"></a>10.查看进程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux|grep java 查看java进程</span><br><span class="line">ps aux 查看所有进程</span><br></pre></td></tr></table></figure>

<h3 id="11-文件下载"><a href="#11-文件下载" class="headerlink" title="11.文件下载"></a>11.文件下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;file.tgz</span><br><span class="line">curl http:&#x2F;&#x2F;file.tgz</span><br></pre></td></tr></table></figure>

<h3 id="12-远程登录"><a href="#12-远程登录" class="headerlink" title="12.远程登录"></a>12.远程登录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh userName@ip</span><br></pre></td></tr></table></figure>
<h3 id="13-打印信息"><a href="#13-打印信息" class="headerlink" title="13.打印信息"></a>13.打印信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $JAVA_HOME</span><br></pre></td></tr></table></figure>











]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 挂载磁盘</title>
    <url>/2018/07/26/linux-mount-disk/</url>
    <content><![CDATA[<h1 id="linux-挂载磁盘"><a href="#linux-挂载磁盘" class="headerlink" title="linux 挂载磁盘"></a>linux 挂载磁盘</h1><p>最近需要挂载磁盘，记录一下。</p>
<p>一个500G的磁盘。使用<code>fdisk</code>查看，如果没有就使用<code>lsblk</code>可以查看到现在有哪个磁盘没有挂载。</p>
<p>之后就是挂载操作了。切换成root用户,查看磁盘使用的卷类型：ext4 , xfs</p>
<span id="more"></span>
<p><img src="/images/qiniu/2018-07-26-13-23-23.png" alt="2018-07-26-13-23-23"></p>
<p>1: 然后使用<code>mkfs -t xfs（或ext4） /dev/vdb</code>  </p>
<p>xfs,ext4 ：是指格式化成什么磁盘类型</p>
<p>/dev/vdb ：是指要挂载的磁盘</p>
<p>2: 挂载点 <code>mkdir /data</code> ，建立一个挂载点</p>
<p>3：挂载磁盘<code>mount /dev/vdb /data</code> 将刚刚格式化的磁盘挂载到<code>/data</code>目录</p>
<p>4：修改<code>/etc/fstab</code>文件，复制一行然后修改就可以了，将最后一个数字改为2。</p>
<p><img src="/images/qiniu/2018-07-26-13-33-04.png" alt="2018-07-26-13-33-04"></p>
<h2 id="挂卷快捷操作"><a href="#挂卷快捷操作" class="headerlink" title="挂卷快捷操作"></a>挂卷快捷操作</h2><p>用 lsblk 查看挂载的磁盘名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pvcreate &#x2F;dev&#x2F;vdb</span><br><span class="line"></span><br><span class="line">sudo vgcreate vg02 &#x2F;dev&#x2F;vdb</span><br><span class="line"></span><br><span class="line">sudo lvcreate -l 100%free -n data vg02</span><br><span class="line"></span><br><span class="line">sudo mkfs.xfs -n ftype&#x3D;1 &#x2F;dev&#x2F;vg02&#x2F;data</span><br><span class="line"></span><br><span class="line">sudo mkdir &#x2F;data</span><br><span class="line"></span><br><span class="line">sudo mount &#x2F;dev&#x2F;vg02&#x2F;data &#x2F;data</span><br><span class="line"></span><br><span class="line">sudo echo &#x2F;dev&#x2F;mapper&#x2F;vg02-data &#x2F;data xfs defaults 0 0 &gt;&gt; &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 创建和扩展逻辑卷</title>
    <url>/2019/05/24/linux-pv-lv-disk/</url>
    <content><![CDATA[<h1 id="Linux-创建和扩展逻辑卷"><a href="#Linux-创建和扩展逻辑卷" class="headerlink" title="Linux 创建和扩展逻辑卷"></a>Linux 创建和扩展逻辑卷</h1><p>最近遇到一个事，以前可能是给了一个大磁盘，然后我们全部格式化，一起挂载上去。后来发现用完了，扩展起来不是特别好扩展。<br>所以就找到了一个新的方式，我们使用逻辑卷来操作我们的磁盘。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>一台centos7主机</li>
<li>两块空盘</li>
</ol>
<h2 id="增加逻辑卷"><a href="#增加逻辑卷" class="headerlink" title="增加逻辑卷"></a>增加逻辑卷</h2><span id="more"></span>
<p>准备工组做好后，就可以慢慢操作了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br><span class="line">Linux myhosts 3.10.0-957.5.1.el7.x86_64 #1 SMP Fri Feb 1 14:54:57 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<h3 id="查找空盘"><a href="#查找空盘" class="headerlink" title="查找空盘"></a>查找空盘</h3><p>使用<code>lsblk</code>或者<code>fdisk -l</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lsblk</span><br><span class="line"></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">vda    252:0    0   60G  0 disk</span><br><span class="line">└─vda1 252:1    0   60G  0 part /</span><br><span class="line">vdb    252:16   0  500G  0 disk /data</span><br><span class="line">vdc    252:32   0   10G  0 disk</span><br><span class="line">vdd    252:48   0   10G  0 disk</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 64.4 GB, 64424509440 bytes, 125829120 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x00005822</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048   125821079    62909516   83  Linux</span><br><span class="line"></span><br><span class="line">Disk /dev/vdb: 536.9 GB, 536870912000 bytes, 1048576000 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/vdc: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/vdd: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到两块空盘:<code>/dev/vdc</code>,<code>/dev/vdd</code>。</p>
<h3 id="创建pv"><a href="#创建pv" class="headerlink" title="创建pv"></a>创建pv</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pvcreate /dev/vdc</span></span><br><span class="line">  Physical volume &quot;/dev/vdc&quot; successfully created</span><br></pre></td></tr></table></figure>

<h3 id="创建vg"><a href="#创建vg" class="headerlink" title="创建vg"></a>创建vg</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vgcreate vg00 /dev/vdc</span></span><br><span class="line">  Volume group &quot;vg00&quot; successfully created</span><br></pre></td></tr></table></figure>

<h3 id="创建lv"><a href="#创建lv" class="headerlink" title="创建lv"></a>创建lv</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# lvcreate -L 2g -n vg-data vg00</span><br><span class="line">  Logical volume &quot;vg-data&quot; created.</span><br><span class="line"></span><br><span class="line">[root@chenzhijun ~]#lvs -a</span><br><span class="line">  LV      VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  vg-data vg00 -wi-a----- 2.00g</span><br></pre></td></tr></table></figure>

<p>现在我们看一下我们创建pv,vg,lv</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# pvs</span><br><span class="line">  PV         VG   Fmt  Attr PSize  PFree</span><br><span class="line">  /dev/vdc   vg00 lvm2 a--  10.00g 8.00g</span><br><span class="line">[root@chenzhijun ~]# vgs</span><br><span class="line">  VG   #PV #LV #SN Attr   VSize  VFree</span><br><span class="line">  vg00   1   1   0 wz--n- 10.00g 8.00g</span><br><span class="line">[root@chenzhijun ~]# lvs</span><br><span class="line">  LV      VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  vg-data vg00 -wi-a----- 2.00g</span><br></pre></td></tr></table></figure>
<p>&lt;!–&gt;<br>lvcreate -l 100%free -n docker vg00<br>&lt;–&gt;<br>这个时候我们再进入到<code>/dev/mapper</code>目录，可以看到我们刚刚建立好的逻辑卷，卷组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun mapper]# pwd</span><br><span class="line">/dev/mapper</span><br><span class="line">[root@chenzhijun mapper]# ls</span><br><span class="line">control  vg00-vg--data</span><br></pre></td></tr></table></figure>

<h3 id="格式化区为Linux可用的磁盘格式"><a href="#格式化区为Linux可用的磁盘格式" class="headerlink" title="格式化区为Linux可用的磁盘格式"></a>格式化区为Linux可用的磁盘格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun mapper]# mkfs.xfs /dev/mapper/vg00-vg--data</span><br><span class="line">meta-data=/dev/mapper/vg00-vg--data isize=512    agcount=4, agsize=131072 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0, sparse=0</span><br><span class="line">data     =                       bsize=4096   blocks=524288, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line">log      =internal log           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure>

<h3 id="挂载到相应目录"><a href="#挂载到相应目录" class="headerlink" title="挂载到相应目录"></a>挂载到相应目录</h3><p>Linux知道了这个可用空间的存在，现在我们要继续告诉它在哪里使用，也就是创建挂载点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun /]# mkdir /mydata</span><br><span class="line">[root@chenzhijun /]# ls -l</span><br><span class="line">total 29288</span><br><span class="line">drwxrwxrwx.   6 mwop mwop       77 Apr 10 19:23 app</span><br><span class="line">lrwxrwxrwx.   1 root root        7 Dec 18  2015 bin -&gt; usr/bin</span><br><span class="line">dr-xr-xr-x.   4 root root     4096 Feb 25 15:21 boot</span><br><span class="line">…………</span><br><span class="line">drwxr-xr-x    2 root root        6 May 24 18:21 mydata</span><br></pre></td></tr></table></figure>

<p>使用<code>fdisk -l</code>,这个时候可以看到有了一个新的空间,<code>/dev/mapper/vg00-vg--data</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun /]# fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 64.4 GB, 64424509440 bytes, 125829120 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x00005822</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048   125821079    62909516   83  Linux</span><br><span class="line"></span><br><span class="line">Disk /dev/vdb: 536.9 GB, 536870912000 bytes, 1048576000 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/vdc: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/vdd: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/vg00-vg--data: 2147 MB, 2147483648 bytes, 4194304 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure>

<p>下面我们要把这个磁盘挂载到我们刚刚创建的目录上，编辑<code>/etc/fstab</code>文件：<code>vi /etc/fstab</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># &#x2F;etc&#x2F;fstab</span><br><span class="line"># Created by anaconda on Thu Dec 17 17:11:31 2015</span><br><span class="line">#</span><br><span class="line"># Accessible filesystems, by reference, are maintained under &#39;&#x2F;dev&#x2F;disk&#39;</span><br><span class="line"># See man pages fstab(5), findfs(8), mount(8) and&#x2F;or blkid(8) for more info</span><br><span class="line">#</span><br><span class="line">UUID&#x3D;fc1bfc5d-a5d1-4c3c-afda-167500654723 &#x2F;                       xfs     defaults        0 0</span><br><span class="line">&#x2F;dev&#x2F;vdb &#x2F;data                       auto     defaults        0 2</span><br><span class="line">&#x2F;dev&#x2F;mapper&#x2F;vg00-vg--data &#x2F;mydata                       auto     defaults        0 2</span><br></pre></td></tr></table></figure>

<p>复制第一行<code>yyp</code>。然后照着修改，最后使用<code>mount -a</code>验证下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@chenzhijun /]# vi /etc/fstab</span><br><span class="line">[root@chenzhijun /]# mount -a</span><br><span class="line">[root@chenzhijun /]#</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在再使用<code>df -h</code>就可以看到我们刚刚挂载的盘了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun /]# df -h</span><br><span class="line">Filesystem                 Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1                   60G   56G  4.9G  92% /</span><br><span class="line">devtmpfs                   3.8G     0  3.8G   0% /dev</span><br><span class="line">tmpfs                      3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                      3.9G  384M  3.5G  10% /run</span><br><span class="line">tmpfs                      3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/vdb                   493G  116G  352G  25% /data</span><br><span class="line">tmpfs                      783M     0  783M   0% /run/user/0</span><br><span class="line">overlay                     60G   56G  4.9G  92% /var/lib/docker/overlay2/e919ab7a38f61e66a783503f1fe9ebfdecd79ce08f35b21547bedf6c803c5b4f/merged</span><br><span class="line">shm                         64M     0   64M   0% /var/lib/docker/containers/71a340da3d3e6f4039623c0709026b3546a2a6b1635ff356fcea867c49159f6f/shm</span><br><span class="line">overlay                     60G   56G  4.9G  92% /var/lib/docker/overlay2/c247fba1ff6be41ed3d3c030c9944006f750fb6e1ab162728169077b1093b894/merged</span><br><span class="line">shm                         64M     0   64M   0% /var/lib/docker/containers/b163be285d664d334d81fa0411e41791001a47111d4124eec4c839cb3e907833/shm</span><br><span class="line">overlay                     60G   56G  4.9G  92% /var/lib/docker/overlay2/2827d53a9dc37f826b16211a02795a5f44bd1d69d26d2b7874750004cf18e1ab/merged</span><br><span class="line">shm                         64M     0   64M   0% /var/lib/docker/containers/8973a1b6f16ccd6adb03512acd3e786001b1e357256ecb51ddfcfae7c2b9624b/shm</span><br><span class="line">overlay                     60G   56G  4.9G  92% /var/lib/docker/overlay2/e718bbb03b70866dd91b78a53c1c735edd8279ca3d11797ba4235d5b6e0ef659/merged</span><br><span class="line">shm                         64M     0   64M   0% /var/lib/docker/containers/87cb442aa259b54b88cb11bbfa0f2c35bb328fbc84c3ec5772a92ee90980253a/shm</span><br><span class="line">overlay                     60G   56G  4.9G  92% /var/lib/docker/overlay2/13733d71ac904b8f5dc6f06122627a9b54f3253c69b773c304968bdb200291bf/merged</span><br><span class="line">shm                         64M     0   64M   0% /var/lib/docker/containers/ad876b38777e4a5dde9b1d7d0add1d7808a996b7c4015c55df4abd6078695041/shm</span><br><span class="line">overlay                     60G   56G  4.9G  92% /var/lib/docker/overlay2/492dd394a21d652026f21a73029a1d83968e6e0e319460c80e032ee03d3ebd63/merged</span><br><span class="line">shm                         64M     0   64M   0% /var/lib/docker/containers/24ced8c700f62c11ab8ff3b7559a8576f1a802693c3b532e4728e22256298257/shm</span><br><span class="line">/dev/mapper/vg00-vg--data  2.0G   33M  2.0G   2% /mydata</span><br></pre></td></tr></table></figure>

<p>一个挂载磁盘的操作就完成了。</p>
<h2 id="扩容逻辑卷空间"><a href="#扩容逻辑卷空间" class="headerlink" title="扩容逻辑卷空间"></a>扩容逻辑卷空间</h2><p>刚刚我们是一个10G的盘只使用了2G，磁盘利用率肯定不足嘛，所以我们扩充到8G。命令如下：</p>
<p>先看到一个盘还剩下多少空间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# vgs</span><br><span class="line">  VG   #PV #LV #SN Attr   VSize  VFree</span><br><span class="line">  vg00   1   1   0 wz--n- 10.00g 8.00g</span><br></pre></td></tr></table></figure>

<p>增加6G：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# lvextend -L +6G /dev/mapper/vg00-vg--data</span><br><span class="line">  Size of logical volume vg00/vg-data changed from 2.00 GiB (512 extents) to 8.00 GiB (2048 extents).</span><br><span class="line">  Logical volume vg-data successfully resized.</span><br></pre></td></tr></table></figure>

<p>确认磁盘：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# xfs_growfs /dev/mapper/vg00-vg--data</span><br><span class="line">meta-data=/dev/mapper/vg00-vg--data isize=512    agcount=4, agsize=131072 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0 spinodes=0</span><br><span class="line">data     =                       bsize=4096   blocks=524288, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line">log      =internal               bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 524288 to 2097152</span><br></pre></td></tr></table></figure>

<p>现在再看pv,vg,lv</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# vgs</span><br><span class="line">  VG   #PV #LV #SN Attr   VSize  VFree</span><br><span class="line">  vg00   1   1   0 wz--n- 10.00g 2.00g</span><br><span class="line">[root@chenzhijun ~]# lvs</span><br><span class="line">  LV      VG   Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  vg-data vg00 -wi-ao---- 8.00g</span><br><span class="line">[root@chenzhijun ~]# pvs</span><br><span class="line">  PV         VG   Fmt  Attr PSize  PFree</span><br><span class="line">  /dev/vdc   vg00 lvm2 a--  10.00g 2.00g</span><br></pre></td></tr></table></figure>

<p>使用df看下磁盘空间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# df -h</span><br><span class="line">Filesystem                 Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1                   60G   56G  4.9G  92% /</span><br><span class="line">devtmpfs                   3.8G     0  3.8G   0% /dev</span><br><span class="line">tmpfs                      3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                      3.9G  400M  3.5G  11% /run</span><br><span class="line">tmpfs                      3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/vdb                   493G  116G  352G  25% /data</span><br><span class="line">tmpfs                      783M     0  783M   0% /run/user/0</span><br><span class="line">overlay                     60G   56G  4.9G  92% /var/lib/docker/overlay2/e919ab7a38f61e66a783503f1fe9ebfdecd79ce08f35b21547bedf6c803c5b4f/merged</span><br><span class="line">shm                         64M     0   64M   0% </span><br><span class="line">/dev/mapper/vg00-vg--data  8.0G   33M  8.0G   1% /mydata</span><br></pre></td></tr></table></figure>

<h2 id="扩容VG"><a href="#扩容VG" class="headerlink" title="扩容VG"></a>扩容VG</h2><p>如果现在加了一个新盘，比如刚刚说的<code>/dev/vdd</code>。查看一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# lsblk</span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">vda             252:0    0   60G  0 disk</span><br><span class="line">└─vda1          252:1    0   60G  0 part /</span><br><span class="line">vdb             252:16   0  500G  0 disk /data</span><br><span class="line">vdc             252:32   0   10G  0 disk</span><br><span class="line">└─vg00-vg--data 253:0    0    8G  0 lvm  /mydata</span><br><span class="line">vdd             252:48   0   10G  0 disk</span><br></pre></td></tr></table></figure>

<p>然后增加vg：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# vgs</span><br><span class="line">  VG   #PV #LV #SN Attr   VSize  VFree</span><br><span class="line">  vg00   1   1   0 wz--n- 10.00g 2.00g</span><br><span class="line">[root@chenzhijun ~]# vgextend vg00 /dev/vdd</span><br><span class="line">  Physical volume &quot;/dev/vdd&quot; successfully created</span><br><span class="line">  Volume group &quot;vg00&quot; successfully extended</span><br><span class="line">[root@chenzhijun ~]# vgs</span><br><span class="line">  VG   #PV #LV #SN Attr   VSize  VFree</span><br><span class="line">  vg00   2   1   0 wz--n- 19.99g 11.99g</span><br></pre></td></tr></table></figure>

<p>扩容之前的路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# lvextend -L +8G /dev/mapper/vg00-vg--data</span><br><span class="line">  Size of logical volume vg00/vg-data changed from 8.00 GiB (2048 extents) to 16.00 GiB (4096 extents).</span><br><span class="line">  Logical volume vg-data successfully resized.</span><br><span class="line">[root@chenzhijun ~]# vgs</span><br><span class="line">  VG   #PV #LV #SN Attr   VSize  VFree</span><br><span class="line">  vg00   2   1   0 wz--n- 19.99g 3.99g</span><br><span class="line">[root@chenzhijun ~]# xfs_growfs /dev/mapper/vg00-vg--data</span><br><span class="line">meta-data=/dev/mapper/vg00-vg--data isize=512    agcount=16, agsize=131072 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0 spinodes=0</span><br><span class="line">data     =                       bsize=4096   blocks=2097152, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line">log      =internal               bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 2097152 to 4194304</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看磁盘：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@chenzhijun ~]# df -h</span><br><span class="line">Filesystem                 Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1                   60G   56G  4.9G  92% /</span><br><span class="line">devtmpfs                   3.8G     0  3.8G   0% /dev</span><br><span class="line">tmpfs                      3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                      3.9G  400M  3.5G  11% /run</span><br><span class="line">tmpfs                      3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/vdb                   493G  117G  351G  25% /data</span><br><span class="line">tmpfs                      783M     0  783M   0% /run/user/0</span><br><span class="line">overlay                     60G   56G  4.9G  92% /var/lib/docker/overlay2/e919ab7a38f61e66a783503f1fe9ebfdecd79ce08f35b21547bedf6c803c5b4f/merged</span><br><span class="line">shm                         64M     0   64M   0% /var/lib/docker/containers/24ced8c700f62c11ab8ff3b7559a8576f1a802693c3b532e4728e22256298257/shm</span><br><span class="line">/dev/mapper/vg00-vg--data   16G   34M   16G   1% /mydata</span><br><span class="line"></span><br><span class="line">[root@chenzhijun ~]# lsblk</span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">vda             252:0    0   60G  0 disk</span><br><span class="line">└─vda1          252:1    0   60G  0 part /</span><br><span class="line">vdb             252:16   0  500G  0 disk /data</span><br><span class="line">vdc             252:32   0   10G  0 disk</span><br><span class="line">└─vg00-vg--data 253:0    0   16G  0 lvm  /mydata</span><br><span class="line">vdd             252:48   0   10G  0 disk</span><br><span class="line">└─vg00-vg--data 253:0    0   16G  0 lvm  /mydata</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="lv删除"><a href="#lv删除" class="headerlink" title="lv删除"></a>lv删除</h2><p><code>lvremove </code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>pv</tag>
        <tag>lv</tag>
        <tag>disk</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 工具-socat</title>
    <url>/2019/06/30/linux-tool-socat/</url>
    <content><![CDATA[<h1 id="Linux-工具-socat"><a href="#Linux-工具-socat" class="headerlink" title="Linux 工具-socat"></a>Linux 工具-socat</h1><p>socat是一个多功能的网络工具，官网：<a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a></p>
<h2 id="安装socat"><a href="#安装socat" class="headerlink" title="安装socat"></a>安装socat</h2><p>安装方式很简单：<code>yum install -y socat</code>,就可以了，当然如果是ubuntu的机器就是用<code>apt</code></p>
<h2 id="使用socat"><a href="#使用socat" class="headerlink" title="使用socat"></a>使用socat</h2><p>公司内部的网络限制比较严格，只有一些常用的端口能正常访问，因此调试的时候非常麻烦，比如你的应用程序端口是19995，但是公司只能是8080来访问，这个时候怎么办？使用nginx或haproxy当然可以，但是麻烦啊，配置搞一堆。。但是使用socat就很方便了:<code>socat TCP4-LISTEN:&#123;port1&#125;,reuseaddr,fork TCP4:&#123;ip:port2&#125;</code> ，比如你有三台机器A(127.0.0.1)；B(127.0.0.2）；C（192.168.1.1）。B能访问A的8080端口，但是不能访问C的9090端口，而服务又监听的是C的9090端口，A能访问C的9090端口。所以很当然会想到B–&gt;A:8080–&gt;C:9090。也就是在A做一层反向代理。socat就是这样的。在A上我们执行：<code>socat TCP4-LISTEN:8080,reuseaddr,fork TCP4:192.168.1.1:9090</code>。然后B就访问A:8080,就能访问到C的9090端口了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 工具-tar</title>
    <url>/2019/06/30/linux-tool-tar/</url>
    <content><![CDATA[<h1 id="Linux-工具-tar"><a href="#Linux-工具-tar" class="headerlink" title="Linux 工具-tar"></a>Linux 工具-tar</h1><p>tar 命令应该是我们经常用的了，它主要的功能是用来对文件的解压缩操作。如果要看tar的具体操作可以使用:<code>man tar</code>，Linux的发行版本默认都会有 tar 命令</p>
<h2 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h2><p>tar 常用来解压<code>tar.gz</code>,<code>tar</code>的文件。使用的方式：<code>tar -zxvf xxx.tar.gz</code></p>
<h2 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h2><p>通常我们也会有需要将多个文件压缩成一个文件的需求，比如传输文件。这个时候我们就可以使用<code>tar -zvcf xxx.tar.gz file-dir-path1 file-dir-path2 file-dir-path-n</code> 其中<code>path1</code>,<code>path2</code>,<code>path-n</code>可以是多个或者单个。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 logstash 输出到 Elasticsearch 时指定 document_id</title>
    <url>/2018/04/02/logstash-output-elasticsearch-document-id/</url>
    <content><![CDATA[<p>今天使用elk搜集日志的时候想到一个事情，是否可以指定es索引中的document_id。查了资料之后发现还真有这个：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">elasticsearch</span> &#123;</span><br><span class="line">        <span class="string">hosts</span> <span class="string">=&gt;</span> [ <span class="string">&quot;localhost:9200&quot;</span> ]</span><br><span class="line">        <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">&quot;<span class="template-variable">%&#123;[fields][service_name]&#125;</span>-<span class="template-variable">%&#123;+YYYY.MM.dd&#125;</span>&quot;</span></span><br><span class="line">        <span class="string">document_id</span> <span class="string">=&gt;</span> <span class="string">&quot;<span class="template-variable">%&#123;@timestamp&#125;</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就是在<code>logstash.conf</code>中的output中，设置elasticsearch里面document_id就可以了。就是这么简单。当然我这里是用timestamp做的id，其实可以自己换成一个其它的。<br>es 对一个 id 添加两次是支持的，里面的字段 version 会加 1。</p>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Logstash发送异常邮件</title>
    <url>/2018/01/09/logstash-send-email/</url>
    <content><![CDATA[<h1 id="使用Logstash发送异常邮件"><a href="#使用Logstash发送异常邮件" class="headerlink" title="使用Logstash发送异常邮件"></a>使用Logstash发送异常邮件</h1><p>前端时间我们讲了<a href="http://chenzhijun.top/2017/12/12/elasticsearch-logstash-kibana-part/">如何使用elk搭建日志系统</a>,以及如何<a href="http://chenzhijun.top/2017/12/27/elk-docker/">使用Docker搭建ELK日志系统</a>。虽然我们可以不用再去日志服务器找日志了，但是这样也有问题，我怎么知道什么时候会出现异常，不出现异常我也没必要去kibana查日志啊。</p>
<p>今天我们就要解决这个问题。当然解决的方式比较简单。如果有大神有更好的方式欢迎一起分享。</p>
<h2 id="使用Logstash发送邮件"><a href="#使用Logstash发送邮件" class="headerlink" title="使用Logstash发送邮件"></a>使用Logstash发送邮件</h2><p>我们使用的是Logstash来发送邮件，网上我也搜了elastalert,但是感觉又多了一个服务，又要多去维护一个服务。后来发现logstash自带了邮件发送功能，那就直接用logstash就好了。</p>
<p>非常的简单易用，在<code>logstash.conf</code>中增加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    host &#x3D;&gt; &quot;localhost&quot;</span><br><span class="line">    port &#x3D;&gt; &quot;5043&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">   if [fields][doc_type] &#x3D;&#x3D; &#39;order&#39; &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">			match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;TIMESTAMP_ISO8601:timestamp&#125; %&#123;LOGLEVEL:level&#125; %&#123;JAVALOGMESSAGE:msg&#125;&quot; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">        hosts &#x3D;&gt; [&quot;localhost:9200&quot;]</span><br><span class="line">        index &#x3D;&gt; &quot;%&#123;[fields][doc_type]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if &quot;ERROR&quot; &#x3D;&#x3D; [level] &#123;</span><br><span class="line">    email &#123;</span><br><span class="line">        to &#x3D;&gt; &quot;5228******@qq.com,chen****@163.cn&quot;</span><br><span class="line">        cc &#x3D;&gt; &quot;email_chen****@163.com&quot;</span><br><span class="line">        via &#x3D;&gt; &quot;smtp&quot;</span><br><span class="line">        subject &#x3D;&gt; &quot;标题，ERROR: %&#123;[fields][doc_type]&#125;项目出现异常&quot;</span><br><span class="line">        htmlbody &#x3D;&gt; &quot;消息主体：%&#123;message&#125;&quot;</span><br><span class="line">        body &#x3D;&gt; &quot;Tags: %&#123;tags&#125;\\n\\Content:\\n%&#123;message&#125;&quot;</span><br><span class="line">        from &#x3D;&gt; &quot;email_chen****@163.com&quot;</span><br><span class="line">        address &#x3D;&gt; &quot;smtp.163.com&quot;</span><br><span class="line">        username &#x3D;&gt; &quot;email_chen****@163.com&quot;</span><br><span class="line">        password &#x3D;&gt; &quot;*****&quot; # pop3密码或者登陆密码</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是增加了下面这段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if &quot;ERROR&quot; &#x3D;&#x3D; [level] &#123;</span><br><span class="line">  email &#123;</span><br><span class="line">      to &#x3D;&gt; &quot;5228******@qq.com,chen****@163.cn&quot;</span><br><span class="line">      cc &#x3D;&gt; &quot;email_chen****@163.com&quot;</span><br><span class="line">      via &#x3D;&gt; &quot;smtp&quot;</span><br><span class="line">      subject &#x3D;&gt; &quot;标题，ERROR: %&#123;[fields][doc_type]&#125;项目出现异常&quot;</span><br><span class="line">      htmlbody &#x3D;&gt; &quot;消息主体：%&#123;message&#125;&quot;</span><br><span class="line">      body &#x3D;&gt; &quot;Tags: %&#123;tags&#125;\\n\\Content:\\n%&#123;message&#125;&quot;</span><br><span class="line">      from &#x3D;&gt; &quot;email_chen****@163.com&quot;</span><br><span class="line">      address &#x3D;&gt; &quot;smtp.163.com&quot;</span><br><span class="line">      username &#x3D;&gt; &quot;email_chen****@163.com&quot;</span><br><span class="line">      password &#x3D;&gt; &quot;*****&quot; # pop3密码或者登陆密码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只对ERROR级别的日志进行发送邮件，这里用了if条件语句。如果你看过之前的两篇文章，我想这里你是很容易就能弄懂的。当然这种方式不一定很好，如果你有更好的想法，欢迎交流。</p>
<!--

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    host &#x3D;&gt; &quot;localhost&quot;</span><br><span class="line">    port &#x3D;&gt; &quot;5044&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">			match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;TIMESTAMP_ISO8601:timestamp&#125; %&#123;LOGLEVEL:level&#125; %&#123;JAVALOGMESSAGE:msg&#125;&quot; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span><br><span class="line"></span><br><span class="line">  if &quot;ERROR&quot; &#x3D;&#x3D; [level] or [message] &#x3D;~ &#x2F;xception&#x2F; &#123;</span><br><span class="line">    email &#123;</span><br><span class="line">        to &#x3D;&gt; &quot;xukai@ap-ec.cn,wangfei@ap-ec.cn,xiaoxq@ap-ec.cn,zhangchi@ap-ec.cn,shangxw@ap-ec.cn,guisw@ap-ec.cn,chenzj@ap-ec.cn&quot;</span><br><span class="line">        #to &#x3D;&gt; &quot;chenzj@ap-ec.cn&quot;</span><br><span class="line">        cc &#x3D;&gt; &quot;noreply_czj@163.com&quot;</span><br><span class="line">        via &#x3D;&gt; &quot;smtp&quot;</span><br><span class="line">        subject &#x3D;&gt; &quot;请注意项目可能出现异常,异常文件:%&#123;source&#125;&quot;</span><br><span class="line">        # htmlbody &#x3D;&gt; &quot;消息主体：%&#123;message&#125;&quot;</span><br><span class="line">        body &#x3D;&gt; &quot;日志信息:\n%&#123;message&#125;\n\n请在日志文件中查看详细信息,机器地址：%&#123;[fields][server_ip]&#125;。\n\n\n\n\n-----------------------------华丽的分割线---------------------\n这是系统发送邮件，请勿回复。\n如有需要请联系chenzhijun。chenzj@ap-ec.cn&quot;</span><br><span class="line">        from &#x3D;&gt; &quot;noreply_czj@163.com&quot;</span><br><span class="line">        address &#x3D;&gt; &quot;smtp.163.com&quot;</span><br><span class="line">        username &#x3D;&gt; &quot;noreply_czj@163.com&quot;</span><br><span class="line">        password &#x3D;&gt; &quot;noreplyczj123&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    http &#123;</span><br><span class="line">        url &#x3D;&gt; &quot;https:&#x2F;&#x2F;oapi.dingtalk.com&#x2F;robot&#x2F;send?access_token&#x3D;3f39f66edc27dbd5c8206183741c372ec459b653af0cd90841edffbbb872cf1b&quot;</span><br><span class="line">        content_type &#x3D;&gt; &quot;application&#x2F;json&quot;</span><br><span class="line">        http_method &#x3D;&gt; &quot;post&quot;</span><br><span class="line">        message &#x3D;&gt; &#39;&#123;&quot;msgtype&quot;: &quot;text&quot;,&quot;text&quot;: &#123;&quot;content&quot;: &quot;%&#123;message&#125;&quot;&#125;&#125;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.prospectors:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Each - is a prospector. Most options can be set at the prospector level, so</span></span><br><span class="line"><span class="comment"># you can use different prospectors for various configurations.</span></span><br><span class="line"><span class="comment"># Below are the prospector specific configurations.</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Change to true to enable this prospector configuration.</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Paths that should be crawled and fetched. Glob based paths.</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/home/cncsen/*/*.log</span></span><br><span class="line">    <span class="comment">#- /home/cncsen/customer/*/*.log</span></span><br><span class="line">    <span class="comment">#- /home/cncsen/contract/*.log</span></span><br><span class="line">    <span class="comment">#- c:\programdata\elasticsearch\logs\*</span></span><br><span class="line">  <span class="attr">multiline:</span></span><br><span class="line">      <span class="attr">pattern:</span> <span class="string">^\d&#123;4&#125;</span></span><br><span class="line">      <span class="attr">negate:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">match:</span> <span class="string">after</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">server_ip:</span> <span class="number">221</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-消息中间件（二）任务队列</title>
    <url>/2017/09/18/message-rabbitmq-2/</url>
    <content><![CDATA[<h2 id="消息中间件-RabbitMQ-二-任务队列"><a href="#消息中间件-RabbitMQ-二-任务队列" class="headerlink" title="消息中间件 RabbitMQ (二) 任务队列"></a>消息中间件 RabbitMQ (二) 任务队列</h2><blockquote>
<p>第一篇中简单介绍了mq的使用，那么第二节中来了解下mq的其它内容.</p>
</blockquote>
<h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p>这节我们将建立一个工作队列来讲任务分发到不同的消费工作者中去。工作队列的主要思想是避免在做资源密集型任务的同时又不得不等待一个个完成。这种时候我们像消息一样封装所要完成的任务然后将它发送到队列中，在后台运行的工作线程会将任务拿出，然后执行这个任务。当运行多个工作线程的时候，任务对他们都是可见的。</p>
<p>网络应用中如果一个任务无法快速执行完，那么工作队列就非常有用。</p>
<span id="more"></span>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>像上节一样，我们准备两个类，一个生产(Tasker.java)一个消费(Worker.java).</p>
<p><code>Task.java</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tasker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;task_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String message = getMessage(new String[]&#123;&quot;this is my message&quot;&#125;);</span></span><br><span class="line">        <span class="comment">//channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String message = getMessage(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;this is my message&quot;</span>&#125;);</span><br><span class="line">            message = message + i;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String[] strings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> joinStrings(strings, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">joinStrings</span><span class="params">(String[] strings, String delimiter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = strings.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        StringBuilder words = <span class="keyword">new</span> StringBuilder(strings[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            words.append(delimiter).append(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Worker.java</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;task_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                String messageReceiv = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[x] received: &quot;</span> + messageReceiv);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    doWork(messageReceiv);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Done&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(String task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : task.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这次的模拟中，我们需要同时启动多个<code>Worker</code>，这样我们才能在控制台中看到不同的Worker会打印不同的值。</p>
<h3 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h3><p>使用任务队列的一个优点是易于并行工作，当一个worker在工作的时候，我们可以将任务给另一个worker。默认情况下，RabbitMQ会发送任务给下一个消费者，着这样每一个消费者能得到一个比较平均的任务数量。这种任务转发方式叫做循环调度。可以启动两个Worker进行尝试一下。</p>
<p><img src="/images/qiniu/2017-09-18-17-13-33.png" alt="2017-09-18-17-13-33"></p>
<p><img src="/images/qiniu/2017-09-18-17-13-59.png" alt="2017-09-18-17-13-59"></p>
<h3 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h3><p>一个任务执行的时间可能需要花费数秒。我们可能想要知道一个消费者在执行了一个长时间任务的时候，如果只是完成了一部分，然后挂掉了怎么办？用我们现在的代码，一旦RabbitMQ传递了一个消息给消费者，它就会立即将它做删除标记。所以在这个问题上，如果你在消费者执行期间kill掉了它，我们就永久的失去了这个消息。我们也会丢失掉所有MQ中间件给它的但是实际上并没有被正确处理的所有消息，以及这些消息的所有详细内容。</p>
<p>但是实际开发中，我们并不想失去任何一个队列中的任务。如果一个worker挂掉了，我们可能想要将这个任务转发给其他的worker。</p>
<p>为了保证消息绝不丢失，RabbitMQ支持<code>[消息完成确认](http://www.rabbitmq.com/confirms.html)</code>,就像网络http请求的<code>ACK</code>(确认)。消费者在接收到详细完整的消息，并且完成了消息的任务，然后会发送一个ack给RabbitMQ，RabbitMQ才会删除它。</p>
<p>如果消费者线程死了(channel关闭，connection关闭，或者TCP 连接丢失)并且挂掉之前没有发送<code>ACK</code>。RabbitMQ会知道消息没有圆满完成，然后会让它重新排到队列中去，如果在这个时候有其它的消费者在线，它就会马上将消息推送给其他消费者。这个方式就能确保尽管有worker不稳定挂掉了，消息也不会丢失。</p>
<p>这里是不会有任何消息超时的，RabbitMQ只会在Worker挂掉之后才会重新转发消息，就算一个处理消息的过程会花费很长很长的时间。</p>
<p>默认情况下消息确认是打开的，<a href="http://www.rabbitmq.com/confirms.html">Manual message acknowledgments</a>。在之前的例子中我们明确的关闭了它<code>autoAck=true</code>;如果你在声明中用到了<code>autoAck=false</code>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> autoAck=<span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(QUEUE_NAME, autoAck, consumer);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个时候把线程时间拉长一点，然后强制kill掉，这个worker挂掉之后也不会重新被MQ转发消息了。</p>
<blockquote>
<p>ps: 忘记消息确认会引发一个非常严重的后果，如果它不能释放未确认的消息的内容,RabbitMQ会不停的吃掉内存空间，如果要调试的话可以在Linux下使用<code>sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</code> 或者windows下使用<code>rabbitmqctl.bat list_queues name messages_ready messages_unacknowledged</code>.</p>
</blockquote>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>我们知道了就算消费者挂了，也能保证任务不会丢失。但是如果我们的RabbitMQ服务器宕机了呢？队列中的任务还是会丢失。</p>
<p>当RabbitMQ退出或者宕机的时候，它会丢失掉所有的队列和消息，除非你对它进行设置。要保证消息不会丢失，必须先做两件事情，我们需要标记队列和消息可以持久化。</p>
<p>首先我们需要保证RabbitMQ绝不会丢失掉我们的队列。为了做到这个，我们需要声明它为<code>durable</code>持久化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(QUEUE_NAME,durable,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的命令本身没有错误，但是如果队列中已经有了<code>QUEUE_NAME</code>的队列，并且前面定义的队列不是<code>durable</code>的，RabbitMQ不会允许你重新用不同的参数定义一个已经存在的队列，如果尝试这样做的话，它会返回一个错误。变通的方法就是取另一个唯一的名字。如果队列名字改了，消费者和生产者要对应到一个队列上。</p>
<p>声明了队列为持续化之后，我们也需要将消息标记为持久化，通过设置<code>MessageProperties</code>(继承至<code>BasicProperties</code>) 的值为<code>PERSISTENT_TEXT_PLAIN</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>消息持久化注意：标记消息持久化不能完全的保证消息不会被丢失，尽管它告诉了RabbitMQ保存消息到磁盘，但是在RabbitMQ接收到消息，这里仍然有一个很短的时间，可能让RabbitMQ没有保存它到磁盘。RabbitMQ不允许对每一个消息进行<code>fsync</code>，它仅仅是存到缓存当中而不是真的写入到磁盘当中。这种持久化的保证不是特别稳定的，但是它也足够我们在简单的任务队列中使用。如果你需要稳定的强保证你可以使用<code>[publish confirms](https://www.rabbitmq.com/confirms.html)</code></p>
</blockquote>
<h3 id="公平转发"><a href="#公平转发" class="headerlink" title="公平转发"></a>公平转发</h3><p>你可能注意到了任务分发有时候并不是精确的像我们期待的那样，例如有一种场景：两个worker，当所有的消息不管是简单的还是难的，可能出现一个worker非常忙，而另一个却没有什么任务。RabbitMQ是不会知道这回事的，然后还是照样的循环分配任务。</p>
<p>这种事情的发生是因为RabbitMQ只是在一个消息进入到队列中转发一个消息，它不会去为消费者考虑未确认的消息，它只是盲目的一个接一个的转发消息给一个消费者。</p>
<p>为了防止这种事情，我们可以使用<code>basicQos</code>方法来设置<code>prefetchCount=1</code>属性值。它会告诉RabbitMQ不要在同一个时间段给一个worker太多的任务，或者换种说话，不要转发一个新的消息给一个worker直到它完成前一个队列并且回复<code>ACK</code>。另外，MQ会将这个任务转发给下一个不忙的worker。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> prefetchCount=<span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意队列大小，如果所有的worker都很忙，队列就有可能会堵塞，你可能就需要持续关注它，或者增加worker，或者采用其它的策略来代替。</p>
</blockquote>
<p>使用消息的<code>消息确认</code>(acknowledgments)和<code>prefetchCount</code>,你可以建立一个工作队列，持久化的设置可以让RabbitMQ就算重启，任务也不会消失。</p>
<p>如果想要了解更多的关于<code>Channel</code>的方法和<code>MessageProperties</code>的属性，你可以在线看<a href="http://www.rabbitmq.com/releases/rabbitmq-java-client/current-javadoc/overview-summary.html">文档</a></p>
<p>参考文档：<br><a href="http://www.rabbitmq.com/tutorials/tutorial-two-java.html">RabbitMQ Java</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>message</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-消息中间件（三）订阅与发布</title>
    <url>/2017/09/22/message-rabbitmq-3/</url>
    <content><![CDATA[<h2 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h2><p>之前的实例我们都是将任务精确的转发给某一个工作线程（消费者）。这节我们讲讲怎么将一个任务转发给多个消费者。这种模式就是闻名的“订阅/发布”模式。</p>
<p>我们的初步想法便是一个发布者发布了一个消息，多个消费者接收到消息，做不同的事情。</p>
<h3 id="交换机-Exchanges"><a href="#交换机-Exchanges" class="headerlink" title="交换机(Exchanges)"></a>交换机(Exchanges)</h3><p>前面已经说了了我们是通过队列来接受和发送消息的(p-q-c)[p:发布者，q:队列，r:消费者]。消息是由p 发布到q,q 再发给c。其实Rabbit又一个消息模型，在我们完成实例前，我们先来看看Rabbit的所有消息模型。</p>
<p>在Rabbit消息模型中最核心的点是生产者从不直接发送消息给队列。实际上，生产者都不知道生产的消息给了那个队列。</p>
<p>相反的，生产者只是给exchange(交换机)发送消息。交换机实际上是一个非常简单的东西，一边是从生产者接受消息，另一边就是将消息推送给队列。交换机必须明确的知道他们接到消息后该怎么处理消息：应该是将消息发送给一个明确的队列？还是应该给所有的队列？又或者是直接忽略不管？这些规则都是由交换机的类型去定义的。</p>
<p><img src="/images/qiniu/2017-09-22-11-12-44.png" alt="Rabbit消息模型"></p>
<p>有一些可用的交换机类型是：<code>direc</code>,<code>topic</code>,<code>headers</code>,<code>fanout</code>。今天我们讲的类型主要是<code>fanout</code>。我们可以先声明一个类型：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;exchange_name&quot;</span>,<span class="string">&quot;fanout&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>fanout</code>交换机非常简单，就像它的名字一样（扇形交换机,广播），它收到消息后就广播给所有它知道的队列。</p>
<p><img src="/images/qiniu/2017-09-22-11-52-29.png" alt="扇形交换机"></p>
<blockquote>
<p>listing exchanges 想知道服务器可以支持哪些交换机类型可以使用：<code>rabbitmqctl list_exchanges</code></p>
</blockquote>
<p>之前的例子中我们使用的是：<code>channel.basicPublic(&quot;&quot;,&quot;hello&quot;,null,message.getBytes());</code>,这种方式是没有声明<code>exchange_name</code>的。默认的话是使用一个无名交换机，消息经过特定的<code>routingKey</code>转发到队列。现在我们可以用我们自定的exchangeName来代替：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;exchangeName&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure>

<h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>之前我们都是声明了特定的队列名称的,因为之前的消息模型中，我们需要将生产者和消费者指定到同一个队列，所以声明队列的名称对我们很重要。</p>
<p>但是在<code>fanout</code>本节中，我们需要的是的监听所有的消息，我们关注的是最新的消息，而不是旧数据。要解决这个，我们需要先做两件事：</p>
<ol>
<li><p>不管是什么时候我们连接到Rabbit 我们都需要一个空的，新队列。要做到这点，我们可以用一个随机名字来创建一个新队列，当然更好的是，让rabbitMQ帮我们选择一个随机名字。</p>
</li>
<li><p>一旦我们的消费者消费完断开了和队列的连接，队列应该自己删除掉。</p>
</li>
</ol>
<p>在Java中，当我们提供一个无参的方法：<code>queueDeclare()</code>,我们创建了一个不可持久化，独立的，可自动删除的带有随机生成名字的队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQuere();</span><br></pre></td></tr></table></figure>

<p><code>queueName</code>就是我们生成的随机队列名，它可能像：<code>amq.gen-JzTY20BRgKO-HjmUJj0wLg</code>.</p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>我们已经知道如何创建一个<code>fanout</code>类型的交换机和队列，现在我们需要告诉交换机发送消息给我们的队列。交换机和队列之间的这种关系就叫做绑定:</p>
<p><img src="/images/qiniu/2017-09-22-11-38-02.png" alt="交换机-队列关系图"></p>
<blockquote>
<p>列出所有已存在的绑定 <code>rabbitmqctl list_bindings</code></p>
</blockquote>
<p>全模型图为：</p>
<p><img src="/images/qiniu/2017-09-22-11-40-53.png" alt="发布-订阅关系图"></p>
<h3 id="实例编程"><a href="#实例编程" class="headerlink" title="实例编程"></a>实例编程</h3><p>生产者程序和之前的代码产不多，最大的不同点就是我们现在想要发布消息给我们自己定义的<code>nameame</code>的exchange,而不再是之前无名的exchanage。现在当我们发送消息的时候，我们就必须提供一个<code>routingKey</code>,不过由于是<code>fanout</code>类型的exchange,它具有广播给所有的队列的作用。(routingKey的主要作用是在exchange和queue中做选择)。下面是生产者代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sudo rabbitmqctl list_exchanges</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String message = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[sent] : &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubcribeReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * No-op implementation of &#123;<span class="doctag">@link</span> Consumer#handleDelivery&#125;.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                String messsage = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[x] Received : &quot;</span> + messsage+<span class="string">&quot;...ooooooo&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别注意，此例中的消费中要先启动。如果exchange没有绑定queue，那么交换机接收到消息会直接抛弃它。该例中，生产者只是声明了交换机，而不会创建队列。这种模型也跟我们之前说的也是一样的，生产者并不知道消息给了那个队列。</p>
<p>如果要多个消费者接收到不同的消息做不同的事情，那么就让消费者绑定到同一个exchange_name,然后监听就可以了。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="http://www.rabbitmq.com/tutorials/tutorial-three-java.html">RabbitMQ part3</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>message</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-消息中间件（四）路由</title>
    <url>/2017/09/25/message-rabbitmq-4/</url>
    <content><![CDATA[<h2 id="RabbitMQ-消息中间件（四）路由"><a href="#RabbitMQ-消息中间件（四）路由" class="headerlink" title="RabbitMQ-消息中间件（四）路由"></a>RabbitMQ-消息中间件（四）路由</h2><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>上面一节我们用交换机<code>fanout</code>的方式进行了广播，这种方式如果在不需要对消息进行区分是没关系的，可以使用。但是有些场景下，比如日志打印，对于一些error的日志，我可能需要的是要保存到磁盘中进行持久化，而对于一些warn，info的日志，我可能只是想着输出下就可以了。那么这种情况下我们还用fanout的方式可能就不行了，我可能想要的是某一个队列接受特定的某一类消息做特别处理。比如我想要一个error队列专门来监听error的消息做打印，其它的队列就不管error的消息了。</p>
<h3 id="绑定-Bingdings"><a href="#绑定-Bingdings" class="headerlink" title="绑定(Bingdings)"></a>绑定(Bingdings)</h3><p>在前面，其实我们已经创建过“绑定”了。比如我们使用到了：<code>channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);</code>,“绑定”：中文意思就是你和我之间有些关联，我们之间有关系；那么MQ也是，它的关联是<code>队列</code>和<code>交换机</code>，它绑定的是队列和交换机的关系，也就是说，这个队列对这个交换机感兴趣，会接受这个交换机的信息。但是接受什么消息了？这个可以在绑定的时候用另外一个参数来设置，也就是<code>路由</code>：俗成绑定的key。<code>channel.queueBind(queueName, EXCHANGE_NAME, &quot;binding key,set by yourself&quot;);</code>。这里我们可以看到，<code>绑定key</code>是否生效其实是跟<code>交换机</code>类型相关的，如果交换机是<code>fanout</code>，那就跟<code>key</code>没关系了，因为它是广播，只要有队列绑定到我交换机，产生了关系，我就懒的管你要不要，直接给你。这个有点类似中国爸妈，你是我孩子，只要我想给，你不要也得要，哈哈。</p>
<span id="more"></span>

<h3 id="Direct-交换机"><a href="#Direct-交换机" class="headerlink" title="Direct 交换机"></a>Direct 交换机</h3><p>前面章节，我们采用的<code>fanout</code>交换机，它是给所有队列发送消息。很明显在我们的日志系统需求里面不太适合，我们希望对消息进行一次过滤，过滤之后再发送给不同的队列做处理，比如有的队列接受消息去打印，有的去写磁盘等等。所以请注意了<em>如果你不想管事，那就用fanout，把消息给你，你自己去做处理，直观无脑给消息就行，其他的就不用关心了。</em>。用不了<code>fanout</code>，那我们用什么了？rabbitMQ有四种交换机，我们可以选择<code>direct</code>。<code>direct</code>交换机背后的算法规则很简单，队列的<code>bingding key</code>和消息的<code>routing key</code>那个能精确匹配就给队列发消息。</p>
<p><img src="/images/qiniu/2017-09-25-11-37-27.png" alt="direct 关联图"></p>
<p>图中非常简单，两个队列同时绑定了<code>direct</code>交换机，Q1的范围是根据<code>bingding key</code>为orange的值得消息。它表明，如果消息中的<code>routing key</code> 为orange，那么消息就发送给Q1。Q2绑定了两个：black、green，如果消息中有<code>routing key </code>为black和green的都发送个Q2。那么如果消息没有routing key,或者队列没有bingding key，那么这种消息，交换机会直接丢弃。</p>
<h3 id="多绑定"><a href="#多绑定" class="headerlink" title="多绑定"></a>多绑定</h3><p><img src="/images/qiniu/2017-09-25-11-43-22.png" alt="多绑定图"></p>
<p>多个队列绑定同一个<code>bingding key</code>,在rabbitMQ中是合法的。如上图中，如果是这种形式，那么<code>direct</code>交换机的作用就是类似<code>fanout</code>，不过只有当消息的<code>routing key</code>和<code>bingding key</code>一直，上图中是消息如果路由key是black，那么交换机就会将消息分发给Q1和Q2两个队列。</p>
<h3 id="实践-发送日志-生产者"><a href="#实践-发送日志-生产者" class="headerlink" title="实践: 发送日志(生产者)"></a>实践: 发送日志(生产者)</h3><p>现在回到我们之前的问题，如果我们想要不同的队列，比如Q1将日志写入磁盘，Q2打印warn日志，Q3接收info日志。我们可以使用<code>drect</code>交换机，然后给不同的队列绑定<code>bingding key</code>。所以对于我们的生产者端：</p>
<ol>
<li>声明交换机还是跟之前的类似，我们必须先声明一个交换机：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;direct&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>传递消息：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicPublish(EXCHANGE_NAME, severity, <span class="keyword">null</span>, message.getBytes());</span><br></pre></td></tr></table></figure>

<h3 id="订阅-Subscribing"><a href="#订阅-Subscribing" class="headerlink" title="订阅(Subscribing)"></a>订阅(Subscribing)</h3><p>消费者对消息的接收和之前的有一个不同，我们用bingding key来绑定消费者只对感兴趣的消息进行接收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="keyword">for</span>(String serverType : msgType)&#123; <span class="comment">//serverType,每一个queue绑定一个消息类型</span></span><br><span class="line">    channel.queueBind(queueName,EXCHANGE_NAME,serverType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/qiniu/2017-09-25-13-54-52.png" alt="实际绑定图"> </p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>生产者，在发送消息的时候特别注意<code>routing key</code>,在此例子中也就是我们for循环里面的key：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.route;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogDirect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;log_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;warn&quot;</span>, <span class="string">&quot;this is message of warn .....&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;debug&quot;</span>, <span class="string">&quot;this is message of debug .....&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;info&quot;</span>, <span class="string">&quot;this is message of info .....&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;this is message of error .....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, key, <span class="keyword">null</span>, map.get(key).getBytes());</span><br><span class="line">            System.out.println(EXCHANGE_NAME + <span class="string">&quot;,serverType:&quot;</span> + key + <span class="string">&quot;,message:&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费者,这里我们使用的是两种方式，第一种是全部绑定到一个队列，另外注释的是开启4个队列，对不动的消息做不同的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.route;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogDirect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;log_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        String[] messageType = new String[]&#123;&quot;warn&quot;, &quot;info&quot;, &quot;debug&quot;, &quot;error&quot;&#125;;</span></span><br><span class="line"><span class="comment">//        for (String serverType : messageType) &#123;</span></span><br><span class="line"><span class="comment">//            String queueName = channel.queueDeclare().getQueue();</span></span><br><span class="line"><span class="comment">//            channel.queueBind(queueName, EXCHANGE_NAME, serverType);</span></span><br><span class="line"><span class="comment">//            Consumer consumer = createConsumer(serverType, channel);</span></span><br><span class="line"><span class="comment">//            boolean isAck = true;</span></span><br><span class="line"><span class="comment">//            channel.basicConsume(queueName, isAck, consumer);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        String[] messageType = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;warn&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;debug&quot;</span>, <span class="string">&quot;error&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String serverType : messageType) &#123;</span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, serverType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;[x] received,routeKey: &quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;,message:&quot;</span> + <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">boolean</span> isAck = <span class="keyword">true</span>;</span><br><span class="line">        channel.basicConsume(queueName, isAck, consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Consumer <span class="title">createConsumer</span><span class="params">(String serverType, Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serverType.equals(<span class="string">&quot;warn&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;[x] received,routeKey: &quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;,message:&quot;</span> + <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;warn消息我们只是打印.....:&quot;</span> + <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverType.equals(<span class="string">&quot;info&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;[x] received,routeKey: &quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;,message:&quot;</span> + <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;info消息我们可以忽略.....:&quot;</span> + <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverType.equals(<span class="string">&quot;debug&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;[x] received,routeKey: &quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;,message:&quot;</span> + <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;debug消息我们只做调试.....:&quot;</span> + <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverType.equals(<span class="string">&quot;error&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;[x] received,routeKey: &quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;,message:&quot;</span> + <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;error消息很重要，存磁盘.....:&quot;</span> + <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;其它消息不管了。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考文档：</p>
<p><a href="http://www.rabbitmq.com/tutorials/tutorial-four-java.html">RabbitMQ Routing</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>message</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-消息中间件（五）Topics</title>
    <url>/2017/09/25/message-rabbitmq-5/</url>
    <content><![CDATA[<h2 id="RabbitMQ-消息中间件（五）Topics"><a href="#RabbitMQ-消息中间件（五）Topics" class="headerlink" title="RabbitMQ-消息中间件（五）Topics"></a>RabbitMQ-消息中间件（五）Topics</h2><h3 id="Topics-前言"><a href="#Topics-前言" class="headerlink" title="Topics 前言"></a>Topics 前言</h3><p>上一章我们写了个路由日志系统，用<code>direct</code>的放交换机，比较了<code>fanout</code>和它之间的区别，一个是广播，一个是绑定。<br>尽管我们使用<code>direct</code>交换机做了改进，但是它还是有一些限制，它没法根据不同的几个规则了区分。我们之前的日志是分了四种:info、debug、warn、error。但是我们可能实际中了，对error又分为系统错误或者业务错误。有时候我们针对业务开发，就不想去管理系统错误，那怎么办？<br>为了再一次提高我们的日志系统，我们需要学习另一种交换机：<code>topic</code>交换机。</p>
<h3 id="Topic-exchange"><a href="#Topic-exchange" class="headerlink" title="Topic exchange"></a>Topic exchange</h3><p>发送给<code>top</code>交换机的消息不能随意定义<code>routing_key</code>,它必须是一串单词，并且用点<code>.</code>分开。这些单词可以任意定义，通常他们是描叙这些消息的共同特点。<code>routing key</code>示范例如：<code>stock.usd.nyse</code>,<code>nyse.vmw</code>,<code>quick.orange.rabbit</code>。你可以定义你喜欢的任何单词，不过记得总共不能超过<code>255 bytes</code>。</p>
<span id="more"></span>

<p><code>routing_key</code>定义好了，那么<code>binding_key</code>也必须和它保持同样的格式。<code>topic</code>得原理其实和<code>direct</code>是类似的：一个拥有特殊routingKey的消息，经过交换机转发给一个匹配它的bindingKey的队列。然而对于<code>topic</code>来说，有两个关于bingdingKey的重要场景：</p>
<ol>
<li>* (星号) 用来表示一个精确的单词；</li>
<li><h1 id="用来表示0个或者多个单词；"><a href="#用来表示0个或者多个单词；" class="headerlink" title="用来表示0个或者多个单词；"></a>用来表示0个或者多个单词；</h1></li>
</ol>
<p>可以看下图加深印象：</p>
<p><img src="/images/qiniu/2017-09-25-16-47-25.png" alt="关联图"></p>
<p>在这个例子中，我们准备发送所有描叙动物的消息，这些消息的routingKey由三个单词组成(其中两个.)。第一个词在routeKey里面描叙速度，第二个表示颜色，第三个表示物种：<code>&lt;speed&gt;.&lt;colour&gt;.&lt;species&gt;</code>。</p>
<p>我们先创建三个<code>bingdingKey</code>,队列1用bindingKey：<code>*.orange.*</code>;队列2用bindingKey：<code>*.*.rabbit</code>和<code>lazy.#</code>。</p>
<p>这些队列可以被总结为：</p>
<ul>
<li>Q1 只对橙色动物感兴趣；</li>
<li>Q2 对所有兔子和所有懒的动物感兴趣；</li>
</ul>
<p>一个消息如果带有<code>quick.orange.rabbit</code>,会被转发给两个队列，如果是<code>lazy.orange.elephant</code>也会转发给两个队列，如果是<code>quick.orange.fox</code>会只转发给第一个队列Q1，如果是<code>lazy.brown.fox</code>会只转发给第二个队列Q2.<code>lazy.pink.rabbit</code>匹配了Q2的两个bingdingKey，但是它只会接收一次消息。<code>quick.brown.fox</code>不会匹配任何绑定，所以它会被丢弃。</p>
<p>如果我们打破下规则，用一个单词或者四个词的routKey，比如<code>orange</code>或者<code>quick.orange.male.rabbit</code>?消息会匹配不上任何的bingdingKey,然后会被丢失掉。</p>
<p>在另一方面，如果用的是<code>lazy.orange.male.rabbit</code>,就算它是四个单词，他也会匹配到bingdingKey为<code>lazy.#</code>,然后消息转发给Q2队列。</p>
<blockquote>
<p>Topic exchange是非常强大的交换机，并且可以像其他交换机一样工作。当一个队列只用<code>#</code>来作为bingdingKey，它会接受所有的消息，就相当于一个<code>fanout</code>交换机。当<code>*</code>和<code>#</code>没有在bingdingKey中使用，那么就相当于一个<code>direct</code>交换机。</p>
</blockquote>
<h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><p>生产者代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogTopic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;log_topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);<span class="comment">//可以自定义</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String routeKey = <span class="string">&quot;errorMessage.server&quot;</span>;<span class="comment">//system.error; errorMessage.server</span></span><br><span class="line">        String message = <span class="string">&quot;key is &quot;</span> + routeKey + <span class="string">&quot;,this is message&quot;</span>;</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, routeKey, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;message is send:&quot;</span> + message);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费者代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;log_topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        String[] messageType = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;#&quot;</span>, <span class="string">&quot;system.*&quot;</span>, <span class="string">&quot;*.server&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String serverType : messageType) &#123;</span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, serverType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                System.out.println(<span class="string">&quot;[X] received,routeKey:&quot;</span> + envelope.getRoutingKey() + <span class="string">&quot;,message:&quot;</span> + <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台输出结果：</p>
<p><img src="/images/qiniu/2017-09-25-17-30-02.png" alt="2017-09-25-17-30-02"></p>
<p>在管理后台查看channel，可以看到生成的三个队列图:</p>
<p><img src="/images/qiniu/2017-09-25-17-28-06.png" alt="生成的队列图"></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>message</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-消息中间件（六）RPC</title>
    <url>/2017/09/26/message-rabbitmq-6/</url>
    <content><![CDATA[<h2 id="RabbitMQ-消息中间件（六）RPC"><a href="#RabbitMQ-消息中间件（六）RPC" class="headerlink" title="RabbitMQ-消息中间件（六）RPC"></a>RabbitMQ-消息中间件（六）RPC</h2><h3 id="Remote-Procedure-Call-RPC"><a href="#Remote-Procedure-Call-RPC" class="headerlink" title="Remote Procedure Call (RPC)"></a>Remote Procedure Call (RPC)</h3><p>第二节讲过可以将耗时的任务通过工作队列给多个工作线程，如果我们想要调用一个在远程其它服务器上的一个功能并且等待它执行完后的结果，我们应该怎么做？是的，这是一个不同的场景，这种模式被叫做<code>Remote Procedure Call</code>或者说是<code>RPC</code>。</p>
<p>在本节中，我们准备使用RabbitMQ来构建一个RPC系统。一个客户端和一个可扩展的RPC服务端。如果我们没有耗时的任务，那么就值得转发，我们准备建造一个仿RPC服务，并且它返回一个斐波那契数。</p>
<h3 id="客户端接口"><a href="#客户端接口" class="headerlink" title="客户端接口"></a>客户端接口</h3><p>为了演示一个RPC服务是怎样被调用，我们准备创建一个简单的客户端。它暴露出一个叫<code>call</code>的方法接口，通过这个接口发送RPC请求，并且等待返回结果。</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FibonacciRpcClien fibonacciRpc = <span class="keyword">new</span> FibonacciRpcClient();</span><br><span class="line">String result = fibonacciRpc.call(<span class="string">&quot;4);</span></span><br><span class="line"><span class="string">System.out.println(&quot;</span>result:<span class="string">&quot;+result);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>RPC tips:<br>尽管RPC是一个在计算中非常通用的模式，它还是经常被喷。最明显的问题就是程序员不知道一个被调用的方法到底是本地方法或者是一个很慢的RPC服务。在一个复杂的系统中造成的结果非常让人迷惑，并且非增加调试时候不必要的复杂性。滥用RPC可能会导致代码异常复杂混乱。<br>如果一定要使用的话，参考下面的建议：<br>1 明确知道被调用的方法是本地的还是远程的<br>2 一定要为系统编写文档，确保确保组件之间的依赖非常清晰<br>3 处理异常情况，当RPC 服务长时间宕机了，客户端应该怎样操作？<br>如果可以的话，尽量避免使用RPC。你应该使用异步的方式来替换像RPC这种同步的。在下一个阶段异步推回结果</p>
</blockquote>
<h3 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h3><p>总的来说在RabbitMQ上做RPC是非常简单的。一个客户端发送一个请求的消息，然后服务端返回响应的消息。为了接收到响应，我们需要在发送请求消息的时候附带一个回调队列地址。我们可以使用默认的队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">callbackQueueName=channel.queueDeclared().getQueue();</span><br><span class="line"></span><br><span class="line">BasicProperties props = <span class="keyword">new</span> BasicProperties.Builder().replyTo(callbackQueueName);</span><br><span class="line"></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;rpc_queue&quot;</span>,props,message.getBytes());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Message properties . AMQP 0-9-1 协议预先定义了14个关于消息的属性。大多数属性使用的很少，一些特别的比如：<br>deliveryMode: 标记一个消息作为persistent(持久化默认值为2),或者transient(非2的值)。<br>contentType： 用来描叙mime-type 编码格式。例如经常使用的JSON编码：application/json。<br>replyTo: 通常用来命名一个回调队列。<br>correlationId: 用来关联RPC响应和请求。</p>
</blockquote>
<p>我们使用的时候需要导入：<code>import com.rabbitmq.client.AMQP.BasiProperties;</code>.</p>
<h3 id="Correlation-Id-（关联-ID）"><a href="#Correlation-Id-（关联-ID）" class="headerlink" title="Correlation Id （关联 ID）"></a>Correlation Id （关联 ID）</h3><p>在上面提出的方法中，我们建议未每一个RPC请求创建一个回调队列。它是非常低效的。但是幸运的是我们有一个更好的方式，我们可以为每一个客户端创建一个回调队列。</p>
<p>尽管我们用为客户端的形式替换了每一个rpc请求，但是它还是带来了新的问题，队列收到响应后无法知道这个响应应该属于哪个请求。现在我们就可以使用<code>correlationId</code>属性了。我们为每一个请求设置一个不同的correlationId。然后，当我们在回调队列里面收到请求的时候我们会关注这个属性，在这个属性值得基础上 我们可以匹配到哪个响应属于哪个请求。如果我们收到一个correlationId不存在值，我们可以安全的丢掉这个消息，因为这个响应不属于我们的请求。<br>你可能会问，为什么我们应该忽略在回调队列里面的不明correlationId的消息，而不是用一个error来报错？这是因为这种情况在服务端是存在的，比如RPC服务可能在发送给我们结果的时候就刚好挂掉了，但是还没有给请求发送一个确认的消息，尽管这种情况很少，但是还是存在；如果这种情况发生了，重启的RPC服务会再次处理这个请求，这就是为什么在客户端我们应该对重复响应进行友好的处理，理论上，RPC应该是幂等的。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/images/qiniu/2017-09-26-15-58-35.png" alt="2017-09-26-15-58-35"></p>
<p>我们的RPC工作的方式就像上图这样：</p>
<ul>
<li>当一个客户端启动，它创建了一个匿名的独立的回调队列。</li>
<li>对于一个RPC请求，客户端发送一个消息，消息有两个属性：<code>replyTo</code>,设置回调队列；<code>correlationId</code>,为每一个请求设置一个唯一值。</li>
<li>请求发送到<code>rpc_queue</code>队列。</li>
<li>RPC工作线程(服务端)等待队列中的请求的消息。当请求出现，它就开始工作，工作完后，使用<code>replyTo</code>中的属性来返回一个结果消息给客户端。</li>
<li>客户端等待回调队列中的消息数据，当一个消息出现，它会先检查<code>correlationId</code>属性，检查响应中的值匹配上了请求中的值。</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>斐波那契算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常简单并且没有太多边界判断，只支持正整数。我们只是用来演示而已，如果要其他的牛逼的算法，自己可以试着写。</p>
<p>RPC 服务端代码：RPCServer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RPC_QUEUE_NAME = <span class="string">&quot;rpc_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[x] awaiting rpc request&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                AMQP.BasicProperties replyProperties = <span class="keyword">new</span> AMQP.BasicProperties.Builder().correlationId(properties.getCorrelationId()).build();</span><br><span class="line">                String response = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> n = Integer.parseInt(message);</span><br><span class="line">                System.out.println(<span class="string">&quot;[x] fib(&quot;</span> + message + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                response += fib(n);</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, properties.getReplyTo(), replyProperties, response.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(RPC_QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        while (true)&#123;</span></span><br><span class="line">            <span class="keyword">synchronized</span> (consumer)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    consumer.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和前面的章节一样，我们建立了connection,channel,queue。我们可能想要运行一个或者多个线程，为了负载我们需要设置<code>channel.basicQos()</code>中的<code>prefetchCount</code>设置。<br>我们可以使用<code>basicConsumer</code>来访问我们设置的回调queue，我们提供了DefaultConsumer来做一些工作并且发送回来response。</p>
<p>RPC客户端代码：RpcClient.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> String requestQueueName = <span class="string">&quot;rpc_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String replyQueueName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        replyQueueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String corraltionId = UUID.randomUUID().toString();</span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder().correlationId(corraltionId).replyTo(replyQueueName).build();</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, requestQueueName, properties, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">final</span> BlockingQueue&lt;String&gt; response = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">1</span>);</span><br><span class="line">        channel.basicConsume(replyQueueName, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (properties.getCorrelationId().equals(corraltionId)) &#123;</span><br><span class="line">                    response.offer(<span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> response.take();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端代码理解也不难：</p>
<ul>
<li>先创建connection，channel，然后声明一个回调的队列来为了(replies)。</li>
<li>我们订阅了回调队列，所以我们可以接收到RPC的response。</li>
<li>我们的call方法是实际上的RPC请求。</li>
<li>我们先生成一个唯一的correlationId，然偶后保存它，它的作用是匹配正确的响应response。</li>
<li>接下来，我们发布了请求request的消息，消息带有replyTo和correlationId.</li>
</ul>
<p> 接下来我们我们就等待何时的响应返回。因为我们的消费者转发处理在一个分开的线程，在响应到达前，我们需要准备一些东西来挂起我们的主线程main。使用<code>BlockingQueue</code>就是一种解决办法，我们在此列中创建了一个<code>ArrayBlockingQueue</code>设置了capacity为1,因为我们仅仅需要它等待一个响应。</p>
<p> <code>handleDelivery</code>方法只做了一个非常简单的工作，对于每一个消费者的响应信息，它会检查是否correlationId是否是我们需要的，如果是的话，它会将它放进<code>BlockingQueue</code>.</p>
<p> 同时<code>main</code>线程是一直在等待从<code>BlockingQueue</code>中拿到响应。</p>
<p>最后我们返回响应结果给用户。</p>
<p>参考资料：</p>
<p><a href="http://www.rabbitmq.com/tutorials/tutorial-six-java.html">rabbitMQ RPC</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>message</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-消息中间件（一）</title>
    <url>/2017/09/15/message-rabbitmq/</url>
    <content><![CDATA[<h2 id="消息中间件-RabbitMQ-一"><a href="#消息中间件-RabbitMQ-一" class="headerlink" title="消息中间件 RabbitMQ (一)"></a>消息中间件 RabbitMQ (一)</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>RabbitMQ 是一个消息中间件，类似于传统的邮局，不过RabbitMQ充当了邮箱，邮局，邮递员的角色。和邮局不同的是，它使用消息接受，存储，发送二进制数据。</p>
<h3 id="RabbitMQ-的一些术语"><a href="#RabbitMQ-的一些术语" class="headerlink" title="RabbitMQ 的一些术语"></a>RabbitMQ 的一些术语</h3><p><code>Producing</code>: 生产者，发送消息方，只发送消息。</p>
<p><code>queue</code>: 消息队列，允许消息从RabbitMQ传送到应用程序，消息只能被存储在队列中。队列仅仅被宿主机的内存和磁盘空间限制，本质上它是一个大的缓存块。生产者可以往队列发消息，消费者也可以从队列中接受消息。</p>
<p><code>Consuming</code>:消费者，类似于收信人，消费者程序通常是在等待接收消息。</p>
<blockquote>
<p>ps:生产者，消费者和中间件不应该在同一台宿主机上面，实际中大多数应用都不会这样做。</p>
</blockquote>
<h3 id="“Hello-World”"><a href="#“Hello-World”" class="headerlink" title="“Hello World”"></a>“Hello World”</h3><span id="more"></span>
<p>Send.java,发布者发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>); <span class="comment">//连接本地的消息中间件，如果是其它机器换成ip就行了,也可以对连接进行授权，协议版本等控制</span></span><br><span class="line"><span class="comment">//        connectionFactory.setPassword();</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();<span class="comment">//socket连接, 大多数任务的完成都是调用connection的api</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1 发送消息之前，必须先声明一个发送消息的队列，然后我们往队列里面发送消息</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);<span class="comment">// 队列声明是幂等的，它只会在不存在的时候创建</span></span><br><span class="line">        String message = <span class="string">&quot;Hello,World&quot;</span>;</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());<span class="comment">// 消息内容是一个字节数组，可以用使用任何编码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 关闭</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[x] sent:&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Receiver.java,先要声明确定建立连接，因为需要等待接收消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/9/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1 前面的操作都是类似，都是需要链接的一些配置</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[X] receiving message&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;[x] Received : &quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>maven仓库包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.5.7&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>使用Demo的时候需要先下载安装RabbitMQ，可能还需要安装erlang，安装完成后打开网站<code>localhost:15672</code>,就可以看到rabbitMQ的管理后台了。</p>
<p>参考文档：</p>
<p><a href="http://www.rabbitmq.com/tutorials/tutorial-one-java.html">RabbitMQ Java</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>message</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Autocommit</title>
    <url>/2019/06/30/mysql-autocommit/</url>
    <content><![CDATA[<h1 id="MySQL-Autocommit"><a href="#MySQL-Autocommit" class="headerlink" title="MySQL Autocommit"></a>MySQL Autocommit</h1><p>最近遇到一个问题，在测试环境没有重现，但是在生产环境就频繁出现。问题的现象时，当我们在生产页面添加一个用户或者一条记录的时候，刷新页面始终是为空的数据，也就是数据没有入库，但是偶尔它又有数据。这个问题就很奇怪。后来追踪到代码的时候发现代码层没有做事务的控制，完全交给了数据库去管理，这个时候如果代码从db申请一个连接，然后完成操作之后，其实是否真实的commit是要看数据库的操作的。MySQL默认的配置中是将autocommit设置为1，也就是默认打开，但是我们公司的dba设置中，统一是0也就是关闭状态的，所以导致了这次事故的发生。作为一个程序员来说，我觉得，应该是要自己在业务逻辑层面来控制，不应该交由db去管理，这种行为有点可耻。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>autocommit</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 用户与权限设置</title>
    <url>/2018/12/17/mysql-grant/</url>
    <content><![CDATA[<h1 id="MySQL-用户与权限设置"><a href="#MySQL-用户与权限设置" class="headerlink" title="MySQL 用户与权限设置"></a>MySQL 用户与权限设置</h1><p>这几天开发完发现dba对于权限控制的比较严，通常是没有root权限的，在正式上线前，还是希望能再通过一个普通用户的权限来做一次预发布。这样可以看看到底会有哪些坑，提前踩一下可能比较好。后来发现，其实你只要准备需求提给dba就ok了，人家会帮你处理的非常好~~~。总之在这过程中遇到的问题，先记录一下吧。</p>
<span id="more"></span>
<h2 id="MySQL创建用户"><a href="#MySQL创建用户" class="headerlink" title="MySQL创建用户"></a>MySQL创建用户</h2><p>第一个就是创建一个普通用户。使用root登陆后，创建一个用户：<code>CREATE USER &#39;username&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;paasword&#39;;</code>其中<code>username</code>,<code>paasword</code>按需修改。一般来说这里需要注意的就是<code>localhost</code>，为什么？因为这个字段稍不注意就会才坑，这里的<code>localhost</code>和<code>%</code>，其实指代的是只允许本地登录和允许所有地方登陆。如果你的应用部署在同一台机器上，那么你用localhost没问题，但是如果应用和数据库是分开机器部署的，那么这里要写成<code>%</code>，不然就会出现远程无法连接。当然还有很多其他的设置，比如什么过期时间啊，证书登录啊，具体的可以看下官方文档:<a href="https://dev.mysql.com/doc/refman/8.0/en/create-user.html">Create User</a>。</p>
<h2 id="给MySQL用户赋权限"><a href="#给MySQL用户赋权限" class="headerlink" title="给MySQL用户赋权限"></a>给MySQL用户赋权限</h2><p>如果做开发的话，你就会发现，你的jdbc或者其他语言连接数据库，都需要选择选择一个库。也就是你必须先在数据库里面建立一个database，但是如果你用root建立一个database，比如：<code>create database DB_USER;</code>这个时候上一步创建的用户是无法访问这个库的。如果你切换到刚刚的用户，那么你也是没有权限建立数据库的。但我们通常开发都会写上库名，那这个时候怎么操作了？嗯，就是先用root建库，然后将权限库的权限赋值给新用户。具体操作如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db_user;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_user.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这里一定要注意<code>%</code>,<code>localhost</code>，如果这里不同，那就是两个用户。</p>
<p>当然，如果你觉得只给查的权限就足够了，那么只需要<code>GRANT SELECT ON db_user.* TO &#39;test&#39;@&#39;%&#39;;</code>。那么有没有更详细的了了？当然有，文档始终是最详细的，我只是记录我使用的过程。文档地址：<a href="https://dev.mysql.com/doc/refman/8.0/en/grant.html#grant-overview">grant</a></p>
<p>一些比较使用的使用方式：</p>
<ol>
<li><p>查看当前用户：<code>select CURRENT_USER();</code></p>
</li>
<li><p>查看当前用户权限：<code>show grants;</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库查询优化</title>
    <url>/2018/03/12/mysql-optimization/</url>
    <content><![CDATA[<h1 id="数据库查询优化"><a href="#数据库查询优化" class="headerlink" title="数据库查询优化"></a>数据库查询优化</h1><p>通常笛卡尔积的优化很明显，可以用字查询等来做。</p>
<p>查询的优化其实实际上很大部分都是来自索引的优化。我是这么认为的。我们很多时候都会查执行计划的方式来优化语句。而这里面我们看得最多的就是表是否使用了索引。其实如果数量量少的情况下，我们用全表扫描可能会比用索引扫描要好。但是一般情况下还是优化成索引查询比较好。使用的方法就是查执行计划。<code>explain</code>，<code>explain extended</code>。</p>
<p>另外还有一个特别有意思的语句优化： <code>where name like &#39;Abc%&#39;</code>优化成：<code>where name&gt;=&#39;Abc&#39; and name &lt; &#39;Abcd&#39;</code></p>
<p>本文来自《数据库查询优化器的艺术》-李海翔的读书摘抄。</p>
<p>今天先给自己挖个坑。等之后我再来填。7天之内必填完，今日是3月12日。3月19日填完此坑。</p>
<p>来填坑，今天是3月16日。</p>
<h2 id="性能优化简介"><a href="#性能优化简介" class="headerlink" title="性能优化简介"></a>性能优化简介</h2><p>谈优化，我们先的知道怎么去测量。我们优化的性能其实实际上指的就是响应时间。主要测量也是看时间花在哪里。响应时间一般指的是执行时间和等待时间。在进行优化之前我们必须先明白什么样的优化才值得我们去优化：</p>
<ol>
<li>值得优化的查询，如果为了优化1%的查询去浪费20%的人力，那肯定是不合算的；</li>
<li>异常情况要优化，有异常当然要优化了；</li>
<li>丢失时间，执行一些语句，发现花费了莫名奇妙的很长一段时间，而且这段时间也没有任何日志记录；这也有点像异常情况，对待异常一定要明白为什么；</li>
<li>不要相信平均值，毕竟有时候峰值几十秒，然后其它时候几毫秒，这种均值肯定是不能信的</li>
</ol>
<p>既然要测量，那当然要有可以测量的点了。比如说从慢查询日志，show status，show profile。下面先介绍下几个常用的测量点：</p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志可以通过设置：<code>long_query_time=0</code>来开启。慢查询日志是开销最低，精度最高的测量查询时间的工具。慢查询最大的担心就是消耗大量的磁盘空间，所以建议在只开启某一段时间进行收集即可。推荐一款工具：<code>pt-query-digest</code>。</p>
<h3 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h3><p>开始profile的命令为：<code>set profiling=1</code>,开启之后，在服务器上执行的所有语句，都会测量其耗费的时间和其它一些查询执行状态变更相关的数据。当一条查询提交给服务器时候，此工具会记录信息到临时表，然后我们可以使用<code>show profiles;</code>来查询结果。当然你可以使用我下面的这个sql来查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@query</span>_id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> state,<span class="built_in">sum</span>(duration) <span class="keyword">as</span> Total_R,</span><br><span class="line">	ROUND(</span><br><span class="line">			<span class="number">100</span><span class="operator">*</span><span class="built_in">SUM</span>(DURATION) <span class="operator">/</span>(<span class="keyword">Select</span> <span class="built_in">sum</span>(duration) <span class="keyword">from</span> information_schema.profiling <span class="keyword">where</span> query_id<span class="operator">=</span><span class="variable">@query</span>_id),<span class="number">2</span>) <span class="keyword">as</span> Pct_R,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> Calls,</span><br><span class="line">	<span class="built_in">SUM</span>(duration) <span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> <span class="string">&#x27;R/CALL&#x27;</span></span><br><span class="line"><span class="keyword">From</span> information_schema.profiling</span><br><span class="line"><span class="keyword">Where</span> query_id<span class="operator">=</span><span class="variable">@query</span>_id</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">by</span> state</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Total_R <span class="keyword">desc</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="show-status"><a href="#show-status" class="headerlink" title="show status"></a>show status</h3><p>该命令返回一些计数器。既有服务器级别的全局计数器，也有基于某个连接的会话级别的计数器。</p>
<p>另外还有一些命令：show processlist;show global status;这些命令可能需要在实际使用中再查了。不是我想说的重点。</p>
<h2 id="优化过程"><a href="#优化过程" class="headerlink" title="优化过程"></a>优化过程</h2><p>谈到优化，其实优化的点有很多，从数据库表开始设计，字段类型，字段索引设置都有很多的可优化之处，我们非专业DBA，但是可以多去尝试理解，至少靠自己，是最靠谱的。</p>
<h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><h4 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h4><p>比如使用可以正确存储数据的最小数据类型。他们更快，因为更小的数据类型占用更少的磁盘，内存和CPU缓存，并且处理时需要的CPU周期也更少。</p>
<h4 id="使用更简单的数据类型"><a href="#使用更简单的数据类型" class="headerlink" title="使用更简单的数据类型"></a>使用更简单的数据类型</h4><p>整型比字符操作代价更低，使用内建类型代替字符串存储日期和时间，使用整型存储IP；</p>
<h4 id="避免使用NULL"><a href="#避免使用NULL" class="headerlink" title="避免使用NULL"></a>避免使用NULL</h4><p>为null的列会使用更多的存储空间；null的列为索引，需要一个额外的存储空间；</p>
<p>另外还有些优化是选择具体数据类型，设计表时候，列不要太多，太多的列需要考虑分表；少关联多个表，多表查询，MySQL最多关联表61个。</p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>很多时候谈优化，最终都无法避免的就是说到索引优化。索引是存储引擎用来快速找到记录的一种数据结构。在MySQL中也成为key。MySQL中索引是存储在存储引擎中的，不是在服务器中。一般我们说的索引都是B-Tree索引，也就是B-Tree数据结构。B-Tree对索引的列是顺序组织存储的（这里可以看到数据结构的威力了！），索引对值进行排序是按照create table时列的顺序来的。B-Tree 索引适用于全键值，键值范围，键前缀值。</p>
<p>索引的种类有很多，除了上面说的B-tree索引，还有哈希索引，空间数据索引，全文索引。</p>
<p>索引的优点：快速定位到表的位置，减少服务器需要扫描的数量，帮助服务器避免排序和临时表，将随机I/O变成顺序I/O。不过别太迷信索引，在表数量少的情况下，全表扫描更高效。</p>
<p>索引查询：</p>
<ol>
<li>全值匹配；</li>
<li>匹配最左前缀，多列索引匹配最左边的索引；</li>
<li>匹配列前缀，匹配某一列的值的开头部分；</li>
<li>匹配范围值；</li>
<li>精确匹配某一列并范围匹配其它列；</li>
<li>只访问索引的查询</li>
</ol>
<p>限制：</p>
<ol>
<li>如果不按照索引最左列开始查找，则无法使用索引；</li>
<li>不能跳过索引列：比如有三个索引列name,address,age;不能跳过address来查询age的索引。</li>
<li>如果某列为范围查询，其右侧列都无法使用索引查询;如有索引a,b,c;如果在查询中使用了 <code>a between 1 and 15 and b =12</code>,由于a使用了范围查询，a之后的索引b不会生效。</li>
</ol>
<h4 id="索引优化实例"><a href="#索引优化实例" class="headerlink" title="索引优化实例"></a>索引优化实例</h4><p>链接地址：<a href="http://chenzhijun.top/2018/03/23/mysql-optimization-index/">http://www.chenzhijun.top/2018/03/23/mysql-optimization-index/</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 优化</title>
    <url>/2017/04/22/mysql-optimize/</url>
    <content><![CDATA[<h2 id="MySQL-优化基础"><a href="#MySQL-优化基础" class="headerlink" title="MySQL 优化基础"></a>MySQL 优化基础</h2><p>mysql 版本5.7</p>
<p>查询数据库版本: select @@version;</p>
<p>查询数据库的变量: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables;  -- 当前会话</span><br><span class="line"></span><br><span class="line">show session variables; -- 当前会话</span><br><span class="line"></span><br><span class="line">show global variables; -- 全局</span><br></pre></td></tr></table></figure>

<p>当我设置<code>long_query_time</code>的时候用到了<code>set global long_query_time = 5</code>;但是查询的时候用到了<code>show global variables like &#39;%long_query_time%&#39;</code>这种情况下查到的值始终为10,中间的原因就是局部和全局的问题:</p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW SESSION VARIABLES LIKE &quot;long_query_time&quot;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line"></span><br><span class="line">mysql&gt; SET @@GLOBAL.long_query_time &#x3D; 1;</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE &quot;long_query_time&quot;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | 1.000000 |</span><br><span class="line">+-----------------+----------+</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &quot;long_query_time&quot;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/15541603/why-i-could-not-alter-the-variable-long-query-time-variable-at-runtime"></a></p>
<p><code>long_query_time</code>记录的是时间的秒。如果设置为0秒，那么所有的sql都会被记录。</p>
<p><code>show variables like &#39;log_queries_not_using_indexes&#39;;</code> 可以查看是否索引查询启用日志。所有没有索引的查询都会记录下来。</p>
<p><code>show variables like &#39;slow_query_log_file&#39;;</code> 是否打开慢查询日志<br><code>set global slow_query_log = on;</code> 打开慢查询日志</p>
<p><code>show global variables like &#39;slow_query_log_file&#39;;</code> 查询慢查询日志文件路径<br><code>set slow_query_log_file=&#39;/usr/local/var/mysql/logs/query_slow.log&#39;;</code> 设置慢查询日志文件路径</p>
<p>query_slow.log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Time: 2017-04-22T07:02:51.980026Z</span><br><span class="line"># User@Host: root[root] @ localhost [127.0.0.1]  Id:     3</span><br><span class="line"># Query_time: 0.000179  Lock_time: 0.000074 Rows_sent: 2  Rows_examined: 2</span><br><span class="line">SET timestamp&#x3D;1492844571;</span><br><span class="line">select * from store limit 10;</span><br></pre></td></tr></table></figure>
<p>第一行是执行sql的时间；第二行是用户和执行的主机；第三行是sql总共执行时间，锁表，查出的row；第三行是执行时间的时间戳；第四行是执行的SQL语句。</p>
<p><code>mysqldumpslow -t 3 logfile</code>:分析日志文件的前3条日志</p>
<p><code>explain sql语句</code>:执行计划分析sql语句</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 存储过程</title>
    <url>/2017/11/21/mysql-stored-procedure/</url>
    <content><![CDATA[<h2 id="MySQL-存储过程"><a href="#MySQL-存储过程" class="headerlink" title="MySQL 存储过程"></a>MySQL 存储过程</h2><p>MySQL存储过程是一个存储在MySQL数据库中的一段SQL代码，类似于我们平常在程序语言中的一个自定义函数。其实说到底，SQL也是一种语言，它也可以定义函数，定时器等等。只不过它是直接操作的数据库中的数据。</p>
<p>平常能用到存储过程的机会不多，以前在支付公司的时候更别说直接操作存储过程了，这根本不可能。任何需要做的处理逻辑都需要在代码中处理，所以这次接到写存储过程的任务，我还是有点忐忑的，一个是自己根本不会。O(∩_∩)O哈！完成的时间还比较紧。不过有挑战就有机遇，这个是没有错的。</p>
<span id="more"></span>
<p>整个一周下来，也算是对存储过程的时候有了一点小小的心得，所以做次记录，如果下次遇到，能提醒自己。</p>
<!--more-->
<h3 id="定义存储过程"><a href="#定义存储过程" class="headerlink" title="定义存储过程"></a>定义存储过程</h3><p>定义一个存储过程是比较简单的，类似与我们写一个Java方法，定义的语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc4(<span class="keyword">IN</span> param1 <span class="type">INT</span>,<span class="keyword">OUT</span> param2 <span class="type">varchar</span>(<span class="number">50</span>),<span class="keyword">INOUT</span> param3 <span class="type">varchar</span>(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">max</span>(order_type) <span class="keyword">INTO</span> param1 <span class="keyword">FROM</span> cncsen.order_info;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@param1</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_info orderInfo <span class="keyword">where</span> orderInfo.ORDER_TYPE<span class="operator">=</span>param1; </span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>现在我们逐句来解析下：</p>
<p><code>DELIMITER</code> : 这个是声明一个结束符，可以这样认为，解析器找到之前默认是找到<code>;</code>就认为这句话结束，而我们用<code>DELIMITER</code>将原来的<code>;</code>改为<code>//</code>,这样解析器只有遇到<code>//</code>才会认为当前句子结束；</p>
<p><code>CREATE</code> : 这个和创建表，创建数据库是一个意思；</p>
<p><code>PROCEDURE</code> : 这个是指创建存储过程，类似于<code>TABLE</code>,<code>DATABASE</code>；</p>
<p><code>proc4</code> ：这个的意思是存储过程名字；</p>
<p><code>OUT / IN / INOUT</code> : 相当于权限定义，OUT 是指该参数可以当做出参，不能作为入参；IN 是指该参数为可以作为入参，不能作为出参；INOUT 是指该参数既可以作为出参，也可以作为入参；（入参指作为参数传进来；出参是指作为返回值，传给其他人用)；</p>
<p><code>INT / VARCHAR </code> : 这个是基本类型，相当于Java里面的预置基本类型。</p>
<p><code>BEGIN ** END</code> : begin和end定义的是一个语句块，从哪里开始，到哪里结束。可以看到后面还有<code>//</code>，而它刚好就是我们之前定义的结束符号，到这里我们的定义也就完成了。最后当然还要将结束符号切换回<code>;</code>。</p>
<p>这里我们就定义好了一个存储过程，其实我们主要关注的是begin和end之间的事情，我们可以在这里写各种SQL语句。当然我们也可以在这里建立临时表，然后将表中的数据插入到其它表中。</p>
<h3 id="存储过程实例"><a href="#存储过程实例" class="headerlink" title="存储过程实例"></a>存储过程实例</h3><p>首先创建两个表，一个是user信息表，一个是user日志表。下面是两个表的建表语句：</p>
<p><code>TBL_USER</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tbl_user` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stu_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>

<p><code>TBL_USER_LOG</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tbl_user_log` (</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">52</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stu_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `now_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `param_address` <span class="type">varchar</span>(<span class="number">25</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> big5 <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;	&#x27;</span>,</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `id_UNIQUE` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面我们开始写一个存储过程，该存储过程很简单就是将<code>tbl_user</code>表的数据备份一份到<code>tbl_user_log</code>中比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc(<span class="keyword">IN</span> start_date <span class="type">varchar</span>(<span class="number">32</span>),<span class="keyword">IN</span> end_date <span class="type">varchar</span>(<span class="number">32</span>),</span><br><span class="line">						<span class="keyword">IN</span> name <span class="type">varchar</span>(<span class="number">50</span>),<span class="keyword">INOUT</span> address <span class="type">varchar</span>(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_user_log(user_id,user_name,age,address,stu_id,create_time,last_update_time,now_time)</span><br><span class="line">		<span class="keyword">SELECT</span> id,name,age,address,stu_id,create_time,last_update_time,<span class="built_in">current_time</span> </span><br><span class="line">        <span class="keyword">FROM</span> tbl_user</span><br><span class="line">        <span class="keyword">WHERE</span> create_time<span class="operator">&gt;=</span><span class="variable">@start</span>_date</span><br><span class="line">        <span class="keyword">AND</span> create_time<span class="operator">&lt;</span><span class="variable">@end</span>_date</span><br><span class="line">        <span class="keyword">AND</span> name<span class="operator">=</span><span class="variable">@name</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你要执行这个存储过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@start</span>_date<span class="operator">=</span><span class="string">&#x27;2017-11-16 12:12:12&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@end</span>_date<span class="operator">=</span><span class="string">&#x27;2017-11-17 12:12:12&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@name</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@address</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">CALL</span> proc(<span class="variable">@start</span>_date,<span class="variable">@end</span>_date,<span class="variable">@name</span>,<span class="variable">@address</span>);</span><br></pre></td></tr></table></figure>

<p>然后在<code>tbl_user_log</code>表中你就可以看到符合你的需求的数据了。</p>
<h3 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event 事件"></a>Event 事件</h3><p>我们经常需要做一些定时任务，在数据库中我们如果需要做一些定时任务，这个时候就需要用到Event了。</p>
<p>创建Event的语法为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">    [DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">    EVENT</span><br><span class="line">    [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]</span><br><span class="line">    event_name</span><br><span class="line">    <span class="keyword">ON</span> SCHEDULE schedule</span><br><span class="line">    [<span class="keyword">ON</span> COMPLETION [<span class="keyword">NOT</span>] PRESERVE]</span><br><span class="line">    [ENABLE <span class="operator">|</span> DISABLE <span class="operator">|</span> DISABLE <span class="keyword">ON</span> SLAVE]</span><br><span class="line">    [COMMENT <span class="string">&#x27;string&#x27;</span>]</span><br><span class="line">    DO event_body;</span><br><span class="line"></span><br><span class="line">schedule:</span><br><span class="line">    <span class="keyword">AT</span> <span class="type">timestamp</span> [<span class="operator">+</span> <span class="type">INTERVAL</span> <span class="type">interval</span>] ...</span><br><span class="line">  <span class="operator">|</span> <span class="keyword">EVERY</span> <span class="type">interval</span></span><br><span class="line">    [STARTS <span class="type">timestamp</span> [<span class="operator">+</span> <span class="type">INTERVAL</span> <span class="type">interval</span>] ...]</span><br><span class="line">    [ENDS <span class="type">timestamp</span> [<span class="operator">+</span> <span class="type">INTERVAL</span> <span class="type">interval</span>] ...]</span><br><span class="line"></span><br><span class="line"><span class="type">interval</span>:</span><br><span class="line">    quantity &#123;YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |</span><br><span class="line">              WEEK <span class="operator">|</span> <span class="keyword">SECOND</span> <span class="operator">|</span> YEAR_MONTH <span class="operator">|</span> DAY_HOUR <span class="operator">|</span> DAY_MINUTE <span class="operator">|</span></span><br><span class="line">              DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND&#125;</span><br></pre></td></tr></table></figure>

<p>具体的字段详情就不一一解释了，如果需要详细了解可以<a href="https://dev.mysql.com/doc/refman/5.7/en/create-event.html">查看Event官网信息</a>。</p>
<p>事件的执行需要打开数据库的配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> event_scheduler <span class="operator">=</span> <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.event_scheduler <span class="operator">=</span> <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> event_scheduler <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.event_scheduler <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>具体详情可以<a href="https://dev.mysql.com/doc/refman/5.7/en/events-configuration.html">查看Event官方文档</a></p>
<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>通常我们需要将查出的数据做一些处理，比如先对一个表进行select，然后再通过某个字段汇总，或者进行一些汇总后的总处理，这个时候如果我们需要遍历记录做处理，那么就需要用到游标了。说白了，游标就是用来遍历select之后的数据的。<br>游标的使用非常简单，我们看一个实例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> curdemo()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> a <span class="type">CHAR</span>(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">DECLARE</span> b, c <span class="type">INT</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> cur1 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> id,data <span class="keyword">FROM</span> test.t1;</span><br><span class="line">  <span class="keyword">DECLARE</span> cur2 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> i <span class="keyword">FROM</span> test.t2;</span><br><span class="line">  <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">OPEN</span> cur1;</span><br><span class="line">  <span class="keyword">OPEN</span> cur2;</span><br><span class="line"></span><br><span class="line">  read_loop: LOOP</span><br><span class="line">    <span class="keyword">FETCH</span> cur1 <span class="keyword">INTO</span> a, b;</span><br><span class="line">    <span class="keyword">FETCH</span> cur2 <span class="keyword">INTO</span> c;</span><br><span class="line">    IF done <span class="keyword">THEN</span></span><br><span class="line">      LEAVE read_loop;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    IF b <span class="operator">&lt;</span> c <span class="keyword">THEN</span></span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.t3 <span class="keyword">VALUES</span> (a,b);</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.t3 <span class="keyword">VALUES</span> (a,c);</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">  <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">CLOSE</span> cur1;</span><br><span class="line">  <span class="keyword">CLOSE</span> cur2;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>主要注意的无非就是<code>DECLARE cur1</code>,先声明;然后open，定义一个LOOP循环，read_loop 这里是循环名称。当然这里也定义了一个退出状态条件-done，最后CLOSE。<br>确实很简单。</p>
<p>定义个test表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>

<p>之后用游标先查出<code>tbl_user</code>的数据，然后插入到test表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">|</span></span><br><span class="line"><span class="keyword">CREATE</span> EVENT event_sale_data</span><br><span class="line">    <span class="keyword">ON</span> SCHEDULE</span><br><span class="line">      <span class="keyword">EVERY</span> <span class="number">1</span> <span class="keyword">HOUR</span></span><br><span class="line">    DO</span><br><span class="line">      <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span>;</span><br><span class="line">      <span class="keyword">DECLARE</span> CITY_NAME <span class="type">VARCHAR</span>(<span class="number">50</span>);</span><br><span class="line">      <span class="keyword">DECLARE</span> cursor_user <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> NAME <span class="keyword">FROM</span> tbl_user;</span><br><span class="line">      <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="literal">TRUE</span>;</span><br><span class="line">      <span class="keyword">OPEN</span> cursor_user;</span><br><span class="line">      read_loop: LOOP</span><br><span class="line">		<span class="keyword">FETCH</span> cursor_user <span class="keyword">INTO</span> user_name;</span><br><span class="line">			IF done <span class="keyword">THEN</span></span><br><span class="line">				LEAVE read_loop;</span><br><span class="line">			<span class="keyword">END</span> IF;</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> demo.test <span class="keyword">VALUE</span>(user_name);</span><br><span class="line">	  <span class="keyword">END</span> LOOP;</span><br><span class="line">    <span class="keyword">END</span> <span class="operator">|</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>存储过程，游标，事件的基本使用就是这些了，非常简单，一开始做的时候很痛苦，也不知道该怎么下手。冷静下来，每一次不会，都是一个机会。</p>
<p>另外，我在event里面如果将select的数据作为变量传递到存储过程当中的时候，存储过程总是获取值失败，也就是参数没法传递到存储过程中，这个问题很奇怪，还在解决中。</p>
<p>还有一个特别有意思的，如果定义了查询-插入的存储过程，也就是将一个表的数据查询后插入到另一个表中，如果你在mysqlworkbench中直接调用call proc()，那么总是会将上一次查询的数据重复的插入的新表中，也就是重复插入，但是第一次的时候没有，只有手动调用两次以上的时候才会出现重复数据。如果是事件触发，却又没有重复数据插入。这个问题，我怀疑是缓存的问题。嗯，踩过的坑就这两个了。作为备忘，时刻提醒自己。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库常用函数汇总</title>
    <url>/2017/04/21/mysql_draft/</url>
    <content><![CDATA[<h2 id="MySQL-常用函数和语句"><a href="#MySQL-常用函数和语句" class="headerlink" title="MySQL 常用函数和语句"></a>MySQL 常用函数和语句</h2><h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><p>修改表的某个字段定义:<code>alter table tableName modify clounmnName column_definition [first|After col_name]</code></p>
<p>增加表字段:<code>alter table tablename add column column_definition [first|after col_name]</code></p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table emp add column age int(3);</span><br><span class="line"></span><br><span class="line">alter table emp add birth date after ename;</span><br></pre></td></tr></table></figure>
<p>删除表字段:<code>alter table tablename drop column col_name</code></p>
<span id="more"></span>
<p>修改字段名:<code>alter table tablename change [column] old_col_name column_definition [First|after col_name]</code></p>
<p>eg:</p>
<p><code>alter table emp change age age1 int(4)</code></p>
<p>修改表名称<code>alter table tablename rename [to new tablename]</code></p>
<p>按照sal排序后查询从第二条记录开始的3条记录<code>limit</code>:<code>select * from emp order by sal limit 1,3.</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select concat(&#39;drop table test1&#39;,table_name,&#39;;&#39;) and table_name like &#39;tmp%&#39;</span><br></pre></td></tr></table></figure>
<p><code>bit</code>类型的数据列用<code>bin(),hex()</code>来显示</p>
<p>mysql 只给表中的第一个<code>timestamp</code>类型设置默认值为系统日期，如果有第二个timestamp类型，则默认为0值。规定<code>timestamp</code>类型字段只能有一列的默认值为<code>current_timestamp</code>;<em>timestamp</em> 和<strong>时区</strong>有关，插入的时候先转换成本地时区后存放，从数据库取出来时也同样需要将日期转换成本地时区后显示。</p>
<p>查看时区: <code>show variables like &#39;time_zone&#39;</code></p>
<p>表中的第一个timestamp自动设置为系统时间。如果插入时为null，该列自动设置为当前的日期和时间</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h4><p><code>LPAD(str,n,pad); RPAD(str,n,pad)</code>:用字符串pad对str最左边和最右边进行填充，知道长度为n个长度为止。</p>
<p><code>LTRIM(str); RTRIM(str)</code>:去掉字符串str左侧和右侧空格</p>
<p><code>REPEAT(str,n)</code>:返回str重复n次</p>
<p><code>REPLACE（str,a,b)</code>: 用字符串b替换字符串str中所有出现的字符串</p>
<p><code>STRCMP(s1,s2)</code>:比较s1，s2的ASCII码值得大小</p>
<p><code>TRIM(str)</code>: 去掉str左右两端的空格</p>
<p><code>SUBSTRING(str,x,y)</code>:返回从字符串str中的第x位置起y个字符长度的子串</p>
<p><code>COUNT(*),COUNT(id)</code>: 如果为*，就是返回总行数；如果只是某个列，特别注意如果该列有值为null，那么count不计数</p>
<h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><p><code>ABS(x)</code>函数:返回x的绝对值</p>
<p><code>CEIL(x)</code>函数:返回大于x的最小整数</p>
<p><code>FLOOR(x)</code>函数:返回小于x的最大整数，和CEIL的用法刚好相反</p>
<p><code>MOD(x,y)</code>:返回x/y的模</p>
<p><code>RAND()</code>函数:返回0~1内的随机值</p>
<p><code>ROUND(x,y)</code>函数:返回参数x的四舍五入的有y位小数的值</p>
<p><code>TRUNCATE(x,y)</code>函数:返回数字x截断为y位小数的结果</p>
<h4 id="日期与时间函数"><a href="#日期与时间函数" class="headerlink" title="日期与时间函数"></a>日期与时间函数</h4><p><code>curdate()</code>:返回当前日期，只包含年月日</p>
<p><code>curtime()</code>:返回当前时间，只包含时分秒</p>
<p><code>now()</code>:返回当前的日期和时间，年月日时分秒全都包含</p>
<p><code>UNIX_timestamp(date)</code>:返回日期date的UNIX时间戳，Unix_timestamp(now())</p>
<p><code>FROM_unixtime(unixtime)</code>:返回unixtime时间戳的日期值，和unix_timestamp(date)互为逆操作</p>
<p><code>week(date),year(date)</code>:前者返回所给的日期是一年的第几周，后者返回所给的日期是哪一年</p>
<p><code>hour(time)和minute(time)</code>:前者返回所给时间的小时，后者返回所给时间的分钟<br>比如当前时间为23:34,selec hour(curtime()),minute(curtime())==&gt;23  34</p>
<p><code>monthname(date)</code>:返回date的英文名称,四月份的话,select monthname(curdate()) ==&gt; April</p>
<p><code>Date_format(date,fmt)</code> : 将date格式化成fmt格式，select date_format(now(),’%M,%D,%Y’)</p>
<p><code>date_add(date,INTERVAL expr type)</code>: 返回与所给日期date相差INTERVAL时间段的日期</p>
<p><code>datediff(date1,date2)</code>:用来计算两个日期之间相差的天数</p>
<h4 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h4><p><code>IF(value,t,f)</code>: select if(salary&gt;2000,’high’,’low’) from salary; 如果value成立，则显示为t，否则为f</p>
<p><code>ifnull（value1，value2)</code> 如果value1为null则显示为value2</p>
<p><code>case when [value] then [result].. else[default] END</code> : 与if-else差不多 select case when id&lt;5 then ‘err1’  else ‘err&gt;5’ end  from city_tbl</p>
<h4 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h4><p><code>database()</code>:返回当前数据库名</p>
<p><code>version()</code>:返回版本</p>
<p><code>user()</code>:返回当前登录用户</p>
<p><code>inet_aton(IP)</code>:返回IP地址的网络字节序表示：select init_aton(‘192.168.1.1’)==》3232235777</p>
<p><code>inet_ntoa(num)</code>:返回网络字节序的IP地址标识：select inet_ntoa(3232235777)==&gt;192.168.1.1</p>
<p><code>password(str)</code>:返回字符串str的加密版本，一个41位长的字符串</p>
<p><code>MD5(str)</code>:返回字符串的str的MD5值，常用来对应用中的数据进行加密</p>
<p><code>show engines</code>:返回存储引擎列表</p>
<p><code>show variables like &#39;have%&#39;</code>:返回have为前缀的所有系统变量</p>
<p><code>alter table *** auto_increment=n;</code>  设置强制自动增长列的初始值，该强制默认值存储在内存中，如果该值在使用之前数据库重启，那么需要在数据库启动后重新设置</p>
<p>对于innoDB表，自动增长列必须是索引</p>
<p>对于text,blob字段的表，如果进场做删除和修改记录，要定时执行optimize table对表进行碎片整理</p>
<p><strong><code>help ‘show engines’</code></strong>:如果忘记了某个方法，某个关键字，都可以用help来帮助</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>简</title>
    <url>/2017/03/13/new-step/</url>
    <content><![CDATA[<pre><code> Hello, A new starting point, 2017.
</code></pre>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx-and-haproxy-config</title>
    <url>/2021/10/06/nginx-and-haproxy-config/</url>
    <content><![CDATA[<h1 id="Nginx-和-Haproxy-配置文件"><a href="#Nginx-和-Haproxy-配置文件" class="headerlink" title="Nginx 和 Haproxy 配置文件"></a>Nginx 和 Haproxy 配置文件</h1><p>目标：通过 Nginx 和 Haproxy 的常用配置实现服务的反向代理。</p>
<span id="more"></span>
<h2 id="NGINX-配置"><a href="#NGINX-配置" class="headerlink" title="NGINX 配置"></a>NGINX 配置</h2><p>nginx 常用的配置文件一般处于 <code>/etc/nginx/conf/nginx.conf</code>。只有改这个文件之后执行 <code>nginx -s reload</code> 才可以动态加载，如果是 include 下面的，不会生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#daemon off;</span><br><span class="line">user root root;</span><br><span class="line">worker_processes auto;</span><br><span class="line">worker_cpu_affinity auto;</span><br><span class="line">error_log &#x2F;var&#x2F;log&#x2F;ingress-gateway&#x2F;error.log;</span><br><span class="line">events &#123;</span><br><span class="line">  use epoll;</span><br><span class="line">  worker_connections 20000;</span><br><span class="line">  multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#TCP 方式</span><br><span class="line">stream &#123;</span><br><span class="line">  upstream env1-lb-tcp &#123;</span><br><span class="line">    server 10.244.13.227:19080 weight&#x3D;1 max_fails&#x3D;1 fail_timeout&#x3D;10s</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 19080;</span><br><span class="line">    proxy_pass env1-lb-tcp;</span><br><span class="line">    proxy_connect_timeout 2s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># HTTP 方式</span><br><span class="line">http &#123;</span><br><span class="line">  server_tokens off;</span><br><span class="line">  sendfile on;</span><br><span class="line">  tcp_nodelay on;</span><br><span class="line">  tcp_nopush on;</span><br><span class="line">  port_in_redirect off;</span><br><span class="line">  keepalive_timeout 0;</span><br><span class="line">  underscores_in_headers on;</span><br><span class="line">  charset utf-8;</span><br><span class="line"></span><br><span class="line">  include mime.types;</span><br><span class="line">  lua_use_default_type off;</span><br><span class="line"></span><br><span class="line">  log_format main &#39;[$time_local]&#96;$http_x_up_calling_line_id&#96;&quot;$request&quot;&#96;&quot;$http_user_agent&quot;&#96;$staTus&#96;[$remote_addr]&#96;$http_x_log_uid&#96;&quot;$http_referer&quot;&#96;$request_time&#96;$body_bytes_sent&#96;$http_x_forwarded_proto&#96;$http_x_forwarded_for&#96;$host&#96;$http_cookie&#96;$upstream_response_time&#96;xd&#39;;</span><br><span class="line">  client_header_buffer_size 4k;</span><br><span class="line">  large_client_header_buffers 8 16k;</span><br><span class="line">  server_names_hash_bucket_size 128;</span><br><span class="line">  client_max_body_size 0m;</span><br><span class="line"></span><br><span class="line">  client_header_timeout 30s;</span><br><span class="line">  client_body_timeout 180s;</span><br><span class="line">  send_timeout 180s;</span><br><span class="line">  lingering_close off;</span><br><span class="line"></span><br><span class="line">  upstream smp-env-http-di1.19089.gts-seata-metrics.up &#123;</span><br><span class="line">    server 10.244.13.227:19089 weight&#x3D;1 max_fails&#x3D;1 fail_timeout&#x3D;10s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  server &#123;</span><br><span class="line">    listen 19089;</span><br><span class="line">    server_name smp-env-http-di1;</span><br><span class="line"></span><br><span class="line">    access_log &#x2F;var&#x2F;log&#x2F;ingress-gateway&#x2F;vhost_access.log main;</span><br><span class="line">    error_log &#x2F;var&#x2F;log&#x2F;ingress-gateway&#x2F;vhost_error.log;</span><br><span class="line">    # for support ssl        # for support data zip        # for support backend server.</span><br><span class="line">    # 后端default_backend的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">    #proxy_redirect                  off;</span><br><span class="line">    #proxy_next_upstream             error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">    proxy_headers_hash_bucket_size 6400;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">      root html;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line"></span><br><span class="line">      proxy_ignore_client_abort on;</span><br><span class="line">      proxy_pass http:&#x2F;&#x2F;smp-env-http-di1.19089.gts-seata-metrics.up&#x2F;;</span><br><span class="line">      proxy_connect_timeout 2s;</span><br><span class="line">      proxy_set_header Host $http_host;</span><br><span class="line">      proxy_http_version 1.1;</span><br><span class="line">      proxy_set_header Connection &quot;&quot;;</span><br><span class="line">      proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">      proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">      proxy_buffer_size 128k;</span><br><span class="line">      proxy_buffers 4 256k;</span><br><span class="line">      proxy_busy_buffers_size 256k;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Haproxy-配置"><a href="#Haproxy-配置" class="headerlink" title="Haproxy 配置"></a>Haproxy 配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">  daemon</span><br><span class="line">  log  127.0.0.1 local0 info</span><br><span class="line">  tune.ssl.default-dh-param 2048</span><br><span class="line">  maxconn  20000</span><br><span class="line">  pidfile  &#x2F;app&#x2F;haproxy&#x2F;run&#x2F;haproxy.pid</span><br><span class="line">  stats  socket &#x2F;app&#x2F;haproxy&#x2F;lib&#x2F;haproxy&#x2F;stats</span><br><span class="line">  tune.bufsize  131072</span><br><span class="line">  user nginx</span><br><span class="line">  group nginx</span><br><span class="line">  tune.ssl.default-dh-param 2048</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">  log  global</span><br><span class="line">  maxconn  10000</span><br><span class="line">  mode  http</span><br><span class="line">  option  dontlog-normal</span><br><span class="line">  option  http-server-close</span><br><span class="line">  retries  3</span><br><span class="line">  stats  enable</span><br><span class="line">  timeout  http-request 10s</span><br><span class="line">  timeout  queue 1m</span><br><span class="line">  timeout  connect 10s</span><br><span class="line">  timeout  client 1m</span><br><span class="line">  timeout  server 30m</span><br><span class="line">  timeout  check 10s</span><br><span class="line"></span><br><span class="line">listen Stats</span><br><span class="line">  bind 0.0.0.0:10000</span><br><span class="line">  mode http</span><br><span class="line">  stats enable</span><br><span class="line">  stats uri &#x2F;</span><br><span class="line">  stats refresh 5s</span><br><span class="line">  stats show-node</span><br><span class="line">  stats show-legends</span><br><span class="line">  stats hide-version</span><br><span class="line"></span><br><span class="line">frontend https_frontend</span><br><span class="line">  #bind *:80</span><br><span class="line">  mode http</span><br><span class="line">  bind *:443 ssl crt  &#x2F;app&#x2F;haproxy&#x2F;cert&#x2F;chenzhijun.top.pem</span><br><span class="line">  acl secure dst_port eq 443</span><br><span class="line">  http-request add-header X-Forwarded-Proto https if &#123; ssl_fc &#125;</span><br><span class="line">  #redirect scheme https if !&#123; ssl_fc &#125;</span><br><span class="line">  rspadd Strict-Transport-Security:\ max-age&#x3D;31536000;\ includeSubDomains;\ preload</span><br><span class="line">  rsprep ^Set-Cookie:\ (.*) Set-Cookie:\ \1;\ Secure if secure</span><br><span class="line">  option httpclose</span><br><span class="line">  default_backend web_server</span><br><span class="line"></span><br><span class="line">backend web_server</span><br><span class="line">  mode http</span><br><span class="line">  balance roundrobin</span><br><span class="line">  http-request add-header X-Forwarded-Proto https if &#123; ssl_fc &#125;</span><br><span class="line">  cookie SERVERID insert indirect nocache</span><br><span class="line">  server lb1 10.0.0.1:80 check port 80 inter 10s fastinter 2s downinter 3s rise 3 fall 3</span><br><span class="line">  server lb2 10.0.0.2:80 check port 80 inter 10s fastinter 2s downinter 3s rise 3 fall 3</span><br><span class="line"></span><br><span class="line">listen harbor-ceph</span><br><span class="line">  bind 0.0.0.0:80</span><br><span class="line">  mode tcp</span><br><span class="line">  maxconn 4086</span><br><span class="line">  server s1 oss.chenzhijun.top:80</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>nginx从docker容器的环境变量中获取值</title>
    <url>/2019/04/08/nginx-conf-get-env-from-docker-contaniner-enviroment/</url>
    <content><![CDATA[<h1 id="nginx从docker容器的环境变量中获取值"><a href="#nginx从docker容器的环境变量中获取值" class="headerlink" title="nginx从docker容器的环境变量中获取值"></a>nginx从docker容器的环境变量中获取值</h1><p>这篇接上一篇<a href="http://chenzhijun.top/2019/04/08/vuejs-starter/">vuejs 从拷项目到开发上线</a></p>
<h2 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h2><p>另外一个问题就是如何制作成镜像了？可以看到我们在nginx.conf中有api服务的地址，这个地址可能在不同的环境(di,sit,prd)都不一样，那能否通过容器的env来改变nginx.conf中的值呢？</p>
<p>不查不知道，一查发现，我擦，还真有，nginx镜像本身就已经具备了。不过是李template的方式，来生成conf文件话不多说，直接上代码，先创建一个<code>nginx.conf.template</code>的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80 default_server;</span><br><span class="line">    listen       [::]:80 default_server;</span><br><span class="line">    server_name  _;</span><br><span class="line">    root         &#x2F;app&#x2F;html;</span><br><span class="line"></span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;m-web&#x2F; &#123;</span><br><span class="line">        root &#x2F;app&#x2F;html&#x2F;dist;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F;m-web&#x2F;m-api&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;$&#123;M_API_SITE&#125;&#x2F;m-api&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">        location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后准备Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> rm -rf /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/nginx.conf</span></span><br><span class="line"><span class="keyword">ENV</span> M_API_SITE <span class="number">192.168</span>.<span class="number">1.19</span>:<span class="number">8089</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> nginx.conf.template /etc/nginx/conf.d/nginx.conf.template</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> dist /app/html/dist</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;envsubst &lt; /etc/nginx/conf.d/nginx.conf.template &gt; /etc/nginx/conf.d/nginx.conf &amp;&amp; exec nginx -g &#x27;daemon off;&#x27;&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后<code>docker build -t xxx:latest .</code>，之后我们就可以通过<code>-e M_API_SITE=192.168.123.1:8080</code>设置容器的环境变量来设置不同的api地址了。</p>
]]></content>
  </entry>
  <entry>
    <title>nginx-http-1.1</title>
    <url>/2019/12/18/nginx-http-1-1/</url>
    <content><![CDATA[<h1 id="Nginx-Http-1-1-Host规范"><a href="#Nginx-Http-1-1-Host规范" class="headerlink" title="Nginx Http 1.1 Host规范"></a>Nginx Http 1.1 Host规范</h1><p>最近发现一个异常问题。一个web服务挂载在nginx后端，然后client通过socket连接后，构建成http-post请求，发现最后nginx会直接返回499，发现其实是客户端断链接，其实应该不对。<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort</a></p>
<p>之后的是http1.1的规范。<a href="https://tools.ietf.org/html/rfc2616#section-14.23">https://tools.ietf.org/html/rfc2616#section-14.23</a> http1.1中，如果Host为空会直接返回400的状态码</p>
]]></content>
  </entry>
  <entry>
    <title>nginx 设置prometheus和grafana的反向代理</title>
    <url>/2018/05/02/nginx-proxy-promethues-grafana/</url>
    <content><![CDATA[<h1 id="nginx-设置promethues和grafana的反向代理"><a href="#nginx-设置promethues和grafana的反向代理" class="headerlink" title="nginx 设置promethues和grafana的反向代理"></a>nginx 设置promethues和grafana的反向代理</h1><p>在配置完promethues，和grafana之后，可能需要上生产环境，这个时候如果有下面两种情况，那么就可能需要用到代理；</p>
<ol>
<li>端口只开发80,或者8080等特别的几个端口，端口数量有限；</li>
<li>不希望暴露给外部端口号，使用子路经来区分；eg: http://{ip}/prometheus,http://{ip}/grafana</li>
</ol>
<p>nginx 配置，监听server的端口为80，然后通过子路径在内部反向代理出去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       127.0.0.1:80;</span><br><span class="line">    #server_name  localhost;</span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;   </span><br><span class="line">    #    proxy_pass http:&#x2F;&#x2F;127.0.0.1:9090&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F;grafana&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F;promethues&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:9090&#x2F;prometheus&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">    #error_page  404              &#x2F;404.html;</span><br><span class="line">    # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>alertmanager很大的情况等同与prometheus，可以等同配置。</p>
<h2 id="设置promethues的代理，子路径"><a href="#设置promethues的代理，子路径" class="headerlink" title="设置promethues的代理，子路径"></a>设置promethues的代理，子路径</h2><p>接下来需要的是将prometheus和grafana在启动或者配置文件中做一些更改，prometheus的相对来说比较简单，主要实在启动的时候根据命令行的参数来进行子路径设置。</p>
<p>在启动的时候设置<code>web.external-url</code>使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./prometheus --web.external-url=promethues</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="/images/qiniu/2018-05-03-13-04-03.png" alt="2018-05-03-13-04-03"></p>
<p>还可以使用<code>./promethues --help</code>获取更多的命令行参数，alertmanager同样也适用。</p>
<h2 id="设置grafana的代理，子路径"><a href="#设置grafana的代理，子路径" class="headerlink" title="设置grafana的代理，子路径"></a>设置grafana的代理，子路径</h2><p>grafana的代理需要在<code>default.ini</code>中配置root_url:<code>root_url = %(protocol)s://%(domain)s:/grafana</code></p>
<p>之后再重启就可以了。记住，再nginx中，proxy_pass 不要带上后缀。添加反向代理后，如果访问使用<code>http://localhost:3000/grafana</code>或者<code>http://localhost:3000</code>页面会显示不全。但是使用nginx代理后的路径：<code>http://localhost/grafana</code>就可以看到全页面了。</p>
<p><img src="/images/qiniu/2018-05-03-13-54-16.png" alt="2018-05-03-13-54-16"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://docs.grafana.org/installation/behind_proxy/">Running Grafana behind a reverse proxy</a></p>
]]></content>
      <categories>
        <category>monitor</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>prometheus</tag>
        <tag>grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>第三方授权登录(oauth2)--Github授权登录</title>
    <url>/2017/09/29/oauth2-github-login/</url>
    <content><![CDATA[<h2 id="第三方授权登录-github授权登录"><a href="#第三方授权登录-github授权登录" class="headerlink" title="第三方授权登录-github授权登录"></a>第三方授权登录-github授权登录</h2><blockquote>
<p>现在时下的框架都是非常流行第三方的授权登录，比如QQ，微信，微博，或者github等等，都是基于OAuth2授权令牌。</p>
</blockquote>
<h3 id="前期的准备"><a href="#前期的准备" class="headerlink" title="前期的准备"></a>前期的准备</h3><p>在现在很多互联网项目当中很少没有第三方登录的，本来想用QQ或者微信来弄，但是发现认证有点麻烦，后来看到github上面的授权很简单，几乎只要有一个github账号就能开始开发了。其实不管是哪个平台授权登录，只要了解了一个原理，其它的都类似了。整个流程图如下：<br><img src="/images/qiniu/2017-09-29-16-25-04.png" alt="2017-09-29-16-25-04"></p>
<h4 id="github-账号"><a href="#github-账号" class="headerlink" title="github 账号"></a>github 账号</h4><p>默认已经有了，如果没有的话作为开发者还是去注册一个吧，不多说了。</p>
<h4 id="注册一个应用"><a href="#注册一个应用" class="headerlink" title="注册一个应用"></a>注册一个应用</h4><p>注册一个我们的应用，该应用就是我们需要用第三方授权登录的应用,github有个好处，可以用<code>127.0.0.1</code>直接挂到本地进行测试，不知道其他的第三方可不可以，还待验证。<br><img src="/images/qiniu/2017-09-29-15-55-40.png" alt="2017-09-29-15-55-40"></p>
<span id="more"></span>
<h4 id="获取到client-id和client-key"><a href="#获取到client-id和client-key" class="headerlink" title="获取到client_id和client_key"></a>获取到client_id和client_key</h4><p>注册新应用之后我们主要是要拿到<code>client</code>和<code>client_key</code>:<br><img src="/images/qiniu/2017-09-29-16-10-22.png" alt="2017-09-29-16-10-22"><br>拿到之后我们就可以开始开发了。</p>
<h3 id="SpringBoot实现授权登录"><a href="#SpringBoot实现授权登录" class="headerlink" title="SpringBoot实现授权登录"></a>SpringBoot实现授权登录</h3><p>首先页面要有一个请求授权的操作，我们简化如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://github.com/login/oauth/authorize?client_id=0430a6c311c3dd1f4869&quot;</span>&gt;</span> github登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/qiniu/2017-09-29-16-35-04.png" alt="2017-09-29-16-35-04"></p>
<p>之后，需要在配置的回调地址就是我们<code>127.0.0.1</code>设置的url地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;login/github&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">loginGithub</span><span class="params">(String code, Model model)</span> </span>&#123;</span><br><span class="line">    logger.info(code);</span><br><span class="line">    System.out.println(<span class="string">&quot;code: &quot;</span> + code);</span><br><span class="line">    String url = <span class="string">&quot;https://github.com/login/oauth/access_token&quot;</span>;</span><br><span class="line"></span><br><span class="line">    MultiValueMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    map.add(<span class="string">&quot;client_id&quot;</span>, ConfigConstant.CLIENT_ID);</span><br><span class="line">    map.add(<span class="string">&quot;client_secret&quot;</span>, ConfigConstant.CLIENT_SECRET);</span><br><span class="line">    map.add(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">    JSONObject jsonObject = RemoteRequestUtil.post(url, map, JSONObject.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;jsonObject:&quot;</span> + jsonObject);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;result&quot;</span>, jsonObject);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;login/success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面用了一个<code>RemoteRequestUtils</code>,其实你只要有一个可以调用post方法的就可以了,我用的是<code>RestTemplate</code>来实现远程调用的，请注意:<code>RestTemplate 只支持传参数MultiValueMap</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteRequestUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">post</span><span class="params">(String url, Object request, Class&lt;T&gt; clazz, Object... uriValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(url, request, clazz, uriValues);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getT</span><span class="params">(String url, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">postT</span><span class="params">(String url, String param, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        System.out.println(url + <span class="string">&quot;:&quot;</span> + param);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(url, param, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">postT</span><span class="params">(String url, Object param, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        System.out.println(url + <span class="string">&quot;:&quot;</span> + param);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(url, param, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RemoteRequestUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以是用POJO的方式，但是地城的HttpEntity也是用的MultiValueMap,不信可以自己看看源码，如果用POJO的方式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GithubRequestLogin param = <span class="keyword">new</span> GithubRequestLogin();</span><br><span class="line">param.setClient_id(ConfigConstant.CLIENT_ID);</span><br><span class="line">param.setClient_secret(ConfigConstant.CLIENT_SECRET);</span><br><span class="line">param.setCode(code);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JSONObject jsonObj = RemoteRequestUtil.postT(url, param, JSONObject.class);</span><br><span class="line">System.out.println(jsonObj);</span><br></pre></td></tr></table></figure>

<p>到这里，我们就可以获取到<code>access_token</code>了,现在就可以用token获取用户信息了。</p>
<p>获取用户信息的代码：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;user/info&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGitHubUserInfo</span><span class="params">(String token, Model model)</span> </span>&#123;</span><br><span class="line">    String url = <span class="string">&quot;https://api.github.com/user?access_token=&quot;</span> + token;</span><br><span class="line">    String result = RemoteRequestUtil.get(url);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;result&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;login/success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就是这样的：<br><img src="/images/qiniu/2017-09-29-16-38-25.png" alt="2017-09-29-16-38-25"><br>这样就可以说是将信息获取完了。其他第三方平台也是大同小异常，以后有机会再补上。<br>当然还有一个问题要留下来，如果token过期了该怎么破了？怎么知道是否过期了？可以思考下。</p>
<p>代码比较简单，需要的话可以看我写的，代码写的有点不太贵方，只做参考，记得替换成你的<code>client_id</code>和<code>client_secret</code>：<br><a href="https://gitlab.com/chenzhijun/github-login">github授权登录</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OAuth2</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Openshift 专属机方案</title>
    <url>/2022/02/17/openshift-server-exclusive/</url>
    <content><![CDATA[<h1 id="Openshift-专属机方案"><a href="#Openshift-专属机方案" class="headerlink" title="Openshift 专属机方案"></a>Openshift 专属机方案</h1><span id="more"></span> 
<h2 id="专属机方案-Kubernetes-一）"><a href="#专属机方案-Kubernetes-一）" class="headerlink" title="专属机方案-Kubernetes(一）"></a>专属机方案-Kubernetes(一）</h2><ol>
<li>给所有主机新增 role:  [<code>node-role.kubernetes.io/&#123;xxxxx&#125;:](http://node-role.kubernetes.io/%7Bxxxxx%7D:) &quot;true&quot;</code>;这样在 oc get nodes 的时候就会多出一个 <code>xxxxx</code> 的角色；</li>
<li>给相关的主机打上污点：<code>oc adm nodes $i com.cmft.exclusive=xxxxx:NoSchedule</code> / <code>kubectl taint node com.cmft.exclusive=xxxxx:NoSchedule</code></li>
<li>让所有的业务 pod 增加主机调度和容忍，<code>nodeSelector</code>,<code>tolerations</code>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: harbor.uat.chenzhijun.top/base/nginx:latest</span><br><span class="line">    name: nginx</span><br><span class="line">    resources: &#123;&#125;</span><br><span class="line">  nodeSelector: </span><br><span class="line">    node-role.kubernetes.io/compute: <span class="string">&quot;true&quot;</span></span><br><span class="line">    node-role.kubernetes.io/xxxxx: <span class="string">&quot;true&quot;</span></span><br><span class="line">  tolerations: </span><br><span class="line">  - key: <span class="string">&quot;com.cmft.exclusive&quot;</span></span><br><span class="line">    operator: <span class="string">&quot;Equal&quot;</span></span><br><span class="line">    value: <span class="string">&quot;xxxxx&quot;</span></span><br><span class="line">    effect: <span class="string">&quot;NoSchedule&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="专属机方案-Openshift（二）"><a href="#专属机方案-Openshift（二）" class="headerlink" title="专属机方案-Openshift（二）"></a>专属机方案-Openshift（二）</h2><ol>
<li> 选定主机并且将主机的 label 进行修改，将 label 名改为 [<code>node-role.kubernetes.io](node-role.kubernetes.io/shimo)/xxx=true</code>，这样在 <code>oc get nodes</code> 时可以看到 <code>xxx</code> 的角色的主机；</li>
<li> project（namespace）在创建的时候可以使用<code>oc adm new-project demo --node-selector=&#39;node-role.kubernetes.io/xxx=true&#39;</code> 这样默认 project 会只调度到selector 的主机上。</li>
<li>如果是已存在的项目：<code>oc patch namespace demo -p &#39;&#123;&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&quot;openshift.io/node-selector&quot;:&quot;node-role.kubernetes.io/xxx=true&quot;&#125;&#125;&#125;&#39;</code> 可以进行 patch 操作；如果有多个 label 可以进行：<code>oc patch namespace demo -p &#39;&#123;&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&quot;openshift.io/node-selector&quot;:&quot;node-role.kubernetes.io/xxx1=true,node-role.kubernetes.io/xxx2=true&quot;&#125;&#125;&#125;&#39;</code></li>
<li>如果需要设置全局默认调度可以修改 master 配置文件：<code>/etc/origin/master/master-config.yaml</code>  <code>projectConfig.defaultNodeSelector</code> 然后重启 api 和 controller：<code>master-restart api</code>&amp;&amp;<code>master-restart api</code></li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenShift 专用 Router 实操</title>
    <url>/2022/02/27/openshift-router/</url>
    <content><![CDATA[<h1 id="Openshift-专用-Router-实操"><a href="#Openshift-专用-Router-实操" class="headerlink" title="Openshift 专用 Router 实操"></a>Openshift 专用 Router 实操</h1><p>由于某些服务在实际业务场景中非常重要，或者为了与其它业务进行入口区分，因此会产生专属 router（Ingress）的需求，在 openshift 的实际操作可以这样：</p>
<span id="more"></span> 

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">确保 sa 为 router 名字的有scc hostnetwork 权限</span></span><br><span class="line">oc adm policy add-scc-to-user hostnetwork -z router</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个 router ，指定 router-iot 为名字</span></span><br><span class="line">oc adm router router-iot --images=&#x27;harbor.uat.chenzhijun.top/openshift3/ose-haproxy-router:v3.11.170&#x27; --selector=&#x27;node-role.kubernetes.io/iot-router=true&#x27; --labels=&#x27;router=iot&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置 router 的 ns 标签</span></span><br><span class="line">oc set env dc/router-iot NAMESPACE_LABELS=&quot;router=iot”</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置 ns 标签</span></span><br><span class="line">oc label namespace demo “router=iot”</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置某个 ns 下的 router 必须有 cluster-reader 权限</span></span><br><span class="line">oc adm policy add-cluster-role-to-user cluster-reader system:serviceaccount:demo:router</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">https://docs.openshift.com/container-platform/3.11/admin_guide/manage_rbac.html</span></span><br><span class="line">oc adm policy add-role-to-user cluster-reader system:serviceaccount:demo:router</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改 router 监听端口</span></span><br><span class="line">oc adm router --replicas=0 --ports=&#x27;10080:10080,10443:10443&#x27; </span><br><span class="line">oc set env dc/router ROUTER_SERVICE_HTTP_PORT=10080 ROUTER_SERVICE_HTTPS_PORT=10443</span><br><span class="line">oc scale dc/router --replicas=1</span><br><span class="line"></span><br><span class="line">iptables -A OS_FIREWALL_ALLOW -p tcp --dport 10080 -j ACCEPT</span><br><span class="line">iptables -A OS_FIREWALL_ALLOW -p tcp --dport 10443 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">暴露一个 route</span></span><br><span class="line">oc expose service myservice --hostname=owner.example.test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">允许泛域名</span></span><br><span class="line">oc set env dc/router ROUTER_ALLOW_WILDCARD_ROUTES=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改泛域名子域</span></span><br><span class="line">oc adm router --force-subdomain=&#x27;$&#123;name&#125;-$&#123;namespace&#125;.apps.example.com&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>最近遇到的小问题总结-2018522</title>
    <url>/2018/05/22/problem-cmrh-2018522/</url>
    <content><![CDATA[<h1 id="最近遇到的小问题总结-2018522"><a href="#最近遇到的小问题总结-2018522" class="headerlink" title="最近遇到的小问题总结-2018522"></a>最近遇到的小问题总结-2018522</h1><ol>
<li><p>Excel将两列合并成一列：<code>=CONCATENATE()</code></p>
</li>
<li><p>linux统计文件,<a href="http://blog.sina.com.cn/s/blog_464f6dba01012vwv.html">原文链接</a>:</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">统计某文件夹下文件的个数</span><br><span class="line">ls -l |grep &quot;^-&quot;|wc -l</span><br><span class="line"></span><br><span class="line">统计某文件夹下目录的个数</span><br><span class="line">ls -l |grep &quot;^ｄ&quot;|wc -l</span><br><span class="line"></span><br><span class="line">统计文件夹下文件的个数，包括子文件夹里的</span><br><span class="line">ls -lR|grep &quot;^-&quot;|wc -l</span><br><span class="line"></span><br><span class="line">如统计/home/han目录(包含子目录)下的所有js文件则：</span><br><span class="line">ls -lR /home/han|grep js|wc -l 或 ls -l &quot;/home/han&quot;|grep &quot;js&quot;|wc -l</span><br><span class="line"></span><br><span class="line">统计文件夹下目录的个数，包括子文件夹里的</span><br><span class="line">ls -lR|grep &quot;^d&quot;|wc -l</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>linux sort的一些用法：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">去除重复行</span><br><span class="line">sort file |uniq</span><br><span class="line"></span><br><span class="line">查找非重复行</span><br><span class="line">sort file |uniq -u</span><br><span class="line"></span><br><span class="line">查找重复行</span><br><span class="line">sort file |uniq -d</span><br><span class="line"></span><br><span class="line">统计</span><br><span class="line">sort file | uniq -c</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>什么是linux vip：<a href="https://www.zhihu.com/question/67682565">https://www.zhihu.com/question/67682565</a>，<a href="https://www.novell.com/documentation/bcc/bcc11_admin_nw/data/bq7ucwl.html">https://www.novell.com/documentation/bcc/bcc11_admin_nw/data/bq7ucwl.html</a>。</p>
</li>
<li><p>Linux scp命令，上传或下载文件</p>
</li>
</ol>
<p>复制本地文件到远程服务器：<code>scp local_file remote_username@remote_ip:remote_folder</code>；<br>例如：<code>scp /home/chen/file.md chen@192.168.1.1:/home/chen/test.md</code></p>
<p>复制远程文件到本地：<code>scp remote_username@remote_ip:remote_folder local_file</code><br>例如：<code>scp chen@192.168.1.1:/home/chen/test.md /home/chen/file.md</code></p>
<ol start="5">
<li>修改文件所属用户和组信息</li>
</ol>
<p><code>chown username:usergroup /path/to/file</code></p>
<ol start="6">
<li>修改文件权限: ugo,a<br>user,group,other,all</li>
</ol>
<p><code>chmod a+x /path/to/file</code></p>
<p><code>chmod u+w /path/to/file</code></p>
<ol start="7">
<li>linux 查看ip：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr</span><br><span class="line">ifconfig</span><br><span class="line">hostname -I</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>解压缩文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压文件：tar -zvxf xxx.tar.gz</span><br><span class="line"></span><br><span class="line">压缩文件： tar -zvcf xxx.tar.gz &#x2F;path&#x2F;to&#x2F;file&#x2F;tozip</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>vim 一些操作</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vim 全文件内替换  ： :%s/old/new/g</span><br><span class="line">当前行替换：:s/old/new/g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim 打开多个文件： split/vsplit     </span><br><span class="line">文件切换ctrl w w， 获取CTRL w (上下左右或者jkhl)，CTRL F6 6</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>docker 删除容器状态为exited的容器：</li>
</ol>
<p><code>docker rm -v $(docker ps -aq -f status=exited)</code></p>
<ol start="10">
<li>删除所有none的tag的镜像</li>
</ol>
<p><code>docker images |grep none |awk &#39;&#123;print $3&#125;&#39;|xargs -i docker rmi &#123;&#125;</code></p>
<ol start="11">
<li>idea重置配置文件。</li>
</ol>
<p>D:\Users\chenzj001.IntelliJIdea2018.1 删除这个文件就好了，全部重置。也可以只删除config。<br>windows找到用户–&gt;.i</p>
<p>也就是在<code>用户目录</code>下,删除<code>.IntelliJIdea2018</code></p>
<ol start="12">
<li>windows 查找端口占用进程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr &quot;端口号&quot;</span><br><span class="line"></span><br><span class="line">tasklist|findstr “端口号”</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>problem</category>
      </categories>
      <tags>
        <tag>problem</tag>
      </tags>
  </entry>
  <entry>
    <title>Alertmanager发送的邮件中external-url修改机器名为IP地址</title>
    <url>/2022/06/09/prometheus-alertmanager-external-url/</url>
    <content><![CDATA[<h1 id="Alertmanager发送的邮件中external-url修改机器名为IP地址"><a href="#Alertmanager发送的邮件中external-url修改机器名为IP地址" class="headerlink" title="Alertmanager发送的邮件中external-url修改机器名为IP地址"></a>Alertmanager发送的邮件中external-url修改机器名为IP地址</h1><p>在使用Alertmanager发送报警邮件的时候，我们通常会采用模板。比如我的一个模板：</p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; define &quot;email.czj.html&quot; &#125;&#125;</span><br><span class="line">详情：&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123; range .Alerts.Firing &#125;&#125;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                  &lt;td class&#x3D;&quot;content-block&quot;&gt;</span><br><span class="line">                    &#123;&#123; if gt (len .Annotations) 0 &#125;&#125;&lt;strong&gt;描叙信息：&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;&#123;&#123; end &#125;&#125;</span><br><span class="line">                    &#123;&#123; range .Annotations.SortedPairs &#125;&#125;&#123;&#123; .Name &#125;&#125; &#x3D; &#123;&#123; .Value &#125;&#125;&lt;br &#x2F;&gt;&#123;&#123; end &#125;&#125;</span><br><span class="line">                    &lt;strong&gt;指标详情：&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;</span><br><span class="line">                    &#123;&#123; range .Labels.SortedPairs &#125;&#125;&#123;&#123; .Name &#125;&#125; &#x3D; &#123;&#123; .Value &#125;&#125;&lt;br &#x2F;&gt;&#123;&#123; end &#125;&#125;</span><br><span class="line">                    </span><br><span class="line">                    &lt;a href&#x3D;&quot;&#123;&#123; .GeneratorURL &#125;&#125;&quot;&gt;链接到Prometheus&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;</span><br><span class="line">                  &lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;br&#x2F;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">          &lt;table width&#x3D;&quot;100%&quot;&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">              &lt;td class&#x3D;&quot;aligncenter content-block&quot; style&#x3D;&quot;text-align: center;&quot;&gt;&lt;a href&#x3D;&#39;&#123;&#123; .ExternalURL &#125;&#125;&#39;&gt;由 &#123;&#123; template &quot;__Alertmanager&quot; . &#125;&#125;发送&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;&#x2F;tr&gt;</span><br><span class="line">          &lt;&#x2F;table&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果注意到会发现有：GeneratorURL和ExternalURL。这两者默认使用的是机器名称也就是<code>hostname</code>。这样我们就很难在邮件中获取到实际的promtheus和Alertmanager地址。查了很多资料，最后发现在prometheus和Alertmanager启动的时候我们可以设置这两个值的。prometheus的启动命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./prometheus.exe --web.external-url=&quot;http://127.0.0.1:9090/prom&quot; \</span><br><span class="line">                --web.route-prefix=prom \</span><br><span class="line">                --web.listen-address=&quot;0.0.0.0:9090&quot;</span><br></pre></td></tr></table></figure>

<p>Alertmanager启动命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./Alertmanager.exe --config.file=config163.yml \</span><br><span class="line">                    --web.external-url=http://127.0.0.1:9093/Alertmanager \              </span><br><span class="line">                    --web.route-prefix=Alertmanager</span><br></pre></td></tr></table></figure>

<p>这里的<code>web.external-url</code>也就是GeneratorURL和ExternalURL两者在email中的指，在设置<code>web.external-url</code>的同时我们需要记得设置<code>web.router-prefix</code>的值，应为<code>web.router-prefix</code>的默认值是<code>web.external-url</code>，如果不同时指定<code>web.router-prefix</code>那么就将会出现特别神奇的效果，你需要重复输入两个地址才能访问到相应的prometheus和Alertmanager，这个参数是指的路径。所以一定要设置<code>web.router-prefix</code>,你也可以设置成<code>--web.route-prefix=&quot;&quot;</code>这样来将子路径就设置为根路径。</p>
]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>Alertmanager</tag>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus+Grafana 搭建监控系统</title>
    <url>/2022/05/02/prometheus-grafana-monitor/</url>
    <content><![CDATA[<h1 id="Prometheus-Grafana-搭建监控系统"><a href="#Prometheus-Grafana-搭建监控系统" class="headerlink" title="Prometheus+Grafana 搭建监控系统"></a>Prometheus+Grafana 搭建监控系统</h1><p>今天将第一版监控系统上线，过程整个就是一路坎坷。不过踩坑，填坑，确实也是为自己积攒了一些小经验。</p>
<h2 id="Prometheus的服务发现"><a href="#Prometheus的服务发现" class="headerlink" title="Prometheus的服务发现"></a>Prometheus的服务发现</h2><p>Prometheus的监控使用的是pull的模式，也就是每隔几秒钟去各个target采集一次metric。那么如果是多个target，如果是静态配置的话，那么就得在配置文件里面一个一个添加，尽管可以使用接口去更新配置文件，但如果服务太多，那工作量也很大。而且如果遇到微服务的情况并且容器化部署，那么可能ip地址都是随机改变的，那么就将更麻烦了。所以就有服务发现的模式出来了，有很多种实现的方式，consul，dns等等，针对我们现有的平台，我们选择了file_sd_config:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="comment"># scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span>       <span class="string">&#x27;rancher_network_monitor&#x27;</span></span><br><span class="line">    <span class="comment"># Override the global default and scrape targets from this job every 5 seconds.</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">1m</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;192.168.7.3:8080&#x27;</span>,<span class="string">&#x27;192.168.8.90:8080&#x27;</span>]</span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">&#x27;rancher_network_monitor&#x27;</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;filediscovery&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">file_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">files:</span> [<span class="string">&#x27;/home/config/*.json&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>基于文件的方式，只需要在<code>/home/config</code>目录下增加json文件就可以了，这也是在网上找的一个方案，所以我也记录下来，万一也能帮助到别人了</p>
<span id="more"></span>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;10.10.10.1:65160&quot;</span>,</span><br><span class="line">            <span class="string">&quot;10.10.10.2:65160&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;labels&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;job&quot;</span>:<span class="string">&quot;Center&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;service&quot;</span>:<span class="string">&quot;qtest&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;10.10.10.3:65110&quot;</span>,</span><br><span class="line">            <span class="string">&quot;10.10.10.4:65110&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;labels&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;job&quot;</span>:<span class="string">&quot;Gateway&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;service&quot;</span>:<span class="string">&quot;qtest&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="监控报警规则-rule-files"><a href="#监控报警规则-rule-files" class="headerlink" title="监控报警规则 rule_files:"></a>监控报警规则 rule_files:</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&#x27;./alert.yml&#x27;</span></span><br></pre></td></tr></table></figure>

<p>规则可以在这里配置多个，这里其实也是支持通配符的。也就是：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&#x27;/path/to/rule/*.yml&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我使用的是yml格式，如果你会的话，也可以是用<code>.rule</code>;</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">goroutines_monitor</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">go_goroutines_test</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">go_goroutines</span> <span class="string">&gt;</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">goroutines_test</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">warning</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span>，机器goroutines过高。&quot;</span> </span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">instance_monitor</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">instance_down</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">1m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">instance</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">critical</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> 挂掉了,<span class="template-variable">&#123;&#123; $labels.job&#125;&#125;</span>&quot;</span> </span><br></pre></td></tr></table></figure>

<p>上面的yaml就是定义了两个规则，<code>go_goroutines&gt;200</code>以及<code>up==0</code>一个是go的协程数，一个是被监控目标是否可以正常采集。在则合理推荐使用labels，这样如果是使用alertmanager做预警，那么可以使用这些label。<code>for</code>的意思指接到一个触发报警rule的收将状态变成active，然后如果在for之内的评估期内如果没有报警就变成pending状态，如果有就变成firing，发送报警。</p>
<h2 id="alertmanager发送报警邮件"><a href="#alertmanager发送报警邮件" class="headerlink" title="alertmanager发送报警邮件"></a>alertmanager发送报警邮件</h2><p>alertmanager相当于通知中心，它只会在Prometheus发送报警后，通过某些渠道（邮件，即时通讯等）发送通知。当然它在通知这方面做了相当多的事情。</p>
<h3 id="alertmanager-通知分组"><a href="#alertmanager-通知分组" class="headerlink" title="alertmanager 通知分组"></a>alertmanager 通知分组</h3><p>如果是一个频繁的bug，引起Prometheus一直触发警报，如果不做限制，那么就会引起邮箱轰炸。alertmanager中的route就是做这个的。通过路由器将不同的邮件发送给不同的人。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">route:</span> </span><br><span class="line">  <span class="comment"># How long to initially wait to send a notification for a group</span></span><br><span class="line">  <span class="comment"># of alerts. Allows to wait for an inhibiting alert to arrive or collect</span></span><br><span class="line">  <span class="comment"># more initial alerts for the same group. (Usually ~0s to few minutes.)</span></span><br><span class="line">  <span class="comment"># group_wait: 30s</span></span><br><span class="line">  <span class="comment"># How long to wait before sending a notification about new alerts that</span></span><br><span class="line">  <span class="comment"># are added to a group of alerts for which an initial notification has</span></span><br><span class="line">  <span class="comment"># already been sent. (Usually ~5m or more.)</span></span><br><span class="line">  <span class="attr">group_interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="comment"># If an alert has successfully been sent, wait &#x27;repeat_interval&#x27; to resend them.</span></span><br><span class="line">  <span class="attr">repeat_interval:</span> <span class="string">10s</span>    </span><br><span class="line">  <span class="comment">#  A default receiver</span></span><br><span class="line">  <span class="attr">receiver:</span> <span class="string">monitor-admin</span>  </span><br><span class="line">  <span class="attr">group_by:</span> [<span class="string">name</span>, <span class="string">alertname</span>]</span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="comment"># All alerts with service=mysql or service=cassandra</span></span><br><span class="line">  <span class="comment"># are dispatched to the database pager.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">receiver:</span> <span class="string">&#x27;go-admin&#x27;</span></span><br><span class="line">    <span class="attr">group_wait:</span> <span class="string">30s</span></span><br><span class="line">    <span class="attr">group_by:</span> [<span class="string">name</span>, <span class="string">alertname</span>]</span><br><span class="line">    <span class="attr">match:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">goroutines_test</span></span><br><span class="line">      <span class="attr">alertname:</span> <span class="string">go_goroutines_test</span></span><br><span class="line">  <span class="comment"># All alerts with the team=frontend label match this sub-route.</span></span><br><span class="line">  <span class="comment"># They are grouped by product and environment rather than cluster</span></span><br><span class="line">  <span class="comment"># and alertname.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">receiver:</span> <span class="string">&#x27;instance-admin&#x27;</span></span><br><span class="line">    <span class="attr">group_interval:</span> <span class="string">1m</span></span><br><span class="line">    <span class="attr">group_by:</span> [<span class="string">name</span>, <span class="string">alertname</span>]</span><br><span class="line">    <span class="attr">match:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">instance</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>group_by: [label,...]</code>将通知分组，<code>group_interval: 30s</code>指的是如果在30s内收到同一组的邮件告警，那么将合并他们为一条邮件然后发送。<code>repeat_interval: 10s</code>当第一次发送邮件后下一次发送邮件的间隔。这个值一定要改，尤其是上线之后。routes主要是将邮件进行区分发送，这里我们之前在rule里面配置的label就可以起作用了。使用match来匹配那些label然后做不同的路由。</p>
<h3 id="alertmanager-邮件抑制"><a href="#alertmanager-邮件抑制" class="headerlink" title="alertmanager 邮件抑制"></a>alertmanager 邮件抑制</h3><p>邮件抑制的意思，我觉得更应该是邮件优先原则。指的是如果有两组告警，一组告警非常紧急，一组不重要，如果两组一起来告警，那么可能会引起，邮箱里面重要的告警被不重要的淹没了，从而导致我们忽略了某些重要告警。所以我们可以进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inhibit_rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">source_match:</span></span><br><span class="line">    <span class="attr">severity:</span> <span class="string">&#x27;critical&#x27;</span></span><br><span class="line">  <span class="attr">target_match:</span></span><br><span class="line">    <span class="attr">severity:</span> <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">  <span class="comment"># Apply inhibition if the alertname is the same.</span></span><br><span class="line">  <span class="comment"># equal: [&#x27;alertname&#x27;, &#x27;cluster&#x27;, &#x27;service&#x27;]</span></span><br><span class="line">  <span class="attr">equal:</span> [<span class="string">&#x27;monitor&#x27;</span>,<span class="string">&#x27;job&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>上面的规则就是，如果有serverity为critical的标签，那么serverity为warning的告警先不发，只发critical的告警。在Prometheus的rule里面如下配置：<br><img src="/images/qiniu/2018-04-26-23-54-39.png" alt="2018-04-26-23-54-39"></p>
<p>所以，多配置点label还是有点用的，哈哈。</p>
<p>ps：抑制的是某一种高级别的邮件发送，而这个邮件会按照定好的时间间隔一直发送，不会说只发一条就不发了。</p>
<h3 id="alertmanager-邮件静默"><a href="#alertmanager-邮件静默" class="headerlink" title="alertmanager 邮件静默"></a>alertmanager 邮件静默</h3><p>邮件静默其实就是指在某一段时间内，将某一类型的告警暂时忽略不让它发送告警。（又用到label了。。）创建静默的方式有两种，一个是直接在告警信息上创建；另一个是直接new silence：<br><img src="/images/qiniu/2018-04-26-23-58-20.png" alt="2018-04-26-23-58-20"></p>
<p>需要配置一个label。之后一定一定要配置时间，第一次使用的时候，我以为静默是一直忽略，然后我就下班了。之后回到家中，2h默认时间过后，我的邮箱爆炸了。。。所以静默是有时间限制的，一定要，一定要设置。<br><img src="/images/qiniu/2018-04-26-23-59-00.png" alt="2018-04-26-23-59-00"></p>
<h2 id="alertmanager的邮件模板"><a href="#alertmanager的邮件模板" class="headerlink" title="alertmanager的邮件模板"></a>alertmanager的邮件模板</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">templates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;./templates/*.tmpl&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">receivers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;monitor-admin&#x27;</span></span><br><span class="line">    <span class="attr">email_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">&#x27;noreply_czj@163.com&#x27;</span></span><br><span class="line">      <span class="attr">headers:</span> &#123; <span class="attr">Subject:</span> <span class="string">&quot;[WARN] <span class="template-variable">&#123;&#123; .CommonLabels.alertname&#125;&#125;</span> 报警邮件&quot;</span> &#125;</span><br><span class="line">      <span class="attr">html:</span> <span class="string">&#x27;<span class="template-variable">&#123;&#123; template &quot;email.czj.html&quot; . &#125;&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; define &quot;email.czj.html&quot; &#125;&#125;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;报警名&lt;&#x2F;td&gt;&lt;td&gt;xxx&lt;&#x2F;td&gt;&lt;td&gt;xx&lt;&#x2F;td&gt;&lt;td&gt;xxx&lt;&#x2F;td&gt;&lt;td&gt;xxx&lt;font color&#x3D;&#39;red&#39;&gt;[xxx]&lt;&#x2F;font&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">    &#123;&#123; range $i, $alert :&#x3D; .Alerts &#125;&#125;</span><br><span class="line">        &lt;tr&gt;&lt;td&gt;&#123;&#123; index $alert.Labels &quot;alertname&quot; &#125;&#125;&lt;&#x2F;td&gt;&lt;td&gt;&#123;&#123; $alert.StartsAt &#125;&#125;&lt;&#x2F;td&gt;&lt;td&gt;&#123;&#123; $alert.Labels.from &#125;&#125;&lt;&#x2F;td&gt;&lt;td&gt;&#123;&#123; $alert.Labels.to &#125;&#125;&lt;&#x2F;td&gt;&lt;td&gt;&#123;&#123; $alert.Labels.value &#125;&#125;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">    &#123;&#123; end &#125;&#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>邮件模板这里我是在网上找了一个非常详细的帖子。我觉得写的非常详细，主要注意就是要在模板的一行的define，要和receivers的html中tempate相对应。之后就是在模板中引用go语言的变量用<code>点+大写变量名</code>。详细可以看这边博客<a href="https://segmentfault.com/a/1190000008695463">alertmanager 邮件模板</a>。从源码解释，很详细。</p>
<p>&lt;!–&gt;<br>Data:.Alerts：[{firing map[instance:10.62.14.80:8080 job:example-random monitor:codelab-monitor to:10.62.12.3 alertname:node_connect from:10.62.14.80 group:production] map[summary:机器 10.62.14.80:8080 ，10.62.14.80，10.62.12.3] 2018-04-19 15:44:51.3912519 +0800 CST 0001-01-01 00:00:00 +0000 UTC <a href="http://ftsz-nb0078:9090/graph?g0.expr=host_to_host_http_connect+%3C=+0&amp;g0.tab=1%7D">http://FTSZ-NB0078:9090/graph?g0.expr=host_to_host_http_connect+%3C%3D+0&amp;g0.tab=1}</a> {firing map[monitor:codelab-monitor to:10.62.14.80 alertname:node_connect from:10.62.14.80 group:production instance:10.62.14.80:8080 job:example-random] map[summary:机器 10.62.14.80:8080 ，10.62.14.80，10.62.14.80] 2018-04-19 15:44:51.3912519 +0800 CST 0001-01-01 00:00:00 +0000 UTC <a href="http://ftsz-nb0078:9090/graph?g0.expr=host_to_host_http_connect+%3C=+0&amp;g0.tab=1%7D%5D">http://FTSZ-NB0078:9090/graph?g0.expr=host_to_host_http_connect+%3C%3D+0&amp;g0.tab=1}]</a><br>status:.status: firing<br>Receiver:.Receiver: team-X-mails<br>GroupLabels:.GroupLabels: map[alertname:node_connect]<br>CommonLabels:.CommonLabels: map[from:10.62.14.80 group:production instance:10.62.14.80:8080 job:example-random monitor:codelab-monitor alertname:node_connect]<br>CommonAnnotations:.CommonAnnotations: map[]<br>ExternalURL:.ExternalURL: <a href="http://ftsz-nb0078:9093/">http://FTSZ-NB0078:9093</a> </p>
<p>&lt;–&gt;</p>
<h2 id="alertmanager-邮件配置"><a href="#alertmanager-邮件配置" class="headerlink" title="alertmanager 邮件配置"></a>alertmanager 邮件配置</h2><p>注意一个，是否开启ssl。我们用的是http，所以把ssl关闭。我用163配置的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">smtp_smarthost:</span> <span class="string">&#x27;smtp.163.com:25&#x27;</span></span><br><span class="line">  <span class="attr">smtp_from:</span> <span class="string">&#x27;********@163.com&#x27;</span></span><br><span class="line">  <span class="attr">smtp_auth_username:</span> <span class="string">&#x27;*******@163.com&#x27;</span></span><br><span class="line">  <span class="attr">smtp_auth_password:</span> <span class="string">&#x27;*******&#x27;</span></span><br><span class="line">  <span class="attr">smtp_require_tls:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>一般本地测试的时候：<code>smtp_require_tls</code>这个可以是true，但是一般服务器不通外网可能不行。</p>
<h2 id="prometheus-与-alertmanager-降低日志级别"><a href="#prometheus-与-alertmanager-降低日志级别" class="headerlink" title="prometheus 与 alertmanager 降低日志级别"></a>prometheus 与 alertmanager 降低日志级别</h2><p>日志调到debug级别，两者都可以用<code>.alertmanager --help</code>或者<code>./promtheus --help</code>来查看所有可选项。</p>
<p>alertmanager:<code>./alertmanager --config.file=&#39;config163.yml&#39; --log.level=debug</code>;</p>
<p>prometheus: <code>./prometheus --web.enable-lifecycle --config.file=&#39;prometheus.yml&#39; --log.level=debug --web.external-url=http://localhost:9090/pro --web.route-prefix=pro</code></p>
<p>后面Prometheus的<code>--web.external-url=http://localhost:9090/pro</code>，<code>--web.route-prefix=pro</code>。这两个参数就类似加个服务号，如果有子路径做反向代理，Prometheus最好启动的时候就加上这两个。</p>
<p>比如在nginx用子路径做反向代理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       127.0.0.1:80;</span><br><span class="line">    #server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;   </span><br><span class="line">    #    proxy_pass http:&#x2F;&#x2F;127.0.0.1:9090&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;alertmanager&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:9093&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;pro&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:9090&#x2F;pro&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">    #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>暂时就这些吧。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://prometheus.io/docs/prometheus/latest/getting_started/">GETTING STARTED prometheus.io</a><br><a href="https://segmentfault.com/a/1190000008695463">alertmanager邮件模版</a><br><a href="https://www.kancloud.cn/huyipow/prometheus/527563">alertmanager报警规则详解</a><br><a href="http://blog.51cto.com/xujpxm/2055970">Prometheus智能化报警流程避免邮件轰炸</a><br><a href="https://prometheus.io/blog/2016/03/03/custom-alertmanager-templates/">Custom Alertmanager Templates</a></p>
]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 监控 Java 应用</title>
    <url>/2022/05/09/prometheus-monitor-tomcat/</url>
    <content><![CDATA[<h1 id="Prometheus-监控-Java-应用"><a href="#Prometheus-监控-Java-应用" class="headerlink" title="Prometheus 监控 Java 应用"></a>Prometheus 监控 Java 应用</h1><p>Prometheus 监控 Java 应用有两种方式：一种是使用官方提供的jar包，然后嵌入到应用中就可以了。这种方式一般都是新项目。我认为也是最合适的一种。不过这种情况一般是理想而已。而除了这种方式，第二种是prometheus的<a href="https://github.com/prometheus/jmx_exporter">jmx_exporter</a>。</p>
<p>今天我们讨论的就是第二种。使用jmx_exporter的方式来监控我们的java应用程序。我们的java应用基本上是使用tomcat作为服务器的。这种情况下有两种方式，一种是基于springboot的jar包启动方式，一种是直接下载tomcat软件之后，将应用打成war包部署的方式。</p>
<span id="more"></span>
<p>jmx_exporter的使用非常简单，但是如果不了解就会非常懵逼。jmx_exporter实际也是基于java的jmx通过暴露Mbean来做为代理，使用http的方式来给Prometheus进行指标采集。</p>
<h2 id="jar-包启动应用"><a href="#jar-包启动应用" class="headerlink" title="jar 包启动应用"></a>jar 包启动应用</h2><p>如果是jar包启动的方式，那么github上面就已经有示例了。可以参照：<code>java -javaagent:./jmx_prometheus_javaagent-0.3.0.jar=9151:config.yaml -jar yourJar.jar</code>，这种方式启动。这种属于在应用启动的时候就给它加上代理。</p>
<p>这种方式是没有加认证的，如果需要加认证，嗯，有点麻烦，实验过一次，后来发现，还是算了。可能在虚拟机上直接运行程序还好，但是打成docker镜像就真的就有点多余了。</p>
<p>这种方式是监控的内嵌tomcat的启动的应用，在访问<code>http://ip:9151/metrics</code>,<code>/metrics</code>可有可无，这个时候可以看到很多tomcat指标，当然如果你的config.yaml没有改动，那么可能并不会看到，因为官网的<a href="https://github.com/prometheus/jmx_exporter/blob/master/example_configs/tomcat.yml">config.yaml</a>中rules下的pattern:Catalina*****，这里是不适用与内嵌tomcat的。内嵌的tomcat需要修改为<code>Tomcat</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">startDelaySeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="comment">#hostPort: 192.168.226.128:8999</span></span><br><span class="line"><span class="comment">#jmxUrl: service:jmx:rmi:///jndi/rmi://127.0.0.1:8999/jmxrmi</span></span><br><span class="line"><span class="attr">ssl:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">wercaseOutputName:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">lowercaseOutputLabelNames:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">&#x27;Tomcat&lt;type=GlobalRequestProcessor, name=\&quot;(\w+-\w+)-(\d+)\&quot;&gt;&lt;&gt;(\w+):&#x27;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat_$3_total</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;$2&quot;</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">&quot;$1&quot;</span></span><br><span class="line">  <span class="attr">help:</span> <span class="string">Tomcat</span> <span class="string">global</span> <span class="string">$3</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">COUNTER</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">&#x27;Tomcat&lt;j2eeType=Servlet, WebModule=//([-a-zA-Z0-9+&amp;@#/%?=~_|!:.,;]*[-a-zA-Z0-9+&amp;@#/%=~_|]), name=([-a-zA-Z0-9+/$%~_-|!.]*), J2EEApplication=none, J2EEServer=none&gt;&lt;&gt;(requestCount|maxTime|processingTime|errorCount):&#x27;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat_servlet_$3_total</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">module:</span> <span class="string">&quot;$1&quot;</span></span><br><span class="line">    <span class="attr">servlet:</span> <span class="string">&quot;$2&quot;</span></span><br><span class="line">  <span class="attr">help:</span> <span class="string">Tomcat</span> <span class="string">servlet</span> <span class="string">$3</span> <span class="string">total</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">COUNTER</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">&#x27;Tomcat&lt;type=ThreadPool, name=&quot;(\w+-\w+)-(\d+)&quot;&gt;&lt;&gt;(currentThreadCount|currentThreadsBusy|keepAliveCount|pollerThreadCount|connectionCount):&#x27;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat_threadpool_$3</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;$2&quot;</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">&quot;$1&quot;</span></span><br><span class="line">  <span class="attr">help:</span> <span class="string">Tomcat</span> <span class="string">threadpool</span> <span class="string">$3</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">GAUGE</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">&#x27;Tomcat&lt;type=Manager, host=([-a-zA-Z0-9+&amp;@#/%?=~_|!:.,;]*[-a-zA-Z0-9+&amp;@#/%=~_|]), context=([-a-zA-Z0-9+/$%~_-|!.]*)&gt;&lt;&gt;(processingTime|sessionCounter|rejectedSessions|expiredSessions):&#x27;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat_session_$3_total</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">context:</span> <span class="string">&quot;$2&quot;</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">&quot;$1&quot;</span></span><br><span class="line">  <span class="attr">help:</span> <span class="string">Tomcat</span> <span class="string">session</span> <span class="string">$3</span> <span class="string">total</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">COUNTER</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">&quot;.*&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，你也看到了我的pattern这里有个：<code>&quot;.*&quot;</code>为啥这样？因为这样可以让所有的jmx metrics全部暴露出来，这方式有点暴力但是很好，很有用。</p>
<h2 id="Tomcat-war包应用"><a href="#Tomcat-war包应用" class="headerlink" title="Tomcat war包应用"></a>Tomcat war包应用</h2><p>war包应用部署就不说了，在bin目录启动<code>./startup.sh</code>就好了。但是如果要加上jmx_exporter。那么我们需要加上要给东西，进入bin目录（<code>$TOMCAT_HOME/bin</code>），将jmx_exporter.jar包文件和config.yaml文件复制到这里。然后修改里面的一个catalina.sh的脚本，找到<code>JAVA_OPTS</code>,加上代理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=&quot;$JAVA_OPTS $JSSE_OPTS&quot;</span><br><span class="line"></span><br><span class="line">JAVA_OPTS=&quot;$JAVA_OPTS -javaagent:$PWD/jmx_prometheus_javaagent-0.3.0.jar=9151:$PWD/config.yaml&quot;</span><br></pre></td></tr></table></figure>

<p>这种启动tomcat之后，你就可以通过访问9151端口来访问metrics了。这里要记得，修改上面的config.yaml中pattern的部分，改为和github上一样就可以了，也就是pattern为Catalina****。</p>
<h2 id="监控远程的-tomcat"><a href="#监控远程的-tomcat" class="headerlink" title="监控远程的 tomcat"></a>监控远程的 tomcat</h2><p>如果你不修改catalina.sh，可以采用在bin目录新建一个setenv.sh文件，<code>修改为可执行文件</code>。然后加入下面的设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">CATALINA_OPTS=<span class="string">&#x27;-javaagent:/home/chen/jmx_prometheus_javaagent-0.3.0.jar=9151:/home/chen/config.yaml&#x27;</span></span></span><br><span class="line">CATALINA_OPTS=&#x27;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">JAVA_OPTS=<span class="string">&#x27;-javaagent:/home/chen/jmx_prometheus_javaagent-0.10.jar=9151:/home/chen/config.yaml&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">CATALINA_OPTS=<span class="string">&#x27;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.password.file=/home/chen/jmxremote.password&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>这样在启动的时候tomcat就会暴露出8999端口并且打开metrics。上面是jmx不带认证的。</p>
<p>然后在另一端下载jmx_exporter，这里需要去下载<code>0.10</code>版本，在github 的release中找一下就好了。如果是远程的tomcat jmx，最新版本的代理反正是用不了，我的测试中<code>0.3.0</code>是用不了的，<code>0.10</code>是可以用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -javaagent:./jmx_prometheus_javaagent-<span class="number">0.10</span>.jar=<span class="number">9150</span>:config.yaml</span><br></pre></td></tr></table></figure>

<p>相应的config.yaml需要做一些修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">startDelaySeconds:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">hostPort:</span> <span class="number">192.168</span><span class="number">.226</span><span class="number">.128</span><span class="string">:8999</span></span><br><span class="line"><span class="attr">jmxUrl:</span> <span class="string">service:jmx:rmi:///jndi/rmi://192.168.226.128:8999/jmxrmi</span></span><br><span class="line"><span class="attr">ssl:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">wercaseOutputName:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">lowercaseOutputLabelNames:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">&#x27;Tomcat&lt;type=GlobalRequestProcessor, name=\&quot;(\w+-\w+)-(\d+)\&quot;&gt;&lt;&gt;(\w+):&#x27;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat_$3_total</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;$2&quot;</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">&quot;$1&quot;</span></span><br><span class="line">  <span class="attr">help:</span> <span class="string">Tomcat</span> <span class="string">global</span> <span class="string">$3</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">COUNTER</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">&quot;.*&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然如果是springboot，现在有<code>spring-boot-starter-actuator</code>的包，是可以直接暴露metrics的，当然也可以引入prometheus提供的client jar。</p>
<p>实际中，还是的多动手，实践出真知。</p>
]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 体验</title>
    <url>/2022/05/01/prometheus-pre-use/</url>
    <content><![CDATA[<h1 id="Prometheus-监控"><a href="#Prometheus-监控" class="headerlink" title="Prometheus 监控"></a>Prometheus 监控</h1><p> Prometheus [普罗米修斯]主要的是从被监控项目中获取metrics。架构全景图：</p>
<p><img src="/images/qiniu/2018-04-16-14-32-33.png" alt="2018-04-16-14-32-33"></p>
<h2 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h2><p>Prometheus 的安装方式很多，我在本地是使用windows的包，Prometheus自打出生就支持docker所以，如果是*inx机器，建议安装docker然后体验。在本地我仅仅只需要执行目录下的<code>prometheus</code>就可以就可以进行体验了。Prometheus服务自身也会暴露出metrics，用来对自身进行指标收集和监控。在根目录最重要的一个配置文件是<code>prometheus.yml</code>，里面有三类大属性：global，rule_files，scrape_configs。具体的配置信息可以看这个：<br><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">https://prometheus.io/docs/prometheus/latest/configuration/configuration/</a>，也可以看看中文文档：<a href="https://songjiayang.gitbooks.io/prometheus/configuration/">https://songjiayang.gitbooks.io/prometheus/configuration/</a></p>
<span id="more"></span>

<p>在Prometheus的后台<code>localhost:9090</code>，选择一个 metric，然后点击 execute，之后就可以在下面的graph和console中看到输出的结果：</p>
<p><img src="/images/qiniu/2018-04-18-22-18-09.png" alt="2018-04-18-22-18-09"></p>
<p>在<code>status</code>下选择<code>Configuration</code>然后可以看到<code>prometheus.yml</code>里面的定义。在<code>Target</code>下可以看到监控的目标源的ip地址的信息。</p>
<h2 id="metrics-类型"><a href="#metrics-类型" class="headerlink" title="metrics 类型"></a>metrics 类型</h2><p>metrics 有四类，并且每一个类都有相应的客户端lib。在目标监控中需要暴露出相应的metrics给prometheus服务器进行收集，之后才能进行有效的信息分析，之后预警和监控。</p>
<p>Prometheus客户端lib提供4种主要的核心metric类型：Counter，Gauge，Histogram，Summary。</p>
<p><code>Counter</code>：数值类型，只能增加，不能减少。用户计数请求服务，完成任务数，发生错误数。不要用在可能会减少的地方</p>
<p><code>Gauge</code>：数值类型可以增加可以减少，变化的类型，类似于测量温度，当前内存使用量</p>
<p><code>Histogram</code>：直方图对样本进行观察（比如请求的持续时间，响应大小）。并将其统计到一个可配置的bucket中。一个Histogram包括：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;basename&gt;_bucket&#123;le=&quot;&lt;upper</span> <span class="string">inclusive</span> <span class="string">bound&gt;&quot;&#125;</span></span><br><span class="line"><span class="string">&lt;basename&gt;_sum</span></span><br><span class="line"><span class="string">&lt;basename&gt;_count：指的是相同的&lt;basename&gt;_bucket&#123;le=&quot;+Inf&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Summary</code>：主要用于表示一段时间内数据采样结果，类似Histogram</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;basename&gt;&#123;quantile=&quot;&lt;φ&gt;&quot;&#125;</span>   <span class="string">（0</span> <span class="string">≤</span> <span class="string">φ</span> <span class="string">≤</span> <span class="number">1</span><span class="string">）</span></span><br><span class="line"><span class="string">&lt;basename&gt;_sum</span></span><br><span class="line"><span class="string">&lt;basename&gt;_count</span></span><br></pre></td></tr></table></figure>

<p>metrics定义如：<code>&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;</code></p>
<p>metrics接口需要注意，每行要空行，最后以空行结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HELP http_requests_total The total number of HTTP requests.</span><br><span class="line"># TYPE http_requests_total counter</span><br><span class="line">http_requests_total&#123;method&#x3D;&quot;post&quot;,code&#x3D;&quot;200&quot;&#125; 1027 1395066363000</span><br><span class="line">http_requests_total&#123;method&#x3D;&quot;post&quot;,code&#x3D;&quot;400&quot;&#125; 3 1395066363000</span><br><span class="line"></span><br><span class="line"># Escaping in label values:</span><br><span class="line">msdos_file_access_time_seconds&#123;path&#x3D;&quot;C:\\DIR\\FILE.TXT&quot;,error&#x3D;&quot;Cannot find file:\n\&quot;FILE.TXT\&quot;&quot;&#125; 1.458255915e9</span><br><span class="line"></span><br><span class="line"># Minimalistic line:</span><br><span class="line">metric_without_timestamp_and_labels 12.47</span><br><span class="line"></span><br><span class="line"># A weird metric from before the epoch:</span><br><span class="line">something_weird&#123;problem&#x3D;&quot;division by zero&quot;&#125; +Inf -3982045</span><br><span class="line"></span><br><span class="line"># A histogram, which has a pretty complex representation in the text format:</span><br><span class="line"># HELP http_request_duration_seconds A histogram of the request duration.</span><br><span class="line"># TYPE http_request_duration_seconds histogram</span><br><span class="line">http_request_duration_seconds_bucket&#123;le&#x3D;&quot;0.05&quot;&#125; 24054</span><br><span class="line">http_request_duration_seconds_bucket&#123;le&#x3D;&quot;0.1&quot;&#125; 33444</span><br><span class="line">http_request_duration_seconds_bucket&#123;le&#x3D;&quot;0.2&quot;&#125; 100392</span><br><span class="line">http_request_duration_seconds_bucket&#123;le&#x3D;&quot;0.5&quot;&#125; 129389</span><br><span class="line">http_request_duration_seconds_bucket&#123;le&#x3D;&quot;1&quot;&#125; 133988</span><br><span class="line">http_request_duration_seconds_bucket&#123;le&#x3D;&quot;+Inf&quot;&#125; 144320</span><br><span class="line">http_request_duration_seconds_sum 53423</span><br><span class="line">http_request_duration_seconds_count 144320</span><br><span class="line"></span><br><span class="line"># Finally a summary, which has a complex representation, too:</span><br><span class="line"># HELP rpc_duration_seconds A summary of the RPC duration in seconds.</span><br><span class="line"># TYPE rpc_duration_seconds summary</span><br><span class="line">rpc_duration_seconds&#123;quantile&#x3D;&quot;0.01&quot;&#125; 3102</span><br><span class="line">rpc_duration_seconds&#123;quantile&#x3D;&quot;0.05&quot;&#125; 3272</span><br><span class="line">rpc_duration_seconds&#123;quantile&#x3D;&quot;0.5&quot;&#125; 4773</span><br><span class="line">rpc_duration_seconds&#123;quantile&#x3D;&quot;0.9&quot;&#125; 9001</span><br><span class="line">rpc_duration_seconds&#123;quantile&#x3D;&quot;0.99&quot;&#125; 76656</span><br><span class="line">rpc_duration_seconds_sum 1.7560473e+07</span><br><span class="line">rpc_duration_seconds_count 2693</span><br></pre></td></tr></table></figure>

<h2 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h2><p>自定义Exporter其实就是暴露一个metrics接口让Prometheus服务器进行收集。所以只需要返回像上面的例子一样的文本数据就可以了。<br>官方推荐首先采用<code>Historam</code>。可以导入相应的客户端metric然后进行导入。</p>
<h2 id="继续学习"><a href="#继续学习" class="headerlink" title="继续学习"></a>继续学习</h2><ol>
<li>Prometheus 的内置函数</li>
<li>Prometheus 自定发现监控目标</li>
<li>报警规则，报警方式</li>
<li>图表</li>
<li>对接granafa</li>
</ol>
]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 常用的查询语句</title>
    <url>/2022/06/16/prometheus-query/</url>
    <content><![CDATA[<h2 id="Prometheus-常用的查询语句"><a href="#Prometheus-常用的查询语句" class="headerlink" title="Prometheus 常用的查询语句"></a>Prometheus 常用的查询语句</h2><p>通常我们会使用Grafana作为图表展示，然后选择Prometheus作为数据源的方式来进行我们想要的图表展示。当然我们也可以在Grafana的官网上找到相应的dashboard来直接导入，这样省去了自己手工配置的麻烦。不过知道一些必要的Prometheus查询语句能帮我们更好的选择Grafana的dashboard，然后我们可以自定义做些配置。</p>
<h3 id="Prometheus一些术语"><a href="#Prometheus一些术语" class="headerlink" title="Prometheus一些术语"></a>Prometheus一些术语</h3><p>Prometheus的metrics分为四类（counter,gauge,histogram,summary）详情(<a href="https://prometheus.io/docs/concepts/metric_types/">metrics-type</a>)，metrics_name的命令也应该符合一定的规范：<a href="https://prometheus.io/docs/concepts/data_model/">metrics-name</a>，<a href="https://prometheus.io/docs/practices/naming/">METRIC AND LABEL NAMING</a></p>
<p><code>metrics_name</code> ： 也就是指标名，通常我们都会用如http_request_total等进行查询;<br><code>metrics_label</code> ：指标的标签，也就是metrics_name{label-1=”a”,label-2=”b”}这种;<br><code>metrics_value</code> : 通常用指标名+标签查出来一个值，该值根据metrics的类型可能为浮点数，也可能为整数。</p>
<span id="more"></span>

<h3 id="0-基础查询"><a href="#0-基础查询" class="headerlink" title="0,基础查询"></a>0,基础查询</h3><p>也就是使用metrics_name+metrics_label的组合进行查询，这种查询的效率的基础是你要知道明确知道相应的name和label，如果有错误拼写，则可能数据无法展示，Prometheus的查询工具能帮我们模糊匹配出所有的metrics_name。可以使用label进行筛选。<br>如果只记得部分metrics_name,那么可以使用内置的label：<code>&#123;__name__=~&quot;metrics_name_you_remember:.*&quot;&#125;</code>这样去匹配出来你想要的标签。</p>
<h3 id="1-正则匹配查询"><a href="#1-正则匹配查询" class="headerlink" title="1,正则匹配查询"></a>1,正则匹配查询</h3><p>Prometheus里面用的最多的查询可能就是正则匹配了。经常配合Grafana的变量(variable)一起使用。比如：<br><code>sum(irate(node_disk_reads_completed&#123;device!~&quot;dm-.*&quot;&#125;[5m]))</code>,这里面的<code>device!~&quot;dm-.*&quot;</code>，后面<br>引号内的<code>dm-.*</code>就是不匹配<code>dm-</code>前缀的所有metrics_name。如果要匹配的话使用<code>=~</code>。这样要注意，如果是或<br>的话要用<code>(regrex_A|regrex_B)</code>,用小括号加<code>|</code>。</p>
<h3 id="2-常用的操作符和函数"><a href="#2-常用的操作符和函数" class="headerlink" title="2,常用的操作符和函数"></a>2,常用的操作符和函数</h3><p>Prometheus支持常用的操作符：<code>+,-,*,/,&gt;=,&lt;,&gt;,....</code>等</p>
<p>count是对查询的结果数量进行总和+; 而sum是对查询出来的value进行总和+;</p>
<p>它也支持比如topk,bottomk,min,max等等。</p>
<h3 id="更多的查询"><a href="#更多的查询" class="headerlink" title="更多的查询"></a>更多的查询</h3><p>在官网还有更多的查询，通常我们是结合Grafana来做。官网的查询:<a href="https://prometheus.io/docs/Prometheus/latest/querying/functions/">proetheus-query</a>。</p>
]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 使用 influxdb 做永久存储</title>
    <url>/2022/06/09/prometheus-storage-influxdb/</url>
    <content><![CDATA[<h1 id="Prometheus-使用远端存储"><a href="#Prometheus-使用远端存储" class="headerlink" title="Prometheus 使用远端存储"></a>Prometheus 使用远端存储</h1><p>使用Prometheus的过程中，我们可以发现Prometheus默认是自己带有存储的，不过保存的时间为15天。但是对于公司而言，可能有时候会对数据进行统计分析，那么15天的数据将不会满足要求了。所以我们希望能够将数据永久存储起来，或者说能够让我们自己将数据进行处理。</p>
<p>这里我们要讲的就是Prometheus的 remote_storage 功能。Prometheus的remote_storage 其实是一个adapter，至于在adapter的另一端是什么类型的时序数据库它根本不关心，如果你愿意，你也可以编写自己的adpater。我这里采用官网提供的influxdb作为远端存储的实例。</p>
<p>存储的方式为：Prometheus —-发送数据—- &gt; remote_storage_adapter —- 存储数据 —-&gt; influxdb。</p>
<span id="more"></span>
<h2 id="下载安装influxdb"><a href="#下载安装influxdb" class="headerlink" title="下载安装influxdb"></a>下载安装influxdb</h2><p>我采用的docker安装influxdb，非常容易。下载influxdb的镜像，然后让它暴露出相应的端口：</p>
<p><code>docker run -p 8086:8086 -v $PWD:/var/lib/influxdb --name influxdb influxdb</code> 这样，一个influxdb就准备好了。influxdb的一些介绍或者操作可以查看官网。<br>我们安装好influxdb之后需要在influxdb中创建一个prometheus的库：<br><code>curl -XPOST http://localhost:8086/query --data-urlencode &quot;q=CREATE DATABASE prometheus&quot;</code>。</p>
<h2 id="准备remote-storage-adapter"><a href="#准备remote-storage-adapter" class="headerlink" title="准备remote_storage_adapter"></a>准备remote_storage_adapter</h2><p>在github上准备一个<a href="https://github.com/prometheus/prometheus/blob/master/documentation/examples/remote_storage/remote_storage_adapter/README.md">remote_storage_adapter</a>的可执行文件，然后启动它，如果想获取相应的帮助可以使用:<code>./remote_storage_adapter -h</code>来获取相应帮助(修改绑定的端口，influxdb的设置等..)，现在我们启动一个remote_storage_adapter来对接influxdb和prometheus：<br><code>./remote_storage_adapter -influxdb-url=http://localhost:8086/ -influxdb.database=prometheus -influxdb.retention-policy=autogen</code>，influxdb默认绑定的端口为<code>9201</code></p>
<h2 id="修改-prometheus-yml-配置对接adapter"><a href="#修改-prometheus-yml-配置对接adapter" class="headerlink" title="修改 prometheus.yml 配置对接adapter"></a>修改 prometheus.yml 配置对接adapter</h2><p>前面的准备操作完了之后，就可以对prometheus进行配置了。修改<code>prometheus.yml</code>文件，在文件末尾增加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">remote_write:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">&quot;http://localhost:9201/write&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">remote_read:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">&quot;http://localhost:9201/read&quot;</span></span><br></pre></td></tr></table></figure>

<p>之后我们启动prometheus就可以看到influxdb中会有相应的数据了。如果验证我们采集的metrics数据被存储起来了呢？我们选取一个metric，过几分钟然后将prometheus停止，并且将data目录删除，重启prometheus，然后我们再查询这个metric，可以看到之前几分钟的数据还在那里。</p>
<h3 id="prometheus-高可用"><a href="#prometheus-高可用" class="headerlink" title="prometheus 高可用"></a>prometheus 高可用</h3><p>最近在实践一个事情，就是Prometheus的高可用，我的想法是将所有数据都存储到influxdb，但是influxdb集群版本竟然是闭源的。我擦。。。不过这个事情倒不是最重要，实在不行我们自己弄集群版本。我的高可用选择是有多个prometheus进行的是采集，在yaml种只配置remote_write，然后让某几台Prometheus机器做查询，只配置remote_read，并且查询的prometheus不做scape-config，也就是没有采集任务，完全的查询客户端，当然还有规则报警。在实际中要注意<code>global.external_labels.monitor</code>这个配置必须是 <strong>相同的值</strong>。不然的话查询客户端不能查询到相应的metric。当然你也可以不设置这个值。<br>另外实践中我发现federate机器也就是prometheus的联邦机器，在另一个prometheus配置了一台federate之后，它会将从federate采集到的数据收集起来，并且存储到influxdb中，也就是相应的做了持久化存储。</p>
<p>目前还有两个问题没有解决：多个查询客户端prometheus如果都配置了报警rule的话，会不会产生单个报警重复报？另外还有就是influxdb的集群方案，该怎么操作？还要进一步研究才行啊。~~</p>
<h3 id="附录，influxdb的一些操作："><a href="#附录，influxdb的一些操作：" class="headerlink" title="附录，influxdb的一些操作："></a>附录，influxdb的一些操作：</h3><p>influxdb常用操作：<br>    显示数据库：show databases<br>    创建一个库：create database database_name<br>    删除一个库：drop database database_name<br>    使用库：use database<br>    表操作：show measurements<br>    插入数据<br>    <code>insert &lt;tbname&gt;,&lt;tags&gt; &lt;values&gt; [timestamp]    </code><br>    说明：<br>    tbname : 数据表名称<br>    tags : 表的tag域<br>    values : 表的value域<br>    timestamp ：当前数据的时间戳（可选，没有提供的话系统会自带添加）</p>
<pre><code>示例如下：
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use testdb;</span><br><span class="line">Using database testdb</span><br><span class="line">&gt; insert students,stuid&#x3D;s123 score&#x3D;89</span><br><span class="line">&gt; show measurements;</span><br><span class="line">name: measurements</span><br><span class="line">name</span><br><span class="line">----</span><br><span class="line">students</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Promethues 联邦集群</title>
    <url>/2022/05/10/promethues-federate/</url>
    <content><![CDATA[<h1 id="Prometheus-联邦集群"><a href="#Prometheus-联邦集群" class="headerlink" title="Prometheus 联邦集群"></a>Prometheus 联邦集群</h1><p>Prometheus的联邦集群我们使用它来作为Prometheus代理。因为我们是在监控rancher平台里面的docker容器里面的应用，那么拿到的就是容器的ip，而我们实际的Prometheus是部署在外部虚拟机上面的。这个时候外部的Prometheus就无法拿到rancher平台内部容器应用的metrics，所以部署一台prometheus到rancher组成联邦机，详细的官网有解释:<a href="https://prometheus.io/docs/prometheus/latest/federation/">federate</a>，总体架构图如下</p>
<span id="more"></span>
<p><img src="/images/qiniu/2018-05-10-12-59-05.png" alt="2018-05-10-12-59-05"></p>
<p>外部连接方式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="comment"># - job_name: &#x27;prometheus&#x27;</span></span><br><span class="line">  <span class="comment">#   # metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">  <span class="comment">#   # scheme defaults to &#x27;http&#x27;.</span></span><br><span class="line">  <span class="comment">#   static_configs:</span></span><br><span class="line">  <span class="comment">#     - targets: [&#x27;localhost:9091&#x27;]</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;federate&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="comment"># honor_labels: true</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">&#x27;/federate&#x27;</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">       <span class="string">&#x27;match[]&#x27;</span><span class="string">:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;&#123;job=~&quot;prometheus&quot;&#125;&#x27;</span></span><br><span class="line">        <span class="comment">#- &#x27;&#123;job=&quot;*&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="comment">#     - &#x27;&#123;job=&quot;prometheus&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="comment">#     - &#x27;&#123;__name__=~&quot;job:.*&quot;&#125;&#x27;</span></span><br><span class="line">        <span class="comment">#  - &#x27;&#123;job=&quot;rancher_network_monitor&quot;&#125;&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;&#123;job=&quot;targets-server&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&#x27;localhost:9090&#x27;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&#x27;10.62.14.129:9090&#x27;</span></span><br><span class="line">      <span class="comment">#  - &#x27;10.62.12.3:9090&#x27;</span></span><br><span class="line">      <span class="comment">#  - &#x27;10.0.11.23:80&#x27;</span></span><br></pre></td></tr></table></figure>

<p>额外注意就是这里的job_name下有一个match，这个好像必须要填写，嗯就是这样，只要在内部的Prometheus代理将job那么定义好，在外部再像上面的配置文件一个配置，就能在外部访问内部的prometheus的数据，而且可以保存这些数据在外部的Prometheus。</p>
]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Rancher 体验</title>
    <url>/2018/04/18/rancher-experience/</url>
    <content><![CDATA[<h1 id="Rancher-体验"><a href="#Rancher-体验" class="headerlink" title="Rancher 体验"></a>Rancher 体验</h1><p>Rancher是一个开源的企业级容器管理平台。花了大概3个小时从零到自己搭建一个能运行的服务，真的容易啊。而且文档很丰富，官方还有中文版。哈~，地址：<a href="https://rancher.com/docs/rancher/v1.6/zh/">文档</a>。</p>
<h2 id="安装-Rancher"><a href="#安装-Rancher" class="headerlink" title="安装 Rancher"></a>安装 Rancher</h2><p>安装Rancher其实很简单，因为它本身就提供了image，所以只需要在本地安装docker，然后下载镜像，之后再启动就完事了。整个过程非常顺利。唯一一个需要主要的地方是，它需要两台机器。一个作为rancher主节点，一个作为工作节点。所以，如果想体验一下 Rancher 的能力，最好能有两台ip不一样的机器，并且两台都安装了docker，当然也可以用虚拟机。</p>
<p><code>docker run -d --name rancher -p 8080:8080 --restart=unless-stopped rancher/server:stable</code></p>
<p>安装完 Rancher 之后，需要配置一下主机。Rancher 做了非常棒的国际化，支持中文。��[笑哭.png]</p>
<span id="more"></span>

<p><img src="/images/qiniu/2018-04-18-22-49-38.png" alt="2018-04-18-22-49-38"> 主机的注册地址，一般是rancher主节点的ip地址。</p>
<p>之后选择基础架构-&gt;添加主机。</p>
<p><img src="/images/qiniu/2018-04-18-22-53-45.png" alt="2018-04-18-22-53-45"></p>
<p>只需要将脚本进行拷贝，在运行的另一台安装了docker的主机上执行它，之后就能在主机中看到了：</p>
<p><img src="/images/qiniu/2018-04-18-22-55-12.png" alt="2018-04-18-22-55-12"></p>
<h2 id="应用安装与运行"><a href="#应用安装与运行" class="headerlink" title="应用安装与运行"></a>应用安装与运行</h2><p>应用分为<code>用户应用</code>和<code>基础设施应用</code>。用户应用：</p>
<p><img src="/images/qiniu/2018-04-18-22-55-50.png" alt="2018-04-18-22-55-50"></p>
<p>基础设施应用：</p>
<p><img src="/images/qiniu/2018-04-18-22-58-49.png" alt="2018-04-18-22-58-49"></p>
<p>添加应用：</p>
<p><img src="/images/qiniu/2018-04-18-22-59-59.png" alt="2018-04-18-22-59-59"></p>
<p>应用是一个服务集，应用下可以有很多服务。一个应用下的网段是在一块的，不同应用之间的网络是不能直接连接的。</p>
<p>添加完应用之后就是添加服务：</p>
<p><img src="/images/qiniu/2018-04-18-23-04-08.png" alt="2018-04-18-23-04-08"></p>
<p>添加完服务之后添加负载均衡：</p>
<p><img src="/images/qiniu/2018-04-18-23-04-54.png" alt="2018-04-18-23-04-54"></p>
<p>一个发布在rancher中的应用就可以体验了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://rancher.com/docs/rancher/v1.6/zh/">Rancher 文档</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Rancher</tag>
      </tags>
  </entry>
  <entry>
    <title>过去一段时间遇到的一些问题</title>
    <url>/2019/08/17/record-last/</url>
    <content><![CDATA[<h1 id="随笔-过去一段时间遇到的一些问题"><a href="#随笔-过去一段时间遇到的一些问题" class="headerlink" title="随笔-过去一段时间遇到的一些问题"></a>随笔-过去一段时间遇到的一些问题</h1><span id="more"></span>
<p>Q: Ansible 远程执行无法找到命令的问题。</p>
<p>A: 实际上是bash / sh的问题，执行的时候使用<code>ansible all -i hosts -m shell -a &#39;PATH=&quot;/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/bin:/usr/bin&quot;;source /etc/profile;groupadd docker&#39;</code></p>
<p>Q：kubernetes 一个节点的ip被加入到集群中，使得节点ip变成了kube-ipvs0里面的子网</p>
<p>A: 创建了外部服务，但是外部服务的ip地址为node的一个节点ip，产生的后果为这个节点与其它节点直接无法ping通。</p>
<p>Q: Docker 使用非Root用户管理或者 Docker无权限</p>
<p>A: <a href="https://docs.docker.com/install/linux/linux-postinstall/">https://docs.docker.com/install/linux/linux-postinstall/</a></p>
<p><code>Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.26/build?buildargs=%7B%7D&amp;buildbinds=null&amp;cachefrom=%5B%5D&amp;cgroupparent=&amp;cpuperiod=0&amp;cpuquota=0&amp;cpusetcpus=&amp;cpusetmems=&amp;cpushares=0&amp;dockerfile=Dockerfile&amp;labels=%7B%7D&amp;memory=0&amp;memswap=0&amp;networkmode=default&amp;pull=1&amp;rm=1&amp;shmsize=0&amp;t=harbor.uat.x.com%2Fx-library%2Fadms-app-0627%3A170&amp;ulimits=null: dial unix /var/run/docker.sock: connect: permission denied</code></p>
<p>Q: Docker 的远程仓库用户权限文件。</p>
<p>A: <code>$HOME/.dockercfg</code> 在用户根目录的<code>.dockercfg</code>目录。如果要查当前仓库登陆的用户<code>docker login hub.xxx.com</code></p>
<p>Q：kubernetes 直接运行一个pod</p>
<p>A: <code>kubectl run testconfig --image=harob -o yaml --dry-run</code></p>
<p>Q：kubernetes 获取某个资源的解释或者yaml的定义解释</p>
<p>A：<code>kubectl explain pods.spec</code></p>
<p>Q: git 使用代理</p>
<p>A: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://proxy.example.com:8888</span><br><span class="line"></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line"></span><br><span class="line">git config --global --add remote.origin.proxy &quot;socks5://127.0.0.1:18001&quot;</span><br><span class="line"></span><br><span class="line">git config --unset-all</span><br></pre></td></tr></table></figure>

<p>Q：docker删除不需要的镜像。</p>
<p>A: <code>docker images|grep &#39;none&#39;|awk &#39;&#123;print $3&#125;&#39;|xargs -r docker rmi -f</code></p>
<p>Q：MySQL 集群无法重启</p>
<p>A: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;wsrep_provider_options&#39;;</span><br><span class="line">&#x2F;data&#x2F;mysql&#x2F;grastate.dat 修改</span><br><span class="line">safe_to_bootstrap: 1</span><br></pre></td></tr></table></figure>

<p>Q: linux某个进程无响应</p>
<p>A: <a href="https://blog.csdn.net/jctian000/article/details/80695025">https://blog.csdn.net/jctian000/article/details/80695025</a></p>
<p><code>/proc/进程号/fd</code></p>
<p><code>/proc/进程/stack</code></p>
<p>Q：Linux逻辑卷扩容</p>
<p>A:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vgextend vg00 /dev/vdc</span><br><span class="line">lvextend -L +20G /dev/vg00/home</span><br><span class="line">xfs_growfs /dev/vg00/home</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Q: curl timeout</p>
<p>A: <code>curl --connect-timeout 2 -m 5 100.66.7.2:25</code></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Restful 接口返回响应码</title>
    <url>/2019/05/05/restful-api/</url>
    <content><![CDATA[<h1 id="Restful-接口返回响应码"><a href="#Restful-接口返回响应码" class="headerlink" title="Restful 接口返回响应码"></a>Restful 接口返回响应码</h1><p>最近用restful做接口，突然想想返回状态码该怎么返回给客户端或者调用者。毕竟那么多的状态码。</p>
<p>后来找到一个状态码解释:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1xx：信息响应类，表示接收到请求并且继续处理</span><br><span class="line">2xx：处理成功响应类，表示动作被成功接收、理解和接受</span><br><span class="line">3xx：重定向响应类，为了完成指定的动作，必须接受进一步处理</span><br><span class="line">4xx：客户端错误，客户请求包含语法错误或者是不能正确执行</span><br><span class="line">5xx：服务端错误，服务器不能正确执行一个正确的请求</span><br><span class="line"></span><br><span class="line">100——客户必须继续发出请求</span><br><span class="line">101——客户要求服务器根据请求转换HTTP协议版本</span><br><span class="line"></span><br><span class="line">200——交易成功</span><br><span class="line">201——提示知道新文件的URL</span><br><span class="line">202——接受和处理、但处理未完成</span><br><span class="line">203——返回信息不确定或不完整</span><br><span class="line">204——请求收到，但返回信息为空</span><br><span class="line">205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class="line">206——服务器已经完成了部分用户的GET请求</span><br><span class="line"></span><br><span class="line">300——请求的资源可在多处得到</span><br><span class="line">301——删除请求数据</span><br><span class="line">302——在其他地址发现了请求数据</span><br><span class="line">303——建议客户访问其他URL或访问方式</span><br><span class="line">304——客户端已经执行了GET，但文件未变化</span><br><span class="line">305——请求的资源必须从服务器指定的地址得到</span><br><span class="line">306——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class="line">307——申明请求的资源临时性删除</span><br><span class="line"></span><br><span class="line">400——错误请求，如语法错误</span><br><span class="line">401——请求授权失败</span><br><span class="line">402——保留有效ChargeTo头响应</span><br><span class="line">403——请求不允许</span><br><span class="line">404——没有发现文件、查询或URl</span><br><span class="line">405——用户在Request-Line字段定义的方法不允许</span><br><span class="line">406——根据用户发送的Accept拖，请求资源不可访问</span><br><span class="line">407——类似401，用户必须首先在代理服务器上得到授权</span><br><span class="line">408——客户端没有在用户指定的饿时间内完成请求</span><br><span class="line">409——对当前资源状态，请求不能完成</span><br><span class="line">410——服务器上不再有此资源且无进一步的参考地址</span><br><span class="line">411——服务器拒绝用户定义的Content-Length属性请求</span><br><span class="line">412——一个或多个请求头字段在当前请求中错误</span><br><span class="line">413——请求的资源大于服务器允许的大小</span><br><span class="line">414——请求的资源URL长于服务器允许的长度</span><br><span class="line">415——请求资源不支持请求项目格式</span><br><span class="line">416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class="line">417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</span><br><span class="line"></span><br><span class="line">500——服务器产生内部错误</span><br><span class="line">501——服务器不支持请求的函数</span><br><span class="line">502——服务器暂时不可用，有时是为了防止发生系统过载</span><br><span class="line">503——服务器过载或暂停维修</span><br><span class="line">504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长</span><br><span class="line">505——服务器不支持或拒绝支请求头中指定的HTTP版本</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转链表</title>
    <url>/2017/04/06/reverse-node-md/</url>
    <content><![CDATA[<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><blockquote>
<p>比如链表1-2-3-4-5 翻转为 链表5-4-3-2-1 格式</p>
</blockquote>
<p>构建基础链表，链表的数据结构比较简单，就是一个数据项，一个下一个节点。我在这里其实遇到过一个理解问题，总是把node当成了链表。其实一个node就是一个小块。不是那一条链，只不过它的中间有下一个node，这样一层一层组成了一个链表。所以记得一个链表中，node指的是一个节点，而不是一个链。能这样理解，那么翻转链表也不是什么问题了。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by alvin on 4/2/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node nextNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextNode</span><span class="params">(Node nextNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">initNode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node temp = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Node nextNode = <span class="keyword">new</span> Node(i);</span><br><span class="line">            temp.setNextNode(nextNode);</span><br><span class="line">            temp = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node node = initNode(<span class="number">5</span>);</span><br><span class="line">        out(node,<span class="string">&quot;init:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(Node node,String prompt)</span></span>&#123;</span><br><span class="line">        System.out.print(prompt);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != node) &#123;</span><br><span class="line">            System.out.print(node.getData()+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            node = node.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们写测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by alvin on 4/2/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node node = Node.initNode(<span class="number">4</span>);</span><br><span class="line">        Node.out(node,<span class="string">&quot;遍历init:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n==========&quot;</span>);</span><br><span class="line">        Node reversNode = reverseNode(node);</span><br><span class="line">        Node.out(reversNode,<span class="string">&quot;遍历翻转:&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Node node1 = Node.initNode(<span class="number">4</span>);</span><br><span class="line">        Node.out(node1,<span class="string">&quot;递归init:&quot;</span>);</span><br><span class="line">        Node reversNode2 = reverseNode1(node1);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n==========&quot;</span>);</span><br><span class="line">        Node.out(reversNode2,<span class="string">&quot;递归翻转:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="遍历反转"><a href="#遍历反转" class="headerlink" title="遍历反转"></a>遍历反转</h3><p><img src="/images/reverse-node.jpeg" alt="遍历链表排序"><br>像图片中所示的一样，第一次在上面，我们定义pre，cur，next三个指示量，链表的好处在于，只要将链表中的节点指向另一个地方就完成了对这个节点链表的操作。每一次我们先将第一个节点保存，将第二个节点的nextNode 指向第一个节点。依次类推，得到的最终node链表就是我们翻转后的了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历翻转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">reverseNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node pre = node;</span><br><span class="line">    Node cur = node.getNextNode();</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    pre.setNextNode(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != cur) &#123;</span><br><span class="line">        next = cur.getNextNode();</span><br><span class="line">        cur.setNextNode(pre);</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归翻转"><a href="#递归翻转" class="headerlink" title="递归翻转"></a>递归翻转</h3><p><em><strong>递归的程序必须有一个终止递归的条件。</strong></em> 递归的思路是递归链表到最后那个节点，然后一层一层的将nextNode 至为上一个node，而上一个node设置为null，这样可以防止在递归回来时，第一个节点和第二个节点造成节点死循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">reverseNode1</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == node || <span class="keyword">null</span> == node.getNextNode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node reHead = reverseNode1(node.getNextNode());</span><br><span class="line"></span><br><span class="line">        node.getNextNode().setNextNode(node);</span><br><span class="line"></span><br><span class="line">        node.setNextNode(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从命令行参数获取Shell脚本参数</title>
    <url>/2018/01/08/shell-get-param-from-console/</url>
    <content><![CDATA[<h1 id="从命令行参数获取Shell脚本参数"><a href="#从命令行参数获取Shell脚本参数" class="headerlink" title="从命令行参数获取Shell脚本参数"></a>从命令行参数获取Shell脚本参数</h1><p>很多时候我们写完脚本都需要指定一些变量，这些变量可能根据实际的环境而值不同。所以如何在 shell 脚本中接收到不同的变量值了？</p>
<h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><p>shell 脚本获取参数的方式很多，我只记录我用过的一种：<code>filebeat.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [ ! -n &quot;$1&quot; ] ;then</span><br><span class="line">    echo &quot;请输入日志文件目录,比如/path/to/xxx.log,输入/path/to:&quot;  </span><br><span class="line">    exit 1;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;日志文件目录：$1&quot; #log_path</span><br><span class="line"></span><br><span class="line">if [ ! -n &quot;$2&quot; ] ;then</span><br><span class="line">    echo &quot;请输入项目名称,比如customer,notice ...:&quot;  </span><br><span class="line">    exit 1;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;项目名称:$2&quot; #log_type</span><br><span class="line"></span><br><span class="line">cd $(pwd)/filebeat</span><br><span class="line"><span class="meta">#</span><span class="bash"> copy a filebeat.yml to filebeat_log_type.yml</span></span><br><span class="line">cp config/filebeat.yml config/filebeat_$2.yml</span><br><span class="line">sed -i &quot;s#PATH#$1#g&quot; config/filebeat_$2.yml</span><br><span class="line">sed -i &quot;s#DOCTYPE#$2#g&quot; config/filebeat_$2.yml</span><br><span class="line">nohup ./filebeat -e -c config/filebeat_$2.yml &gt;&gt; logs/$2.log &amp;</span><br><span class="line">tail -f logs/$2.log</span><br></pre></td></tr></table></figure>

<p>shell 文件都是用<code>#!/bin/bash</code>作为第一行，我们在 filebeat.sh 中获取两个参数，如何使用这个脚本了？<br><code>sh filebeat.sh param1 param2</code></p>
<p>param1 我们在脚本中使用<code>$1</code>获取，param2 我们在脚本中使用<code>$2</code>获取，以此类推。</p>
<p>如果要在文件中替换某个特殊文字或者字符如果值中带有<code>/path/to/file</code>,这种带有<code>/</code>的字符，在脚本中可以使用<code>#</code>来转义。之前用的是<code>sed -i &quot;s/path/$1/g&quot; config/file.yml</code>,后来改成<code>sed -i &quot;s#path#$1#g config/file.yml</code>。</p>
<p>参考文档：<br><a href="http://www.jb51.net/article/56549.htm">http://www.jb51.net/article/56549.htm</a></p>
<p><a href="https://www.jianshu.com/p/d3cd36c97abc">https://www.jianshu.com/p/d3cd36c97abc</a></p>
<p><a href="http://blog.51cto.com/w55554/1223870">http://blog.51cto.com/w55554/1223870</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 相关基本操作</title>
    <url>/2019/09/07/shell-learn-1/</url>
    <content><![CDATA[<h1 id="shell-相关基本操作"><a href="#shell-相关基本操作" class="headerlink" title="shell 相关基本操作"></a>shell 相关基本操作</h1><h2 id="shell-基础"><a href="#shell-基础" class="headerlink" title="shell 基础"></a>shell 基础</h2><p>shell中的脚本通常就是控制台中的语句，将这些语句结合到一个文件中，就组成了脚本。脚本的第一行通常是<code>#!/bin/bash</code>开通，这行的作用是指定用哪个shell。可以<code>cat /etc/shells</code>查看当前操作系统支持哪些shell。</p>
<p>在控制台中我们使用 <code>;</code> 隔开多条语句，在shell脚本中则是一行命令独立一行。通常我们会以<code>*.sh</code>结尾来作为一个脚本名称，另外会将其权限设置为可执行权限：<code>chmod u+x *.sh</code>。</p>
<span id="more"></span>


<h2 id="管道与重定向"><a href="#管道与重定向" class="headerlink" title="管道与重定向"></a>管道与重定向</h2><p>管道的符号是：<code>|</code>，作用是将前一个命令的操作结果传给第二个命令：<code>ps | cat</code>，<code>echo 123 | ps</code></p>
<p>重定向的符号:</p>
<p>1: 输入重定向：<code>&lt;</code>;<br>2：输出重定向<code>&gt;</code>,<code>&gt;&gt;</code>,<code>2&gt;</code>,<code>&amp;&gt;</code>;</p>
<p>输入输出组合使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /path/to/a/file &lt;&lt; EOF</span><br><span class="line">I am test</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><code>&gt;</code> : 先会清空文件然后再输出到文件</p>
<p><code>&gt;&gt;</code> ：追加到文件中，会在最后一行添加</p>
<p><code>2&gt;</code> ：如果出现异常，将异常结果输出到文件中</p>
<p><img src="/images/qiniu/2019-09-07-11-36-12.png" alt="2019-09-07-11-36-12"></p>
<p><code>&amp;&gt;</code> : 不管结果对错都输入到文件中</p>
<p><img src="/images/qiniu/2019-09-07-11-41-02.png" alt="2019-09-07-11-41-02"></p>
<h2 id="shell-脚本执行的几种方式"><a href="#shell-脚本执行的几种方式" class="headerlink" title="shell 脚本执行的几种方式"></a>shell 脚本执行的几种方式</h2><p><code>bash xxx.sh</code> : 开了一个子进程bash执行脚本，可以不需要shell文件有可执行权限，就可以执行脚本；</p>
<p><code>./xxx.sh</code> ：同bash，不过需要脚本有可执行权限；</p>
<p><code>source xxx.sh</code> ：在当前shell内去执行脚本，脚本可以没有可执行权限；</p>
<p><code>. xxx.sh</code> ：source的缩写；</p>
<p><img src="/images/qiniu/2019-09-07-11-53-42.png" alt="2019-09-07-11-53-42"></p>
<h2 id="变量定义与使用"><a href="#变量定义与使用" class="headerlink" title="变量定义与使用"></a>变量定义与使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME=chenzhijun</span><br><span class="line">echo $NAME</span><br></pre></td></tr></table></figure>

<p>上面中<code>=</code>两边不能有空格，不然的话会将 NAME 识别成一个命令来报错。使用变量 NAME 的时候只需要带上<code>$</code>即可。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><code>env</code> <code>set</code> 获取环境变量；</p>
<p><code>$PS1</code>可以修改总端显示</p>
<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p><code>$?</code> : 使用<code>echo $?</code>可以获取上一条命令执行的结果，成功为0，失败为1</p>
<p><code>$$</code> ：获取当前的pid</p>
<p><code>$0</code> ：当前进程名称</p>
<p><img src="/images/qiniu/2019-09-07-12-15-44.png" alt="2019-09-07-12-15-44"></p>
<p>执行的方式不同，<code>$0</code>的值也不同。</p>
<h3 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$1</span> <span class="variable">$2</span> ...<span class="variable">$9</span> <span class="variable">$&#123;10&#125;</span></span></span><br><span class="line"></span><br><span class="line">pos1=$1</span><br><span class="line">pos2=$&#123;2-_&#125; # 如果$2为空值，用`_`代替</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/</span><br><span class="line"></span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.bashrc</span><br><span class="line"></span><br><span class="line">/etc/bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>/etc/profile*</code> 是所有用户通用的。<code>~/.bash*</code>是用户特有的。 </p>
<p>用户登录分为<code>login shell</code>，<code>nologin shell</code> 。如果是<code>su - user</code>是<code>login-shell</code> ，如果是<code>su user</code>是<code>nologin shell</code></p>
<p>如果在每个文件第一行加入<code>echo xxx</code>，可以看到如下加载顺序：</p>
<p><img src="/images/qiniu/2019-09-07-12-34-30.png" alt="2019-09-07-12-34-30"></p>
<p>要注意作用域的问题，shell执行的时候通常是一个subshell，也就是一个子进程shell，要注意变量是否可以传递过去。一般可以用<code>source /etc/profile</code>来重加载；也使用export也可以将当前shell的变量传递subshell中。</p>
<p><img src="/images/qiniu/2019-09-07-12-39-06.png" alt="2019-09-07-12-39-06"></p>
<p>上面的方式是在<code>/etc/profile</code>文件最后面增加了<code>aaa</code>变量，使用source可以加载到当前shell中，使用export可以在subshell（bash命令）也同样获取到<code>aaa</code>的值。</p>
<h2 id="常用的一些脚本命令"><a href="#常用的一些脚本命令" class="headerlink" title="常用的一些脚本命令"></a>常用的一些脚本命令</h2><ol>
<li>找出dir目录下文件名带 <code>xxx</code> 的文件 : <code>find /dir -name *xxx*</code> ; </li>
<li>找出dir目录下文件中带 <code>xxx</code> 内容的文件 ：<code>grep -r &quot;xxx&quot; /dir</code> ;</li>
<li>找出dir目录下文件名带 <code>aaa</code> 的文件并且文件路径中有 <code>bbb</code> 然后查找这些文件中含有 <code>ccc</code> 的文件，替换这些文件中的 <code>ddd</code> 为 <code>eee</code>: <code>find /dir -name &quot;*aaa*&quot;|grep &#39;bbb&#39;|xargs grep &#39;ccc&#39; -l|xargs sed -i &#39;s/ddd/eee/g&#39;</code> ;<br><code>grep -l</code> 为输出全路径。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/dylanaraps/pure-bash-bible">github shell 大全</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>shell-operation</title>
    <url>/2019/12/18/shell-operation/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>shell 脚本学习</title>
    <url>/2018/05/13/shell-script/</url>
    <content><![CDATA[<h1 id="shell-脚本学习"><a href="#shell-脚本学习" class="headerlink" title="shell 脚本学习"></a>shell 脚本学习</h1><p>shell 脚本在linux上可以说是非常有用的一个工具，它就是linux命令的一个集合，所以写好shell脚本的关键一部分就是对linux命令比较熟悉。</p>
<p>本博客是在图书馆借阅shell相关脚本学习书记做的一个简单笔记。</p>
<h2 id="shell-脚本的创建与执行"><a href="#shell-脚本的创建与执行" class="headerlink" title="shell 脚本的创建与执行"></a>shell 脚本的创建与执行</h2><p>一般我们在linux中创建的shell脚本都是以<code>.sh</code>为结尾的，这其实不是说一定要用sh结尾才行，只是大家约定习俗的一个习惯而已。<br>在shell文件的第一行，通常是<code>#!/bin/bash</code>，表示该脚本使用bash语法。<code>#</code>是shell脚本中的注释。通常自定义的脚本我通常习惯放在<code>/usr/local/bin</code>目录下,<a href="https://unix.stackexchange.com/questions/8656/usr-bin-vs-usr-local-bin-on-linux">关于bin,sbin,/usr/bin,/usr/local/bin等的区别</a></p>
<p>现在我们创建第一个脚本<code>first.sh</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello,world&quot;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>脚本创建好之后有两种运行方式:</p>
<ol>
<li>使用bash执行：<code>bash first.sh</code></li>
<li>直接执行：先让first.sh变成可执行脚本<code>chmod +x first.sh</code>,然后再直接运行<code>./first.sh</code></li>
</ol>
<p>脚本运行过程中可以使用<code>bash -x first.sh</code>，这样可以看到脚本的执行过程。</p>
<h2 id="shell-脚本的变量"><a href="#shell-脚本的变量" class="headerlink" title="shell 脚本的变量"></a>shell 脚本的变量</h2><h3 id="脚本预定义变量"><a href="#脚本预定义变量" class="headerlink" title="脚本预定义变量"></a>脚本预定义变量</h3><p>shell 预先设置的几个变量值，比如<code>optin.sh</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo $0 $1 $2</span><br></pre></td></tr></table></figure>

<p>如果执行：<code>./option.sh 1 2</code>,输出为：<code>option.sh 1 2</code></p>
<p>也就是执行脚本的时候后面的参数有几个，在脚本中直接使用<code>$位置</code>就可以使用这些变量值，0位置是脚本的名称。</p>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>在脚本中自己定义的变量，<code>变量名=变量值</code>，在脚本中使用的方式为<code>$变量名</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">num=1</span><br><span class="line">echo &quot;$num&quot;</span><br></pre></td></tr></table></figure>

<p><code>num=1</code> 中<code>num</code>和<code>=</code>之间不要有空格,不要有空格，不要有空格。</p>
<h3 id="控制台变量值传递"><a href="#控制台变量值传递" class="headerlink" title="控制台变量值传递"></a>控制台变量值传递</h3><p>控制台交互性，读取控制台输入的数，然后传递给脚本中，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; x</span><br><span class="line">read -p &quot;Please input another number: &quot; y</span><br><span class="line"></span><br><span class="line">sum=$[$x+$y]</span><br><span class="line"></span><br><span class="line">echo &quot;the sum of the two numbers is : $sum&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#chen@ubuntu:~/shell-learn$ bash read.sh</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash">Please input a number: 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Please input another number: 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash">the sum of the two numbers is : 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><p>简单的加减乘除的运算，使用<code>[]</code>前面需要加上<code>$</code>，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">sum=$[$a+$b]</span><br><span class="line"></span><br><span class="line">echo &quot;$a+$b=$sum&quot;</span><br><span class="line"></span><br><span class="line">echo ================</span><br><span class="line"></span><br><span class="line">sum2=$[$a+$b]</span><br><span class="line">echo &quot;$a+$b=$sum2&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># sh sum.sh 1+2=$[1+2]</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># bash sum.sh 1+2=3</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># ./sum.sh  1+2=3</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 这三种方式执行结果不一样</span></span></span><br></pre></td></tr></table></figure>

<h2 id="if-else-条件逻辑语句"><a href="#if-else-条件逻辑语句" class="headerlink" title="if-else 条件逻辑语句"></a>if-else 条件逻辑语句</h2><p>对于if-else大家在任何一门语言中都是必备的，shell中的if-else格式如下：</p>
<h3 id="常用的数值判断"><a href="#常用的数值判断" class="headerlink" title="常用的数值判断"></a>常用的数值判断</h3><p>if-else常用的根据数字来判断的相关实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 单独<span class="keyword">if</span>语句</span></span><br><span class="line">if 判断语句; then</span><br><span class="line">    command</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> if-else 语句</span></span><br><span class="line">if 判断语句; then</span><br><span class="line">    command</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">if-elseif-else 语句</span></span><br><span class="line">if 判断语句; then </span><br><span class="line">    command</span><br><span class="line">elif 判断语句2; then</span><br><span class="line">    command</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">num=$1</span><br><span class="line"></span><br><span class="line">if ((num&lt;60));then</span><br><span class="line">	echo &quot;you don&#x27;t pass the exam; your score is $num&quot;</span><br><span class="line">elif ((num&gt;=60&amp;&amp;num&lt;80));then</span><br><span class="line">	echo &quot;good job, your score is $num&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;great job, your score is $num&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if ((num==60));then </span><br><span class="line">	echo &quot;ok&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if ((num!=50));then</span><br><span class="line">	echo &quot;not equal 50&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>执行的时候：<code>./if.sh 89</code>。</p>
<p>数值大小的判断除了有<code>(())</code>之外，还可以使用<code>[]</code>，如果使用<code>[]</code>，那么就不能使用<code>&gt; , &lt; , =</code>这些符号，要使用:<br>小于：<code>-lt</code>，大于：<code>-gt</code>，小于或等于：<code>-le</code>，大于或等于：<code>-ge</code>，等于：<code>-eq</code>，不等于：<code>-ne</code>，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">a=10</span><br><span class="line">if [ $a -lt 5 ];then echo ok;fi</span><br><span class="line">if [ $a -gt 5 ];then echo gt;fi</span><br><span class="line">if [ $a -ge 5 ];then echo ge;fi</span><br><span class="line">if [ $a -eq 5 ];then echo eq;fi</span><br><span class="line">if [ $a -ne 5 ];then echo ne;fi</span><br></pre></td></tr></table></figure>

<h3 id="if中常用的跟文档相关的判断"><a href="#if中常用的跟文档相关的判断" class="headerlink" title="if中常用的跟文档相关的判断"></a>if中常用的跟文档相关的判断</h3><p>if 语句中可以使用一些内置的跟文件判断相关的参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span>判断跟文件相关的一些参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -e 判断文件或目录是否存在</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 判断是不是目录，以及是否存在</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f 判断是不是普通文件，以及是否存在</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 判断是否有读权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -w 判断是否有写权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x 判断是否可执行</span></span><br><span class="line"></span><br><span class="line">if [ -e /home/ ]; then echo ok ;fi</span><br><span class="line"></span><br><span class="line">if [ -f /home/ ]; then echo ok ;fi</span><br><span class="line"></span><br><span class="line">if [ -f /home/chen/shell-learn/if1.sh ]; then echo ok ;fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="case-逻辑判断"><a href="#case-逻辑判断" class="headerlink" title="case 逻辑判断"></a>case 逻辑判断</h2><p>java中有if之外还有switch，shell中除了if之外还有case,如果总结一下啊，可以发现if中的结束用fi，case中结束用esac，刚好是倒过来的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span>语句，value可以任意个，*指代其它值。类似java switch default</span></span><br><span class="line"> case 变量 in</span><br><span class="line"> value1)</span><br><span class="line"> 	command</span><br><span class="line"> 	;;</span><br><span class="line"> value2)</span><br><span class="line"> 	command</span><br><span class="line"> 	;;</span><br><span class="line"> value3)</span><br><span class="line"> 	command</span><br><span class="line"> 	;;</span><br><span class="line"> *)</span><br><span class="line"> 	command</span><br><span class="line"> 	;;</span><br><span class="line"> esac</span><br></pre></td></tr></table></figure>

<p>实例脚本，判断奇偶数字：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">num=$1</span><br><span class="line">n=$[$num%2]</span><br><span class="line"></span><br><span class="line">case $n in</span><br><span class="line">1)</span><br><span class="line">	echo &quot;奇数&quot;</span><br><span class="line">	;;</span><br><span class="line">0)</span><br><span class="line">	echo &quot;偶数&quot;</span><br><span class="line">	;;</span><br><span class="line">*)</span><br><span class="line">	echo &quot;其它的值&quot;</span><br><span class="line">	;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之前跟同事学的一个很有用的基础脚本：<a href="http://chenzhijun.top/2018/05/10/a-easy-script/">地址</a></p>
<h2 id="shell中的循环：for，while"><a href="#shell中的循环：for，while" class="headerlink" title="shell中的循环：for，while"></a>shell中的循环：for，while</h2><p>常用到的循环就是for和while了，</p>
<p>for的使用方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 脚本循环</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 循环的条件; <span class="keyword">do</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">	<span class="built_in">command</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">done</span></span></span><br><span class="line"></span><br><span class="line">for i in 1 2 3 4 5 6; do</span><br><span class="line">	echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for filename in `ls`; do</span><br><span class="line">	echo $filename</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>while 的使用方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">while</span> 条件; <span class="keyword">do</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 	<span class="built_in">command</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">done</span></span></span><br><span class="line"></span><br><span class="line">num=5 </span><br><span class="line"></span><br><span class="line">while [ $num -ge 1 ]; do</span><br><span class="line">	echo $num</span><br><span class="line">	num=$[ $num-1 ]</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>while 中如果是<code>while :; do</code>那么就是死循环了，有些地方可以这样使用。</p>
<h2 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h2><p>shell的函数一定要在被调用之前声明，生命函数的关键字是<code>function</code>,函数的参数个数需要在调用的时候指定，如<code>func.sh</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function sum()</span><br><span class="line">&#123;	</span><br><span class="line">	sum=$[$1+$2]</span><br><span class="line">	echo $sum</span><br><span class="line">	echo &quot;第三个变量：&quot; $3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum $1 $2</span><br><span class="line"></span><br><span class="line">echo &quot;=======================&quot;</span><br><span class="line"></span><br><span class="line">sum $1 $2 $3</span><br></pre></td></tr></table></figure>

<p>调用的方式<code>./func.sh 1 2 3</code> 输出结果为：<br><img src="/images/qiniu/2018-05-13-18-56-53.png" alt="2018-05-13-18-56-53"></p>
<p>可以看到第一个函数里面的<code>$1 $2 $3</code>跟shell脚本预设的变量是不相关的，函数里面能用的参数都是<code>sum</code>传递进去的。</p>
<blockquote>
<p>ps: 如果每次写完脚本都需要使用<code>chmod +x xxx.sh</code>这样也挺烦的，不如写个脚本吧，<code>x.sh</code>。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x *.sh</span><br></pre></td></tr></table></figure>
<p>这样就可以使用<code>./x.sh</code>，直接执行脚本就好了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序算法</title>
    <url>/2018/03/17/shell-sort/</url>
    <content><![CDATA[<h1 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h1><p>这个算法是插入排序的基础上做的优化，它描叙与实现可以看这个<a href="http://chenzhijun.top/2018/03/09/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a>。</p>
<p>希尔排序的思想是使间隔为h之间的元素都是有序的。<br>比如我们说有10个数字，首先我们使用间隔4，那么就是位置为 <code>1，5</code>,<code>2，6</code>,<code>3，7,</code>4，8<code>,</code>5，9<code>；将这些组的相应**位置的值**，我们说的1-9是指的位置，而不是值哦。将这些组进行排序。之后我们再进行第二次分组，也就是将间隔的长度再缩小，假如这里缩小为2，那么第二次的间隔位置组就是：</code>1，3，5，7，9<code>,</code>2，4，6，8`。这样循环比较进行交换之后，我们最终就可以将间隔降为1，这样我们就可以得到一个优化的优化后的插入排序了，也就是常说的希尔排序；</p>
<p>一般来说我们通常将长度设为2的幂除。也就是先用数组长度除2，再除2，再除2；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">void</span> <span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h=arr.length/<span class="number">2</span>;h&gt;<span class="number">0</span>;h=h/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;arr.length&amp;&amp;arr[j]&lt;arr[j-h];j-=h)&#123;</span><br><span class="line">                swap(arr,j,j-h)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在&lt;&lt;算法&gt;&gt;第四版中看到另一种实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;arr.length/<span class="number">3</span>)&#123;</span><br><span class="line">        h=h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len&amp;&amp;a[j]&lt;a[j-h];j-=h)&#123;</span><br><span class="line">                swap(arr,j,j-h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h=h/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> j,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    arr[j] = arr[j]+arr[i];</span><br><span class="line">    arr[i] = arr[j]-arr[i];</span><br><span class="line">    arr[j] = arr[j]-arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>极光推送线下交流分享会</title>
    <url>/2018/03/17/shenzhen-xianxia-fenxianghui/</url>
    <content><![CDATA[<h1 id="极光推送线下交流分享会"><a href="#极光推送线下交流分享会" class="headerlink" title="极光推送线下交流分享会"></a>极光推送线下交流分享会</h1><p>周六参加了异常极光推送组织的线下架构师分享会。当然我只是去学习的。</p>
<span id="more"></span>

<p>首先是极光推送的架构师分享极光面对的问题以及架构进化历史。他们呢的架构我就听懂了一个从vm迁移到k8s,docker。另外他们是用c++开发的，采用的是并行处理。实话C++忘记的差不多了。然后他们对于特殊vip客户做了特殊处理。我特别感兴趣一个问题，他说他们有上亿的激活用户，那么怎么给每个用户分标签了？我们在使用机关推送的时候其实是有按男女，按地区，按年龄等来分别推送的。那他们怎么做到在亿级别的用户数上做到很快的处理？他说的方案是<strong>请求并行处理</strong>；一个请求可以拆分成多个请求，然后结果统一汇总。这个怎么感觉是多线程并发么？</p>
<p>另外还听到了一个服务化层的概念。比如mq，他说他们所有的请求都是走mq异步的。但是现在并发量大的情况下，mq已经抗不住了。这个时候他们提出mq服务化。就是说mq可能有kafka，rabbitmq，rocketmq。他们可能是在这些mq的上层包装一层，然后底下用这些mq的集群，而对外就是一个mq服务接口层，使用者完全感觉不出来，还是跟以前一样，而这个服务层有路由策略和处理。另外他们的mq是单实例，也就是非集群方式8c16G。</p>
<p>第二位分享的是平安云的架构师，主要讲的是k8s。已经他们的云平台服务搭建，已经在内部的使用。项目先要考虑活下来，才会考虑去优化。这是他分享的一句话。另外会下我还问了一下他关于日志的问题。日志丢包怎么解决，他的回答是切分，然后采用一些策略来做。防止掉大部分。小部分丢包可以自己再采用策略补偿。</p>
<p>第三位分享的是阿里豌豆荚的架构师，很明显，这是一个阿里互联网的气息的人。我第一次听到下级给上级打绩效。这个不得不佩服，他也说了136淘宝的策略，如果两年1，必须淘汰，每年必须有人1。厉害了。然后他分享给我们的是抓好数据结构。熟悉一门新的语言先去看它的api文档，但是如果你熟悉数据结构，你会发现api文档里面其实通用的，因为每个语言用的数据结构还是那些只是实现方式有点不一样罢了。他还分享了一个架构模式进程：mvc-&gt;mvp-&gt;mvvm。性能优化方法面他说先要有个量化下来，他主要是安卓开发推荐我们内存优化的工具是memory，monitor，heap view,aliocation Tracker，MAT。<br>内存泄漏：应用不停的申请新内存；<br>内存溢出：需要一个大内存，实际只有一个小内存;<br>在安卓中使用轻量级的数据结构，不用hashmap的原因是自动装箱，自动拆箱。<br>技术的进化历史：<br>服务业务—&gt; 解决需求<br>反哺业务—&gt; 留存<br>提升业务</p>
<p>作为技术人需要的不但专，而且要博。专而博。</p>
<p>最后的提问环节，不得不说，阿里的影响力那是真的大啊，一堆人提问，一堆人加微信。厉害了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 应用可视化监控</title>
    <url>/2017/11/02/spring-boot-actuator-prometheus-grafana/</url>
    <content><![CDATA[<h1 id="Spring-Boot-应用可视化监控"><a href="#Spring-Boot-应用可视化监控" class="headerlink" title="Spring Boot 应用可视化监控"></a>Spring Boot 应用可视化监控</h1><blockquote>
<p>使用spring-actuator 并且使用prometheus, grafana 做可视化视图展示</p>
</blockquote>
<p>总体过程图：</p>
<p><img src="/images/qiniu/2017-11-02-17-21-51.png" alt="2017-11-02-17-21-51"></p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h3 id="SpringBoot-应用监控"><a href="#SpringBoot-应用监控" class="headerlink" title="SpringBoot 应用监控"></a>SpringBoot 应用监控</h3><p>SpringBoot 其实也整合了 ops 的功能，也就是运维的部分能力。通过引入包<code>spring-boot-starter-actuator</code>来监控相关的指标信息,详情文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready">Actuator 介绍</a>。另外在新版本的<code>actuator</code>中已经有了加密信息，所以对于一些信息的获取可能需要授权，因此我们还需要引入<code>spring-security</code>,pom 文件如下：</p>
<span id="more"></span>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然既然引入了<code>spring-security</code>,我们就需要对其做一些配置，我的完整配置是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 应用的api端口</span><br><span class="line">server.port&#x3D;8818</span><br><span class="line"># 启用基础认证</span><br><span class="line">security.basic.enabled &#x3D; true</span><br><span class="line"></span><br><span class="line"># 安全路径列表，逗号分隔，此处只针对&#x2F;admin路径进行认证</span><br><span class="line">security.basic.path &#x3D; &#x2F;admin</span><br><span class="line"></span><br><span class="line"># 认证使用的用户名</span><br><span class="line">security.user.name &#x3D; admin</span><br><span class="line"></span><br><span class="line"># 认证使用的密码。 默认情况下，启动时会记录随机密码。</span><br><span class="line">security.user.password &#x3D; 123456</span><br><span class="line"></span><br><span class="line"># 可以访问管理端点的用户角色列表，逗号分隔</span><br><span class="line">management.security.roles &#x3D; SUPERUSER</span><br><span class="line"></span><br><span class="line"># actuator暴露接口使用的端口，为了和api接口使用的端口进行分离</span><br><span class="line">management.port &#x3D; 8099</span><br><span class="line"></span><br><span class="line"># actuator暴露接口的前缀</span><br><span class="line">management.context-path &#x3D; &#x2F;admin</span><br><span class="line"></span><br><span class="line"># actuator是否需要安全保证</span><br><span class="line">management.security.enabled &#x3D; true</span><br><span class="line"></span><br><span class="line"># actuator的metrics接口是否需要安全保证</span><br><span class="line">endpoints.metrics.sensitive &#x3D; false</span><br><span class="line"></span><br><span class="line"># actuator的metrics接口是否开启</span><br><span class="line">endpoints.metrics.enabled&#x3D;true</span><br><span class="line"></span><br><span class="line"># actuator的health接口是否需要安全保证</span><br><span class="line">endpoints.health.sensitive&#x3D;false</span><br><span class="line"></span><br><span class="line"># actuator的health接口是否开启</span><br><span class="line">endpoints.health.enabled&#x3D;true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指标采集"><a href="#指标采集" class="headerlink" title="指标采集"></a>指标采集</h3><p>采集应用的指标信息，我们使用的是<code>prometheus</code>,相应的我们引入包:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_spring_boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后在程序中开启相应的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnablePrometheusEndpoint</span></span><br><span class="line"><span class="meta">@EnableSpringBootMetricsCollector</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们可以开始启动我们的应用程序，并且访问相关接口:<a href="http://localhost:8099/admin/prometheus">http://localhost:8099/admin/prometheus</a></p>
<p>输入 properties 文件中的账号密码，就能看到下图：<br><img src="/images/qiniu/2017-11-02-16-26-20.png" alt="2017-11-02-16-26-20"></p>
<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>我们采集了指标信息之后就可以开始数据收集了，这个时候我们需要用到<code>Prometheus</code>工具，注意这里是工具，不再是 jar 包了。我使用的是 prometheus 的 docker 镜像，当然你也可以根据需要自己选择,先准备一份 Promethus 的配置文件,更多的配置文档请查看：<a href="https://prometheus.io/docs/operating/configuration/">配置文档</a>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">10m</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">spring-boot</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">scrape_timeout:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">/admin/prometheus</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">basic_auth:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.11</span><span class="number">.54</span><span class="string">:8099</span></span><br></pre></td></tr></table></figure>

<p>之后我们准备服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name prometheus -p 9090:9090 -v D:\chenzhijun\test\actuator\prometheus\prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请注意，<code>D:\chenzhijun\test\actuator\prometheus\prometheus.yml</code> ，是我的配置文件存放地址，我们需要将它放到容器里面去，所以用了<code>-v</code>来做文件映射。<code>/etc/prometheus/prometheus.yml</code>这个是容器启动的时候去取的默认配置，这里我是直接覆盖掉了它。<code>prom/prometheus</code>这是镜像，如果本地没有，就回去你设置好的镜像仓库去取。</p>
<p>启动完成后用<code>docker ps</code>看下是否已经启动成功，之后打开浏览器输入：<br><code>http://localhost:9090/targets</code>,如果看到下图就是成功了：<br><img src="/images/qiniu/2017-11-02-16-40-26.png" alt="2017-11-02-16-40-26"></p>
<blockquote>
<p>ps: 这里需要注意一点，我们在<code>prometheums.yml</code>中使用的IP地址一定要准确，因为我是docker访问的，所以我使用的是宿主机的地址</p>
</blockquote>
<h2 id="数据可视化展示"><a href="#数据可视化展示" class="headerlink" title="数据可视化展示"></a>数据可视化展示</h2><p>同样的我也是使用 docker ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name grafana -d -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure>

<p>成功之后访问：<a href="http://localhost:3000/">http:localhost:3000</a>，输入账号密码：<code>admin/admin</code>。<br>之后就开始配置 grafna。</p>
<ol>
<li><p>先配置数据源,这里稍微注意下 ip 地址<br><img src="/images/qiniu/2017-11-02-16-49-26.png" alt="2017-11-02-16-49-26"></p>
</li>
<li><p>新建 dashboard<br><img src="/images/qiniu/2017-11-02-16-51-04.png" alt="2017-11-02-16-51-04"></p>
</li>
<li><p>配置图形数据<br><img src="/images/qiniu/2017-11-02-16-51-28.png" alt="2017-11-02-16-51-28"></p>
</li>
<li><p>选择指标,这里的指标数据只能是<code>promethues</code>采集到了的数据<a href="http://localhost:9090/graph">http://localhost:9090/graph</a>:</p>
</li>
</ol>
<p><img src="/images/qiniu/2017-11-02-16-52-58.png" alt="2017-11-02-16-52-58"></p>
<p>4.1. <code>prometh</code>采集的数据<a href="http://localhost:9090/graph">http://localhost:9090/graph</a></p>
<p><img src="/images/qiniu/2017-11-02-16-54-12.png" alt="2017-11-02-16-54-12"></p>
<ol start="5">
<li>最终结果</li>
</ol>
<p><img src="/images/qiniu/2017-11-02-17-03-01.png" alt="2017-11-02-17-03-01"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://gitee.com/chenzhijun/actuator">actuator 源码</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.jianshu.com/p/ebee9a0dc15c">SpringBoot 应用监控踩坑集锦</a></p>
<p><a href="http://www.jianshu.com/p/7ecb57a3f326">Spring Boot 应用可视化监控</a></p>
<p><a href="https://prometheus.io/docs/introduction/getting_started/">prometheus_started</a></p>
<p><a href="http://docs.grafana.org/installation/docker/">Grafana</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring周报翻译 - 2017年10月3日周报</title>
    <url>/2017/10/09/spring-io-weekly-newspaper/</url>
    <content><![CDATA[<h2 id="10月3号周报"><a href="#10月3号周报" class="headerlink" title="10月3号周报"></a>10月3号周报</h2><blockquote>
<p>今日突然兴起，想翻译文章，其实之前的我在LinuxCN上也翻译过，只是那边大多是Linux的文章，其实我想翻译Java周边的。那边的文章我也有翻译过，只是总觉得缺少什么，后来接触了Spring4ALL,也就随口问了下，没想到还竟然有人回复了我,所以也就有了下面这篇文章，算作投名状吧。</p>
</blockquote>
<p>其实，能翻译我还是很高兴的，因为我觉得那26个字母非常可爱。^_^</p>
<p>下面是是10月3号在Spring官网看到的周报内容，取出主要内容作为本文主体：</p>
<ol>
<li><p> 怎么<a href="https://spring.io/blog/2017/09/27/spring-tips-reactive-websockets-with-spring-framework-5">使用Spring Framwork5来构建基于websocket的响应式应用</a></p>
</li>
<li><p> Spring AMQP和Spring Integration开发领导者Gary Russell发布了<a href="https://spring.io/blog/2017/09/27/spring-amqp-2-0-release-candidate-2-available">Spring AMQP 2.0.RC2</a>。</p>
</li>
<li><p> 经过一段长的时间，<code>Spring Framework 5.0.GA</code>现在终于发布了！新版本集成了Reactor项目，包括响应式web运行时环境，Kotlin扩展，以及全面基于Java EE 7和Java 8。<br>新的发行版具有太多的新东西,如果想要知道更多的消息，查看<a href="https://spring.io/blog/2017/09/28/spring-framework-5-0-goes-ga">版本说明</a>，然后查看<a href="https://github.com/spring-projects/spring-framework/wiki/What's-New-in-the-Spring-Framework#whats-new-in-spring-framework-5x">更新内容</a></p>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>Spring Reactor团队成员Simon Baslé宣布发布Spring和Reactor集成的新版本<a href="https://spring.io/blog/2017/09/28/reactor-bismuth-is-out">Reactor Bismuth</a>。这个版本为Spring Framework 5.0奠定了基础，它自己本身也包含了非常多的功能！</p>
</li>
<li><p> Spring Framework 5.0版本更新了一些其他的项目，其中包括发布了<a href="https://spring.io/blog/2017/10/02/spring-data-release-train-kay-goes-ga">Spring Data Kay</a>。自从Spring Data于2009年成立以来，这是Spring Data更新的最大版本！该新版本以Spring Framework 5.0，Java 8和Java EE 7作为基准。它包括一个改进的仓储(repository) API（完整支持<code>Optional&lt;T&gt;</code>），支持响应式数据访问（Cassandra，Couchbase，MongoDB和Redis），新发布版本新增Spring Data Geode，使用非空注解并且优化了运行时检查空注解，通过Kotlin构造方法，支持Kotlin的null安全和不可变数据类，支持兼容Java 9和然后还有更多的请看文档：<a href="https://spring.io/blog/2017/10/02/spring-data-release-train-kay-goes-ga">Spring Data Kay</a>！</p>
</li>
<li><p> Spring消息中间件集成团队成员Artem Bilan宣布发布<a href="https://spring.io/blog/2017/10/02/spring-for-apache-kafka-2-0-ga-available">Spring for Apache Kafka 2.0.GA</a>.新版本包括支持<code>Apache Kafka</code>，支持事务，消息头匹配，Apache Kafka 的<code>Streams</code>支持，新的<code>KafkaAdmin</code>，增加<code>@KafkaListener</code>和<code>Consumer</code>错误处理和群组支持的方案。它还支持使用<code>@EmbeddedKafka</code>进行测试。</p>
</li>
<li><p> Spring Cloud团队成员Ryan Baxter宣布发布<a href="https://spring.io/blog/2017/10/03/spring-cloud-dalston-sr4-is-now-available">Spring Cloud Dalston SR4</a>。新版本更新了<code>Spring Cloud Contract</code>，<code>Spring Cloud Config</code>，<code>Spring Cloud Commons</code>，<code>Spring Cloud Netflix</code>和<code>Spring Cloud Sleuth</code>。</p>
</li>
<li><p> Spring REST Docs 开发领导者Andy Wilkinson宣布发布<a href="https://spring.io/blog/2017/09/28/spring-rest-docs-1-2-2-release">Spring REST Docs 1.2.2.RELEASE</a>。这个维护版本包括一些错误修复和文档的改进，推荐大家升级</p>
</li>
<li><p> 查看Spring Framework 5的全新的<a href="https://github.com/spring-projects/spring-framework/commit/23497a7ece7aac1591187b46f4b601d2f48764e0">通过构造方法实现注解的实现</a></p>
</li>
<li><p> 德语访谈中Andreas Falk提到的Spring Framework 5.0和Spring Security 5.0中的<a href="https://jaxenter.de/spring-security-interview-falk-62685">新功能</a>。</p>
</li>
<li><p> 由Zoltan Altfatter发表的这篇文章介绍了<a href="http://blog.mimacom.com/blog/2017/09/29/trigger-a-spring-batch-job-with-a-jms-message/">如何在Spring Integration流程中引入一个新的JMS消息来启动Spring Batch作业</a>。</p>
</li>
<li><p> Rohit Kelapure: <a href="https://twitter.com/rkela/status/914924780373073920">为什么Pivotal公司的Cloud Foundry是运行Spring Boot应用程序的最佳选择</a></p>
</li>
<li><p> 在这篇文章中，Cristina Negrean介绍了<a href="https://cristinanegrean.github.io/2017/10/01/spring-cloud-dataflow-for-real-time-analytics-with-twitter-api">如何使用Spring Cloud Data Flow进行实时分析</a>。</p>
</li>
<li><p> Gabriela Motroc<a href="https://jaxenter.com/spring-framework-5-0-137677.html">在JAXEnter网上发布了一篇关于Spring Framework 5的新文章</a>。非常多的功能文章都包含了</p>
</li>
<li><p> Aboullaite Mohammed：<a href="https://aboullaite.me/spring-boot-elastic-kibana/">使用Elasticsearch和Kibana和Spring Boot集合来监控一些指标</a></p>
</li>
<li><p> Ordina JWorks：<a href="https://ordina-jworks.github.io/microservices/2017/09/26/Secure-your-architecture-part1.html">使用Spring Cloud来对微服务进行安全防护</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring周报翻译</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud 集成 Consul</title>
    <url>/2019/05/31/springcloud-consul-integration/</url>
    <content><![CDATA[<h1 id="SpringCloud-集成-Consul"><a href="#SpringCloud-集成-Consul" class="headerlink" title="SpringCloud 集成 Consul"></a>SpringCloud 集成 Consul</h1><p>SpringBoot ，SpringCloud 可以说是在 Spring 里面最流行的，确实它的上手要比以前开发真的方便很多，约定优于配置。</p>
<p>springcloud可以理解成基于springboot的各种解决方案。</p>
<h2 id="集成consul"><a href="#集成consul" class="headerlink" title="集成consul"></a>集成consul</h2><p>我们没有使用eureka作为注册中心，而是使用consul，为什么了？因为eureka停止更新了。嗯，是的，如果没有人继续维护了，那我就觉得使用起来就会有局限性，这个不是在前期，而是在后期。而且官方都不更新维护了，以后我发现bug，都没有提PR的地方了~~~~嘿嘿。其实个人觉得注册中心以后可能会下沉，比如现在的k8s，就已经在底层平台解决了服务发现与注册的问题。当然那是扯远了，我们暂时还是先用consul做我们的注册中心，毕竟一套k8s也并不是那么好玩的。</p>
<p>在官网下载consul的安装包，然后使用<code>consul agent -dev</code>我们就可以在通过<code>http://IP:8500</code>端口来访问了。</p>
<span id="more"></span>
<h2 id="Springcloud-集成consul"><a href="#Springcloud-集成consul" class="headerlink" title="Springcloud 集成consul"></a>Springcloud 集成consul</h2><h3 id="服务提供方"><a href="#服务提供方" class="headerlink" title="服务提供方"></a>服务提供方</h3><p>我们的代码结构如下：</p>
<p><img src="/images/qiniu/2019-05-31-21-09-48.png" alt="2019-05-31-21-09-48"></p>
<p>我们使用springcloud提供的<code>spring-cloud-starter-consul-discovery</code>,这是集成了consul的starter，完整的<code>pom.xml</code>如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>me.chenzhijun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-consul-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-consul-server<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>consul project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后看下我们的<code>application.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org.springframework.cloud.consul:</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">management:</span> <span class="comment"># 需要一个health端口来让consul回调</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">/admin</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">servlet:</span></span><br><span class="line">      <span class="attr">context-path:</span> <span class="string">/admin</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">18080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-app</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># consul 地址</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">instance-id:</span> <span class="string">user-app</span> <span class="comment"># 注册到consul的名字</span></span><br><span class="line">        <span class="attr">management-port:</span> <span class="number">18080</span> <span class="comment"># consul会来访问这个端口+health-check-path 来判断应用是否正常</span></span><br><span class="line">        <span class="attr">health-check-path:</span> <span class="string">$&#123;management.server.servlet.context-path&#125;$&#123;management.endpoints.web.base-path&#125;/health</span></span><br></pre></td></tr></table></figure>

<p>在服务提供方我们的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.consul;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们这里需要使用<code>@EnableDiscoveryClient</code> 这样就能让项目注册到consul了。</p>
<h3 id="服务调用方"><a href="#服务调用方" class="headerlink" title="服务调用方"></a>服务调用方</h3><p>既然是注册中心，我们有了服务提供方，当然需要服务调用方啦。调用方的结构如下：</p>
<p><img src="/images/qiniu/2019-05-31-21-31-41.png" alt="2019-05-31-21-31-41"></p>
<p>pom文件的内容类似<code>pom.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>me.chenzhijun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-consul-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-consul-client<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>application.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">instance-id:</span> <span class="string">user-client</span></span><br><span class="line">        <span class="attr">health-check-path:</span> <span class="string">$&#123;management.endpoints.web.base-path&#125;/health</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">    <span class="attr">level:</span></span><br><span class="line">      <span class="attr">org.springframework.cloud.consul:</span> <span class="string">DEBUG</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">18088</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">/admin</span></span><br></pre></td></tr></table></figure>

<p>我们再看<code>Application.java</code>的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.calltest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalltestApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CalltestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//restTemplate 必须使用@LoadBalanced创建</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/abc&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">&quot;user-app&quot;</span>);</span><br><span class="line"><span class="comment">//        if (list != null &amp;&amp; !list.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//            String serviceId = list.get(0).getServiceId();</span></span><br><span class="line"><span class="comment">//            URI uri = list.get(0).getUri();</span></span><br><span class="line"><span class="comment">//            System.out.println(uri.toString());</span></span><br><span class="line"><span class="comment">//            String url = &quot;http://&quot; + list.get(0).getHost() + &quot;:&quot; + list.get(0).getPort() + &quot;/hello&quot;;</span></span><br><span class="line"><span class="comment">//            RestTemplate restTemplate = new RestTemplate();</span></span><br><span class="line"><span class="comment">//            String result = restTemplate.getForEntity(url, String.class).getBody();</span></span><br><span class="line"><span class="comment">//            ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity(url, String.class);</span></span><br><span class="line"><span class="comment">//            System.out.println(forEntity.getBody());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里我们使用的是服务名user-app直接调用，注意这里的resttemplate一定要用@Bean @LoadBalanced 不然会报错</span></span><br><span class="line">        ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity(<span class="string">&quot;http://user-app/hello&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> forEntity.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在浏览器里面访问<code>http://localhost:8088/abc</code>就能看到返回<code>Hello World123</code>了。</p>
<p>ps:<br>1：为什么RestTemplate必须要使用@LoadBalanced ?<br>2：springboot actuator starter 能否去掉，去掉的话应该怎么实现？<br>3：你觉得独立的注册中心未来的路会是怎样？</p>
<p>今天5月31日，改日回答，<a href="http://chenzhijun.top/2019/05/31/springcloud-consul-integration/">记住来看答案</a>。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title>从 SVN 迁移到 Git （二）</title>
    <url>/2018/04/02/svn-to-git/</url>
    <content><![CDATA[<p>从 SVN 导入到 GitLab 仓库中我们只需要下载一个 <code>git-svn</code> 的工具，如果是windows版本的git工具，应该是内置了的；Linux 下使用<code>yum install git-svn</code>。一些操作可以参考git官网的两篇文章：<a href="https://git-scm.com/book/zh/v1/Git-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F-Git-%E4%B8%8E-Subversion">Git-与其他系统-Git-与-Subversion</a>和<a href="https://git-scm.com/book/zh/v1/Git-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F-%E8%BF%81%E7%A7%BB%E5%88%B0-Git">Git-与其他系统-迁移到-Git</a>。</p>
<p>从实际的svn迁移到git中有两种方式:</p>
<h2 id="1-最简单最直接的方式，从svn拷下代码，然后上传到gitlab仓库中。"><a href="#1-最简单最直接的方式，从svn拷下代码，然后上传到gitlab仓库中。" class="headerlink" title="1) 最简单最直接的方式，从svn拷下代码，然后上传到gitlab仓库中。"></a>1) 最简单最直接的方式，从svn拷下代码，然后上传到gitlab仓库中。</h2><p>先将svn上的代码拷下来，<code>git svn clone https://192.168.1.12/svn/trade/App_cn/Src/_CJ208_Noe</code>。</p>
<p><img src="/images/qiniu/2018-04-02-11-23-02.png" alt="2018-04-02-11-23-02"></p>
<p>然后使用git将其推送到gitlab仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin http://gitlab.xxx.com/xxxgroup/_CJ208_Noe.git</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>推送过程记得使用<code>root</code>管理：</p>
<p><img src="/images/qiniu/2018-04-02-11-28-59.png" alt="2018-04-02-11-28-59"></p>
<p>可以在项目提交历史看到相应的提交记录。<br><img src="/images/qiniu/2018-04-02-11-29-41.png" alt="2018-04-02-11-29-41"></p>
<p>这种方式提交的话，可以看到提交人的信息跟gilab是没有绑定的，这样可能就不太方便我们去查找某人，尤其是svn账号不规范的情况。</p>
<p><img src="/images/qiniu/2018-04-02-11-30-49.png" alt="2018-04-02-11-30-49"></p>
<p>上图就是使用<code>czj</code>这种缩写，有些svn账号又是全名。有可能是因为历史原因，不过如果想直接从svn导入到git，这种方式是最方便的。当然可能在历史的提交记录里面有一些杂的信息。比如：<code>git-svn-id:XXXX</code>这些，进入到项目里面使用<code>git log</code>可以看到<code>commit</code>信息：</p>
<p><img src="/images/qiniu/2018-04-02-11-48-08.png" alt="2018-04-02-11-48-08"></p>
<h2 id="2-将用户名和账号对应起来，然后再上传代码。不过在上传之前我们先过滤一下："><a href="#2-将用户名和账号对应起来，然后再上传代码。不过在上传之前我们先过滤一下：" class="headerlink" title="2) 将用户名和账号对应起来，然后再上传代码。不过在上传之前我们先过滤一下："></a>2) 将用户名和账号对应起来，然后再上传代码。不过在上传之前我们先过滤一下：</h2><p>a) 先将用户名称过程，可以使用下面两个方式将svn提交的用户名存放到文本文件中：</p>
<p>直接使用svn地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svn log https://192.168.7.2/svn/trade/App_cncsen/Src/CJ325_Integral --xml | grep -P &quot;^&lt;author&quot; | sort -u | \</span><br><span class="line">      perl -pe &#x27;s/&lt;author&gt;(.*?)&lt;\/author&gt;/$1 = /&#x27; &gt; users.txt</span><br></pre></td></tr></table></figure>

<p>将代码从svn拷下来之后，进入到代码根目录里面使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svn log ^/ --xml | grep -P &quot;^&lt;author&quot; | sort -u | \</span><br><span class="line">      perl -pe &#x27;s/&lt;author&gt;(.*?)&lt;\/author&gt;/$1 = /&#x27; &gt; users.txt</span><br></pre></td></tr></table></figure>

<p>在<code>users.txt</code>中我们可以看到提交人的账号信息：</p>
<p><img src="/images/qiniu/2018-04-02-11-40-24.png" alt="2018-04-02-11-40-24"></p>
<p>之后我们将其匹配到gitlab中的用户名：</p>
<p><img src="/images/qiniu/2018-04-02-11-43-03.png" alt="2018-04-02-11-43-03"></p>
<p>然后使用 <code>git svn clone</code> 将代码拷下来，不过这次拷贝我们加入用户的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git svn clone https:&#x2F;&#x2F;192.168.7.246&#x2F;svn&#x2F;trade&#x2F;App_cncsen&#x2F;Src&#x2F;CJ325_Integral  --authors-file&#x3D;users.txt --no-metadata</span><br></pre></td></tr></table></figure>

<p>之后再进行一些过滤:</p>
<p>过滤svn中tag分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git for-each-ref refs&#x2F;remotes&#x2F;tags | cut -d &#x2F; -f 4- | grep -v @ | while read tagname; do git tag &quot;$tagname&quot; &quot;tags&#x2F;$tagname&quot;; git branch -r -d &quot;tags&#x2F;$tagname&quot;; done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后将 <code>refs/remotes</code> 下面剩下的索引变成本地分支:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git for-each-ref refs&#x2F;remotes | cut -d &#x2F; -f 3- | grep -v @ | while read branchname; do git branch &quot;$branchname&quot; &quot;refs&#x2F;remotes&#x2F;$branchname&quot;; git branch -r -d &quot;$branchname&quot;; done</span><br></pre></td></tr></table></figure>

<p><img src="/images/qiniu/2018-04-02-11-50-02.png" alt="2018-04-02-11-50-02"></p>
<p>这样过滤之后现在再发布到远端，下图可以看到，现在的历史中干净很多，而且名字也对应上了。</p>
<p><img src="/images/qiniu/2018-04-02-11-53-25.png" alt="2018-04-02-11-53-25"></p>
<p>现在就可以开心的使用git了。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>PaaS 平台应当具备的能力</title>
    <url>/2023/01/16/the-ability-of-a-paas-platform/</url>
    <content><![CDATA[<h1 id="PaaS-平台应当具备的能力"><a href="#PaaS-平台应当具备的能力" class="headerlink" title="PaaS 平台应当具备的能力"></a>PaaS 平台应当具备的能力</h1><p>一个完善的paas平台应该具备的能力:</p>
<p><img src="/images/qiniu/2019-07-06-13-31-12.png" alt="2019-07-06-13-31-12"></p>
<p>代码管理中有gitlab，github，gitee. etc…</p>
<p>配置管理中：开发，测试，生产一致性。</p>
<span id="more"></span>

<p>准备一个个的环节点慢慢来写…</p>
]]></content>
      <categories>
        <category>Paas</category>
      </categories>
      <tags>
        <tag>PaaS</tag>
      </tags>
  </entry>
  <entry>
    <title>重温Java编程思想的一些感悟-20180223</title>
    <url>/2018/02/23/thinkinjava-20180223/</url>
    <content><![CDATA[<h1 id="重温Java编程思想的一些感悟-20180223"><a href="#重温Java编程思想的一些感悟-20180223" class="headerlink" title="重温Java编程思想的一些感悟-20180223"></a>重温Java编程思想的一些感悟-20180223</h1><p>最近又重新翻开了这本书，翻开第一页，上面的第一句话让我有点感触。</p>
<p><code>2013年11月25日，购于亚马逊-陈志军</code></p>
<p>过得真快啊，今天是18年2月23日。岁月绕过谁？莫名的想起一句话：优于别人，并不高贵，真正的高贵应该是优于过去的自己。<br>今天的我，是否又优于过去的我了？</p>
<p>翻了一下书的目录，上面还有以前写的，哪天哪天要读那几章节。哈，我其实已经忘记我读过的这本书的内容了。</p>
<p>翻了下第一二三章，对象导论，一切都是对象，操作符。</p>
<p>使用java开发，我们通常会说一句话，万事皆对象。什么是对象？对象的好处？继承和组合的区别与联系？java的单继承结构-Object为终结父类。对象的创建和生命期。我们通常说创建一个对象在堆上，然后都是new出来的，那么基本类型的变量的空间又该如何算？也是在堆上么？</p>
<span id="more"></span>

<p>对象的存储：寄存器（无法直接控制），堆栈（RAM），堆（RAM），常量存储，非RAM存储（流对象，持久化对象）。<br>常量存储是将值直接存储在程序代码内部，常量的意思就是表明它是永远不会被改变的。那么基本类型是怎么存放的了？书上说，new的对象存储在堆里，但用new来创建一个小的简单的变量通常不是很搞笑，所以基本类型是特例，基本类型不用new来创建变量，而是创建一个并非是引用的“自动”变量，存储在堆栈中，并且也会将“值”也存在堆栈中。更加具体的解释可以看这篇问答：<a href="http://www.iteye.com/problems/75716%E3%80%82%E5%A0%86%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%85%88%E5%88%86%E9%85%8D%E7%9A%84%E5%86%85%E5%AD%98%E6%9C%80%E5%90%8E%E9%87%8A%E6%94%BE%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A0%86%E6%A0%88%E4%B8%AD%EF%BC%8C%E6%89%80%E4%BB%A5%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%B0%B1%E6%B2%A1%E6%9C%89%E4%BA%86%E3%80%82">http://www.iteye.com/problems/75716。堆栈的作用是一个先进后出的结构也就是先分配的内存最后释放，局部变量是存放在堆栈中，所以函数返回之后，局部变量就没有了。</a></p>
<p>基本类型：boolean，byte(8bit),char(16bit),short(16bit),int(32bit),long(64bit),float(32bit),double(64bit),void</p>
<p>可以确定这些基本类型所占的存储空间的大小是不变的。但是boolean占多少位了？<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</a> 网上一堆的争论，官网的解释是这个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean: The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true&#x2F;false conditions. This data type represents one bit of information, but its &quot;size&quot; isn&#39;t something that&#39;s precisely defined.</span><br></pre></td></tr></table></figure>

<p>boolean 只有两个值：true和false。使用它作为真/假表达式的标记，它的数据类型表示的是一个bit的信息，但实际大小确不是精确定义的。</p>
<p>基本类型是有默认值的，但仅仅只限于作为类的成员变量时，java才会给默认值，如果是在一个方法中，如果你直接像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    System.out.println(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果像上面这样，i不初始化，就会报编译错误。</p>
<p>static关键字：我们知道，对象的创建需要在执行new之后，才会给对相对分配数据存储空间。但如果我只想给类的某个域或者方法单一分配存储空间或者希望某个方法就算没有创建对象，也能够被调用。这种想法就是，我不想使用new去创建对象(可能对象太大占用太多空)，但是勒，我又需要这个对象里面的某个域或者某个方法。这种时候就可以使用static关键字了。static的意思就是用它来修饰的域或者方法，不与包含它的那个类的任何实例对象关联在一起。所以就算没有创建某个类的任何对象，也可以调用static方法，或者static域。而非static域和方法，必须知道他们一起运作的特定对象。static字段对于每个类来说都只有一份，也就是无论你是创建多个也好，还是只有一个也好，它们用到的那个static域是公有的，都是同一个存储空间。</p>
<p>操作符<br>在java最底层，数据是通过操作符来操作的。<br>java的操作符有：四则运算(算术操作符)，赋值，关系操作符（&lt;,&gt;,&lt;=,==,!=），逻辑操作符号（&amp;&amp;，||，！），自增自减，按位操作（&amp;，|，^,~），移位操作符（&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;（无符号右移）,&lt;&lt;&lt;（无符号左移））。</p>
<p><strong>逻辑操作符号只用于布尔值</strong></p>
<p><strong>按位操作符～，是一元操作符，也就是只需要一个操作数就可以了。所以不能用 ～=</strong></p>
<p>类型转换：高位转地位会失真，所以需要显示强转；地位转高位没事不必显示强转。基本类型中，如果是数据类型小和数据类型大的做运算，结果总是数据类型大的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重温Java编程思想的一些感悟-20180305</title>
    <url>/2018/03/05/thinkinjava-20180305/</url>
    <content><![CDATA[<h1 id="重温Java编程思想的一些感悟-20180305"><a href="#重温Java编程思想的一些感悟-20180305" class="headerlink" title="重温Java编程思想的一些感悟-20180305"></a>重温Java编程思想的一些感悟-20180305</h1><p>JIT(just-in-time) 即时编译技术：将程序全部或者部分翻译成本地机器码，程序运行速度因此得到提升。<br>对于hotspot来说，代码每次被执行，都会做一些优化，执行的次数越多，速度也就越快。</p>
<p>java会给所有的默认域做一个初始化，非基本类型对象不初始化值的情况下，默认为null。<br>初始化顺序:static-&gt;{}-&gt;构造器；</p>
<p>static的数据指向同一份存储区域，不能用于局部变量。</p>
<p>final对于基本类型，其数值永不改变。final对于引用类型，其引用永不改变。<br>必须在定义final或者在构造器中对final进行赋值。</p>
<p>final类无法继承，方法无法重写或修改。private的方法其实是隐式的final。</p>
<p>compareTo,如果是两个int，最好不要直接返回i-i2，如果是有符号的int类型，一个正数最大，一个负数最大，那么将永远返回负数。所以如果重写compareTo，最好是不要直接返回return i-i2;</p>
<p>集合是fail-fast的，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(aa);</span><br><span class="line">list.iterator();</span><br><span class="line">list.add(cc);</span><br></pre></td></tr></table></figure>

<p>需要明确在添加或者修改完容器所有元素之后再获取迭代器。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>重温Java编程思想的一些感悟-20180310</title>
    <url>/2018/03/10/thinkinjava-20180310/</url>
    <content><![CDATA[<h1 id="重温Java编程思想的一些感悟-20180310"><a href="#重温Java编程思想的一些感悟-20180310" class="headerlink" title="重温Java编程思想的一些感悟-20180310"></a>重温Java编程思想的一些感悟-20180310</h1><blockquote>
<p>人的懒惰，是思想上的懒惰</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天说个有趣的事情，起床的时间是9点。周末9点起床其实也不算过分，但是吧。拖着拖着在床上又赖到了10点。然后找不到理由再拖下去了。321起床，洗脸刷牙。然后脑袋在思考了：现在要是去大学城吧，10点了。这过去就得半小时吧，然后吃午饭吧，花半小时吧，然后去图书馆路上走个20分钟吧，嗯，好像差不多就12点了。这样下去吧，晚上6点又要吃饭。等会中午说不定还要睡觉。那还去图书馆干嘛。在家里也一样的啊，反正一张大桌子，一个人，很安静。那我先去吃个肠粉当早午饭，吃完回来看书。嗯，出门记得把垃圾扔出去。嗯是的。故事就是这样开始的。当我拿着垃圾扔到楼下垃圾桶。看着太阳这么明媚，天气这么暖和，不知咋地，我竟然生出一种感觉，回家拿书包，去图书馆，而且一分钟也没有思考其它的。直接就又返回来。拿着书包，就出去了。吃完肠粉就去图书馆了。<br>最后得出一个结论：人啊，要想战胜懒惰，先的开始行动。</p>
<p>今日看了《Java编程思想》的多态，接口，内部类。总共花费蕃茄钟5.5个，当然这只是有效的蕃茄中，天知道我分心走神了几次。。。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态，继承，抽象统称为《面向对象三大核心系统》。多态传统上的用法有点像：基类的方法调用，子类的方法实现。它的作用就是消除类型之间的耦合关系。<br>了解多态就得先了解下<strong>绑定</strong>，绑定分为前期绑定和后期绑定。</p>
<p>前期绑定：默认的绑定方式，方法直接调用，在编译期就能知道。</p>
<p>后期绑定：根据运行时的对象的类型进行绑定。又称为动态绑定或者运行时绑定。</p>
<p>Java中除了static方法和final方法之外其它都是后期绑定。（private方法是final方法）。只有普通方法的调用是多态的，静态方法不能使用多态的。构造器实际上是static方法，不过是隐式的。酒席那个private的方法是final一样，也是隐式的。</p>
<p>动态绑定只有在运行时才知道，因为无法知道它是属于方法所在的那个类，还是属于那个类的子类。</p>
<p>编写构造器的一条准则：尽可能简单的方法是对象进入正常状态，如果可以的话，避免去调用其它方法。</p>
<p>使用继承还是使用组合？推荐使用组合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Happy Actor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SadActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Sad Actor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stage</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Actor actor = <span class="keyword">new</span> HappyActor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        actor = <span class="keyword">new</span> SadActor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performPlay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        actor.act();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Stage stage = <span class="keyword">new</span> Stage();</span><br><span class="line">        stage.performPlay();</span><br><span class="line">        stage.change();</span><br><span class="line">        stage.performPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码用到了<strong>状态模式</strong>，使用组合还是继承有一条通用准则：用继承表达行为间的差异，并用字段表达状态上的变化。代码中，通过继承获得了两个不同的类，用于表达act()方法的差异。stage通过使用组合的方式通过change()方法试自己的状态发生改变。状态的改变也产生了行为的改变。</p>
<p>一个子类向上转型成父类，总是安全的。但是父类向子类转型就不一定了，毕竟子类的实现可能有很多，直接强转可能会出错（ClassCastException）。</p>
<span id="more"></span>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口的好处有很多，我最大的体会就是，接口中定义方法，子类中各自实现。在项目中我也看过部分代码常量是写在接口中的，工具类是用abstract标明。这种写法我在《effective java》里面看到好像是不推荐这么干的。算了扯回来接口。</p>
<p>谈接口就有点类似抽象类。接口可以看作抽象类的抽象。接口中只有方法定义，新版jdk8支持带默认的方法体了好像要用default。但是实际中，我没用过。。接口中的方法都是public的。接口中声明的域都是static和final的。</p>
<p>策略模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">extends</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String)input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">extends</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String)input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String)input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Processor p,Object s)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Using processor&quot;</span>+p.name());</span><br><span class="line">        System.out.print(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String s = <span class="string">&quot;Disagreement with beliefs is by definition incorrect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        process(<span class="keyword">new</span> Upcase(),s);</span><br><span class="line">        process(<span class="keyword">new</span> Downcase(),s);</span><br><span class="line">        process(<span class="keyword">new</span> Splitter(),s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>根据所传递的参数对象的不同而具有不同行为的方法</strong>。Processor对象是一个策略。上面的例子是类版本，改成接口版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> String <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s = <span class="string">&quot;Disagreement with beliefs is by definition incorrect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        process(<span class="keyword">new</span> Upcase(),s);</span><br><span class="line">        process(<span class="keyword">new</span> Downcase(),s);</span><br><span class="line">        process(<span class="keyword">new</span> Splitter(),s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String)input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String)input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String)input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>适配器模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterAdapter</span> <span class="keyword">implements</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">    Filter filter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilterAdapter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filter = filter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> filter.name():&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filter.process((Waveform)input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Waveform w = <span class="keyword">new</span> Waveform();</span><br><span class="line">        Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> LowPass(<span class="number">1.0</span>)),w);</span><br><span class="line">        Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> HighPass(<span class="number">2.0</span>)),w);</span><br><span class="line">        Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> BandPass(<span class="number">2.0</span>)),w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口是可以多继承的，使用关键字<code>extends</code>。接口也可以用来实现工厂方法设计模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    Implementation1()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Implementation1 method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Implementation1 method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implemetation1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    Implementation2()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Implementation2 method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Implementation2 method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implemetation2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Implementation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span></span>&#123;</span><br><span class="line">        Service s = fact.getService();</span><br><span class="line">        s.method1();</span><br><span class="line">        s.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> Implemention1Factory());</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> Implemention2Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>将一个类的定义放在另一个类的定义内部，这就是内部类。普通内部类，只能放在类的外部层次，不能有static字段。匿名类必须传进必须是final的。</p>
<p>内部类实现工厂方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    Implementation1()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Implementation1 method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Implementation1 method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ServiceFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ServiceFactory()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    Implementation1()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Implementation2 method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Implementation2 method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ServiceFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ServiceFactory()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Implementation2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span></span>&#123;</span><br><span class="line">        Service s = fact.getService();</span><br><span class="line">        s.method1();</span><br><span class="line">        s.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        serviceConsumer(Implemention1.factory);</span><br><span class="line">        serviceConsumer(Implemention2.facotry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux如何查看当前占用CPU或内存最多的K个进程</title>
    <url>/2017/12/27/top-k-pid-memory-cpu-linux/</url>
    <content><![CDATA[<h1 id="Linux如何查看当前占用CPU或内存最多的K个进程"><a href="#Linux如何查看当前占用CPU或内存最多的K个进程" class="headerlink" title="Linux如何查看当前占用CPU或内存最多的K个进程"></a>Linux如何查看当前占用CPU或内存最多的K个进程</h1><h2 id="一、可以使用以下命令查使用内存最多的K个进程"><a href="#一、可以使用以下命令查使用内存最多的K个进程" class="headerlink" title="一、可以使用以下命令查使用内存最多的K个进程"></a>一、可以使用以下命令查使用内存最多的K个进程</h2><ol>
<li>方法1：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux | sort -k4nr | head -K</span><br></pre></td></tr></table></figure>

<p>如果是10个进程，K=10，如果是最高的三个，K=3</p>
<p><strong>说明：</strong>ps -aux中（a指代all——所有的进程，u指代userid——执行该进程的用户id，x指代显示所有程序，不以终端机来区分）</p>
<p>​        ps -aux的输出格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0  19352  1308 ?        Ss   Jul29   0:00 &#x2F;sbin&#x2F;init</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    Jul29   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        S    Jul29   0:11 [migration&#x2F;0]</span><br></pre></td></tr></table></figure>

<p>​     sort -k4nr中（k代表从第几个位置开始，后面的数字4即是其开始位置，结束位置如果没有，则默认到最后；n指代numberic sort，根据其数值排序；r指代reverse，这里是指反向比较结果，输出时默认从小到大，反向后从大到小。）。本例中，可以看到%MEM在第4个位置，根据%MEM的数值进行由大到小的排序。</p>
<p>​     head -K（K指代行数，即输出前几位的结果）</p>
<p>​     |为管道符号，将查询出的结果导到下面的命令中进行下一步的操作。</p>
<ol start="2">
<li>方法2：top （然后按下M，注意大写）</li>
</ol>
<h2 id="二、可以使用下面命令查使用CPU最多的K个进程"><a href="#二、可以使用下面命令查使用CPU最多的K个进程" class="headerlink" title="二、可以使用下面命令查使用CPU最多的K个进程"></a>二、可以使用下面命令查使用CPU最多的K个进程</h2><ol>
<li>方法1：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux | sort -k3nr | head -K</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法2：top （然后按下P，注意大写）</li>
</ol>
<p>原文转自:<a href="https://www.cnblogs.com/zhanmeiliang/p/5999300.html">博客园</a></p>
]]></content>
  </entry>
  <entry>
    <title>ubuntu 怎么修改源？</title>
    <url>/2018/05/02/ubuntu-change-source-list/</url>
    <content><![CDATA[<h1 id="ubuntu-怎么修改源"><a href="#ubuntu-怎么修改源" class="headerlink" title="ubuntu 怎么修改源"></a>ubuntu 怎么修改源</h1><p>修改ubuntu的源为国内的源，修改之前首先备份：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.backup</span><br></pre></td></tr></table></figure>

<p>修改源列表，选择的是国内的阿里源,<code>vi /etc/apt/sources.list</code>,清空里面内容：<code>dG</code>,使用命令的时候要回到第一行：<code>gg</code>,之后将下面的内容复制到文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security universe</span><br><span class="line">deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.daocloud.io&#x2F;docker&#x2F;linux&#x2F;ubuntu xenial stable</span><br><span class="line"># deb-src [arch&#x3D;amd64] https:&#x2F;&#x2F;download.daocloud.io&#x2F;docker&#x2F;linux&#x2F;ubuntu xenial stable</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>参数-异常统一打印</title>
    <url>/2017/11/02/unit-error-and-param-log/</url>
    <content><![CDATA[<blockquote>
<p>先说明我们业务开发基础框架使用的是 SpringBoot </p>
</blockquote>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在项目开发中总是需要知道一些常用信息打印，比如出现异常了你可能需要打印日志，为了便于分析，你可能也需要打印埋点数据，或者请求参数之类的。</p>
<p>这类操作可能在任何地方都有，如果分别取处理，感觉上不是特别合适。需要写大量代码并且维护量大。我的做法就是使用<code>@Aspect</code>,<code>@ControllerAdvice</code>利用切面来做统一的参数和异常处理。</p>
<span id="more"></span>
<h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p>使用<code>ControllerAdvice</code>注解来监听全局异常。这样的好处是，所有的出现异常的点我都是直接往上抛，而不用在每个业务里面去处理。在里面我处理了是否为我自己业务逻辑抛出的异常，如果是的话根据错误码返回响应的错误提示。如果不是业务异常，那么我就转换成系统异常，最后给用户的也是“系统出现异常”等提示语，而不会出现异常堆栈代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(ExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultData <span class="title">exceptionHandler</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;系统异常：&#123;&#125;&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        ResultData ret = <span class="keyword">new</span> ResultData&lt;&gt;();</span><br><span class="line">        ret.setData(<span class="keyword">null</span>);</span><br><span class="line">        ret.setSucceed(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            BusinessException serverException = (BusinessException) e;</span><br><span class="line">            ret.setErrorCode(serverException.getErrorCode());</span><br><span class="line">            ret.setErrorMsg(SpringUtil.getMessage(serverException.getErrorCode(), serverException.getMessage()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret.setErrorCode(<span class="string">&quot;100002&quot;</span>);</span><br><span class="line">            ret.setErrorMsg(SpringUtil.getMessage(<span class="string">&quot;100002&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="处理参数"><a href="#处理参数" class="headerlink" title="处理参数"></a>处理参数</h2><p>利用<code>@Aspect</code>，我将请求的参数，和响应的返回值都做了相应的日志打印。这种方式可能并不是特别好，因为可能响应的信息很多，那么可能系统很快就会磁盘爆满，但是在前期我想还是很有必要的，后期我们可能根据日志的级别来做响应的控制。</p>
<p>下面的代码主要是监控在 controller 层的参数和响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(ParamLogAspect.class);</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;Long&gt; startTime = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(public * com.web..*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        startTime.set(System.currentTimeMillis());</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        logger.info(<span class="string">&quot;URL : &#123;&#125;&quot;</span>, request.getRequestURL().toString());</span><br><span class="line">        logger.info(<span class="string">&quot;HTTP_METHOD : &#123;&#125; &quot;</span>, request.getMethod());</span><br><span class="line">        logger.info(<span class="string">&quot;IP : &#123;&#125; &quot;</span>, IPUtil.getIpAddress(request));</span><br><span class="line">        logger.info(<span class="string">&quot;CLASS_METHOD : &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());</span><br><span class="line">        logger.info(<span class="string">&quot;REQUEST_PARAM : &#123;&#125;&quot;</span>, Arrays.toString(joinPoint.getArgs()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(returning = &quot;resp&quot;, value = &quot;execution(public * com.web..*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(Object resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;RESPONSE : &#123;&#125;&quot;</span>, JSON.toJSONString(resp));</span><br><span class="line">        logger.info(<span class="string">&quot;SPEND TIME : &#123;&#125;&quot;</span>, (System.currentTimeMillis() - startTime.get()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，方式有很多，我也见过通过实现继承的接口方式来做异常处理的，不管哪种我们的目的都是一个，尽量不给用户不好的提示信息，毕竟我们的目标是：<strong>代码帅，运行快</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用CURL发送http请求</title>
    <url>/2018/01/09/use-curl-to-http-request/</url>
    <content><![CDATA[<h1 id="使用CURL发送http请求"><a href="#使用CURL发送http请求" class="headerlink" title="使用CURL发送http请求"></a>使用CURL发送http请求</h1><p>之前都是postman发送数据，但是在服务器上有时候没法用postman连接，其实挂VPN是可以的，但是为了显示b格(好吧，其实是被逼而已)使用curl发送http请求。</p>
<p>其实curl可以做的事情非常多，我们这里仅仅只是用到了一小一小小部分。</p>
<p>发送get请求：<code>curl localhost:8888/path/to/api</code></p>
<p>发送post请求带json数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl &quot;http://localhost:8888/path/to/api&quot; -H &quot;Content-Type: application/json&quot; --data &#x27;&#123;&quot;pageNumber&quot;:1,&quot;pageSize&quot;:10&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>当然还有一招，你可以使用火狐的控制台，查看网络，选中接口，复制为CURL。嘿嘿~~~</p>
]]></content>
      <categories>
        <category>CURL</category>
      </categories>
      <tags>
        <tag>CURL</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 初步使用</title>
    <url>/2017/05/09/vim-start/</url>
    <content><![CDATA[<h1 id="vim使用命令"><a href="#vim使用命令" class="headerlink" title="vim使用命令"></a>vim使用命令</h1><p>:help <command><br>:set nu<br>i: 插入<br>a: 当前光标后面插入<br>x: 删除当前光标<br>u: 撤销<br>control + r  前进<br>:w  保存<br>:q  退出<br>:wq  保存并退出<br>:q! 强制退出<br>dd 删除一行并且存入剪切板<br>2dd 剪切2行,从当前光标行开始计算<br>p 粘贴<br>o 之后新增一行<br>O 之前新增一行<br>cw 从光标开始到第一个空格全部删除,并在当前位置插入<br>0   数字0,到行头<br>$  到行末</p>
<span id="more"></span>

<p>^  到本行第一个不是blank字符的位置(blank指代空格,tab,换行,回车)<br>g_ 到本行最后一个不是blank字符的位置(blank指代空格,tab,换行,回车)<br>fa 查找下一个为a的字符处,fs 下一个为s的字符处..<br>3fa 当前行第3个出现a的位置<br>ta 查找下一个为a的字符的前一个字符处,ts 下一个为s的字符的前一个字符处..<br>F T 和 f t 类似,只是方向想反</p>
<p>dt” 删除所有内容,直到遇到”</p>
<p>/patern 文本查找,用n下一个</p>
<p>yy 拷贝<br>3yy 拷贝三行</p>
<p>:e &lt;path/to/file&gt; 打开一个文件<br>:saveas &lt;path/to/file&gt; 另存为<br>:bn :bp 切换打开的文件</p>
<p>.   重复上次的命令<br>N<command> 重复某个命令多少次<br> eg:2dd 删除2行,剪切也是<br>     3p  粘贴文本三次<br>     10idesu [ESC] 写下10次desu desu desu desu desu desu desu desu desu desu<br>     . 重复上一个命令–10”desu”<br>     3. 重复3次”desu”.只会输入3个</p>
<p>N G 到几行 比如34G 跳转到34行<br>gg 到第一行<br>G 到最后一行<br>w 到下一个单词的开头 W<br>e 到下一个单词的结尾 E</p>
<ul>
<li><h1 id="当前光标在那个字母上-按-或者-后-再按一次可以让光标移动了-是下一个-是上一个"><a href="#当前光标在那个字母上-按-或者-后-再按一次可以让光标移动了-是下一个-是上一个" class="headerlink" title="当前光标在那个字母上,按*或者#后,再按一次可以让光标移动了,*是下一个,#是上一个"></a>当前光标在那个字母上,按*或者#后,再按一次可以让光标移动了,*是下一个,#是上一个</h1></li>
</ul>
<p>% 可以匹配(,{,[ 括号的另一半,光标直接移动到另一个位置</p>
<p><code>&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</code><br>命令联动 0y&lt;dollar符号&gt;  复制一行</p>
<p>gU 转大写<br>gu 转小写<br>v 视图模式 ,然后按下hjkl 就可以选择了<br>视图模式下如果有,<code>(map (+) (&quot;foo&quot;))</code>.而光标键在第一个 o 的位置<br>vi” → 会选择 foo.<br>va” → 会选择 “foo”.<br>vi) → 会选择 “foo”.<br>va) → 会选择(“foo”).<br>v2i) → 会选择 map (+) (“foo”)<br>v2a) → 会选择 (map (+) (“foo”))</p>
<p>i和a可以代表in all</p>
<p>块操作<br>control + v<br>control + d<br>Itest [ESC]<br>&lt; &gt; 缩进<br>J 行缩进</p>
<p>:split 分屏<br>control+w 切换</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vuejs 从拷项目到开发上线</title>
    <url>/2019/04/08/vuejs-starter/</url>
    <content><![CDATA[<h1 id="vuejs-从拷项目到开发上线"><a href="#vuejs-从拷项目到开发上线" class="headerlink" title="vuejs 从拷项目到开发上线"></a>vuejs 从拷项目到开发上线</h1><p>最近组里缺人手，我们都是一堆后端，却没有一个前端。所以你看到了一堆的后台接口，但就是没有一个页面。囧~<br>本着求人不如求己，活人不能被尿憋死不是~所以准备自己开始干。</p>
<h2 id="前端选型"><a href="#前端选型" class="headerlink" title="前端选型"></a>前端选型</h2><p>首先想了一下，我们应该怎么开发前端了？使用thymeleaf这种貌似是最合适的，毕竟类似于以前用jsp，对不对~当然有点不一样。<br>但后来想想，都前后端分离了，以后我们要真的做牛逼了。要是给我们分配个前端，那我们不又要改死啊。<br>然后觉得前后端不分离，逼格不够，也不好维护。那好咯，那就定好方向前端分离。</p>
<p>前后端分离的方向定好，那就先想想是自己完全自己弄一个，还是直接用模板套一个？一致觉得，自己从头写，费时费力，一群后端去弄不太现实，毕竟还是有很多要调的，适配啊，排版啊。所以投票决定，选模板。选了模板，那就好弄了，github上找了前十个优秀的模板。有一些是基于bootstrap，然后每个页面都是html，所以这种就相当于用jQuery或者javascript用ajax这种吧。想想就被以前写dom支配的恐惧。后来了解到有个vue，人家都说好用，其实公司还有很多都是vue，我们想了想，要是用bootstrap那种估计就是靠我们自己了。要是vue，要是我们实际搞不定，在公司也好请外援。想了想，那就找vue的模板吧。找来找去，找了个最简单实用的。毕竟我们需求很简单，列表显示，表格添加，搜索框就好了，后管管理页面是真的好搞啊。找了个最简单的功能又全的，感谢github，感谢可爱的爱分享的工程师们。</p>
<h2 id="vue-使用"><a href="#vue-使用" class="headerlink" title="vue 使用"></a>vue 使用</h2><p>模板选好了，这下来到重头戏了。大家都不会啊，以前都是听说，我们前端用vue，特么到底怎么用啊。不过既然选好了方案，选好了模板，其实就很明确了，不会那就学啊。vue官网一翻，一遍浏览。大概的使用方式也是了解了。</p>
<h3 id="vue-数据绑定"><a href="#vue-数据绑定" class="headerlink" title="vue 数据绑定"></a>vue 数据绑定</h3><p>vue的模式感觉跟以前的不一样，看整个项目发现其实就一个html页面，也就是index.html，然后就是在里面有个APP.vue，通过不同的xx.vue来选择相应的页面，其实就是他们口中的单页式应用。就是一个html页面，然后根据不同的path来显示不同的内容。另外需要转换一个观点，vue不像传统的面向页面来编程，因为它的数据绑定感觉太好用了。如果是在html标签中只需要用<code>&#123;&#123; key &#125;&#125;</code>就可以使用在js中定义的key的值。有几个好用的标签：</p>
<p>感觉吧，说的不太全，还是要实际用起来才有那种感觉。<a href="https://github.com/chenzhijun/vue-manage-system">模板地址</a></p>
<h2 id="使用中遇到的问题"><a href="#使用中遇到的问题" class="headerlink" title="使用中遇到的问题"></a>使用中遇到的问题</h2><p>在实际使用中遇到一些问题，一开始有点懵逼，不过到后来都解决了。</p>
<h3 id="本地开发-跨域问题"><a href="#本地开发-跨域问题" class="headerlink" title="本地开发-跨域问题"></a>本地开发-跨域问题</h3><p>这个一开始的时候有点蒙圈，本地是使用<code>npm run dev</code>启动的，启动后发现，跨域了。这个该怎么搞哦。后来在vue.config.js中发现一个文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    baseUrl: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">    productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&#x27;/m-paas&#x27;</span>:&#123;</span><br><span class="line">                target: <span class="string">&#x27;http://localhost:8080/m-paas&#x27;</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite:&#123;</span><br><span class="line">                    <span class="string">&#x27;/m-paas&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实可以看到只要打开changeOrigin 就可以了。其它的都不需要改动。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>开发完了，代码也写好了。重点来了，怎么部署到服务器？来跟我三步走</p>
<ol>
<li>step1，构建应用</li>
</ol>
<p>使用<code>npm run build</code>先进行构建，完成后会在根路径下生成一个dist文件夹。</p>
<ol start="2">
<li>step2，准备nginx服务器</li>
</ol>
<p>下载一个nginx，现在都是使用nginx来做前端的服务器。将刚刚的dist文件夹的内容copy到服务器某个路径。<br>比如<code>/app/html</code>，或者就是nginx目录下的html。随自己开心就好</p>
<ol start="3">
<li>step3，修改nginx配置</li>
</ol>
<p>目录确定后，我们就需要修改nginx的配置了。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">       listen       127.0.0.1:6000;</span><br><span class="line">       #server_name  localhost;</span><br><span class="line"></span><br><span class="line">       #charset koi8-r;</span><br><span class="line"></span><br><span class="line">       #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">       location &#x2F;m-web&#x2F; &#123;</span><br><span class="line">          root   &#x2F;app&#x2F;html&#x2F;dist;</span><br><span class="line">          index  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line">       location &#x2F;m-api &#123;</span><br><span class="line">           proxy_pass http:&#x2F;&#x2F;localhost:8080&#x2F;m-api;</span><br><span class="line">           #proxy_pass http:&#x2F;&#x2F;api-m.chenzhijun.top&#x2F;m-api;</span><br><span class="line">       &#125;</span><br><span class="line">       #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">       # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">       #</span><br><span class="line">       error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">       location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">           root   html;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后启动 nginx 就好了。</p>
]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是云原生？</title>
    <url>/2023/02/10/what-is-cloud-native/</url>
    <content><![CDATA[<h1 id="什么是云原生？"><a href="#什么是云原生？" class="headerlink" title="什么是云原生？"></a>什么是云原生？</h1><p>云原生是一种基于容器、微服务和自动化运维的软件开发和部署方法。</p>
<p>云原生分为 3 种核心技术和 2 个核心理念：</p>
<p>3 种核心技术：分别是容器、微服务、服务网格；<br>2 个核心理念：分别指不可变基础设施和声明式 API。</p>
<span id="more"></span>
<p>容器：容器是云原生应用程序中最小的计算单元。它们是将微服务代码和其他必需文件打包在云原生系统中的软件组件。通过容器化微服务，云原生应用程序独立于底层操作系统和硬件运行。这意味着软件开发人员可以在本地、云基础设施或混合云上部署云原生应用程序。 开发人员使用容器将微服务与其各自的依赖项（例如主应用程序运行所需的资源文件、库和脚本）打包。</p>
<p>微服务：微服务是小型的独立软件组件，它们作为完整的云原生软件共同运行。每个微服务都侧重于一个小而具体的问题。微服务是松散耦合的，这意味着它们是相互通信的独立软件组件。开发人员通过处理单个微服务来更改应用程序。这样，即使一个微服务出现故障，应用程序仍能继续运行。</p>
<p>服务网格：服务网格是云基础设施中的一个软件层，用于管理多个微服务之间的通信。开发人员使用服务网格来引入其他功能，而无需在应用程序中编写新代码。</p>
<p>不可变基础设施：不可变基础设施意味着用于托管云原生应用程序的服务器在部署后保持不变。如果应用程序需要更多计算资源，则会丢弃旧服务器，并将应用程序移至新的高性能服务器。通过避免手动升级，不可变基础设施使云原生部署成为一个可预测的过程。 </p>
<p>声明式 API：应用程序编程接口（API）是两个或多个软件程序用来交换信息的方法。云原生系统使用 API 将松散耦合的微服务整合在一起。API 会告诉您微服务想要什么数据以及它能给您带来什么结果，而不是指定实现结果的步骤。</p>
<p>云计算是云供应商按需提供的资源、基础设施和工具。而云原生是一种使用云计算模型构建和运行软件程序的方法。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>查漏补缺 Java 系列 - JVM 垃圾回收</title>
    <url>/2021/04/05/what-is-garbage-to-need-collecter/</url>
    <content><![CDATA[<h1 id="查漏补缺-Java-系列-JVM-垃圾回收"><a href="#查漏补缺-Java-系列-JVM-垃圾回收" class="headerlink" title="查漏补缺 Java 系列 - JVM 垃圾回收"></a>查漏补缺 Java 系列 - JVM 垃圾回收</h1><p>正如一间房子，房子的主人肯定需要在客人来的时候进行一些收拾，让家里显得更加的大，而让客人有更好的体验。JVM 也是一样，你想想，JVM 是不是也要不定时的清理下内存区域空间以便能让更多的线程有更好的执行体验？那主人在进行清理的时候，至少要知道要对哪个区域进行清理吧？要知道在哪个区域清理哪些垃圾吧？清理的过程是用拖把还是用扫把，要有个选择吧？你想想 JVM 是不是也应该是类似的？</p>
<h2 id="JVM-应该回收哪个区域的垃圾？"><a href="#JVM-应该回收哪个区域的垃圾？" class="headerlink" title="JVM 应该回收哪个区域的垃圾？"></a>JVM 应该回收哪个区域的垃圾？</h2><p>上一篇，我们介绍了 jvm 中一些基础概念，包括运行时内存区域。其中我们知道 jvm 规范中规定了5个运行时区域，一器两栈一堆一区。程序计数器，Java 虚拟机栈，本地方法栈，堆，方法区【运行时常量池（方法区内部）】；</p>
<p>JVM 这些区域里面我们可以分两类，一类需要重点关注 GC，一点可以不需要 GC。根据它们的生命周期可以看到虚拟机栈、本地方法栈、程序计数器这三个线程私有的区域，他们的生命周期跟线程的生命周期保持一样，他们的内存分配和回收时间是可以确定的，所以基本上用不上 GC；而方法区，堆他们需要在程序实际运行时才能知道需要创建哪些对象分配多大的空间，所以这部分是重点要关注的 GC 区域；</p>
<p>我们根据分配的时机来确定了需要进行垃圾回收的两个区域：堆，方法区。但是在 jvm 规范中对方法区进行了一个定义，也就是这块区域逻辑上属于堆，但是它可以不用 GC（上篇文章我有说到）。因此我们将重点放到堆（Heap）的回收中。</p>
<p>好了，我们现在知道哪个区域需要进行 GC 了，那么 JVM 又如何知道哪些是垃圾需要清理，哪些不是垃圾不需要清理了？因为堆主要是用来存放对象的，我们也可以当做，jvm 应该怎么判读一个对象是不是应该被回收？</p>
<span id="more"></span>
<h2 id="JVM-怎么判断是不是要回收的对象？"><a href="#JVM-怎么判断是不是要回收的对象？" class="headerlink" title="JVM 怎么判断是不是要回收的对象？"></a>JVM 怎么判断是不是要回收的对象？</h2><p>判断一个对象是不是应该被回收，通常是认为这个对象是否存活（有用）。判断的方式一般可以选择下面两种方法：1，引用计数法；2，可达性分析法。</p>
<p><code>引用计数法</code>就是给对象加一个引用计数器，每一次被引用到就加1，解除引用就减1。如果为 0 那就认为是需要被回收的，不能再继续使用了。这种方法效率高，一般情况下其实还不错，但是有个隐藏的问题，那就是对象之间的循环引用问题。</p>
<p>什么是循环引用呢？看下面的代码你就能很好地理解了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CircularReference &#123;</span><br><span class="line">    public Object instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CircularReference objA &#x3D; new CircularReference();</span><br><span class="line">        CircularReference objB &#x3D; new CircularReference();</span><br><span class="line">        objA.instance &#x3D; objB;</span><br><span class="line">        objB.instance &#x3D; objA;</span><br><span class="line">        objA &#x3D; null;</span><br><span class="line">        objB &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方式就是<code>可达性分析法</code>，可达性分析就是从一个起始点出发（GC Roots），从这个节点往下搜索节点，两个点之间的路径叫做引用链条（Reference Chain）。当一个对象到 GC Roots 之间没有任何一条引用链，我们判断这个节点是可回收的对象。</p>
<p>可达性的图类似于下面这样：</p>
<p><img src="/images/qiniu/2020-04-05-14-59-07.png" alt="2020-04-05-14-59-07"></p>
<p>可达性分析可以解决循环引用的问题，你看上图的 a，b两个对象。从 GC Root 到 a,b 两者间是没有引用链的，所以是可以认为a,b 可以回收。但是 a，b 一定会回收吗？可达性分析的过程中，会要进行两次标记才能确定对象是否可以被回收，第一次可达性分析中，会将没有引用链的对象进行第一次标记并且进行一次筛选。筛选的条件主要是看对象是否有必要执行finalize()方法，如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用了，虚拟机认为这两种情况都属于“没有必要执行”。所以在被回收前，他们还是有一次机会进行“自救”的。如果第二次标记的时候对象还是没有引用链，那么就真的被回收了。</p>
<blockquote>
<p>虚拟机进行了一轮筛选后会将有必要执行 finalize()方法的对象发到一个 F-Queuen 的队列中，然后创建一个 Finalizer 线程去执行它。这里要注意虚拟机会触发执行它，但不承偌会等待其运行完，这样做的目的是为了防止 finalize() 方法执行缓慢，或者死循环，这样会导致 F-queuen 里面的所有对象都会处于永久等待状态，也可能导致整个内存回收系统崩溃。</p>
</blockquote>
<p>这是两种常用的判断对象是否可以进行回收的方法。</p>
<p>我们举个例子子说明：<br>假设现在你要堆家里进行大扫除，你需要整理一些垃圾扔掉，你应该怎么做？</p>
<p>如果你在家里做过大扫除，你肯定需要对物品进行判断是不是应该进行清理，你判断的方式可能是两种：1. 物品是属于谁的（开玩笑，要是你把女朋友的口红扔了试试？）；2. 物品还能不能用？</p>
<p>假设你跟你女朋友住一起，在打扫客厅的时候看到了一个空的薯片桶盒，你会想这是谁吃的，自己没吃过，问了女朋友，她也说没吃过。好了，反正就是没人认啦，然后这个盒子对于你是否有用了？至少对于大部分人来说是没用了（废物回收者除外），所以你就判断它是垃圾了。对吧。这是不是有点类似于引用计数法？有人用就+1，没人用就-1，为 0 就回收啊。</p>
<p>然后，你在打扫沙发的时候发现了一个未拆封的礼品盒，你确认这不是你的。然后你问你女朋友，这是不是她的？她说，这不是她的，但是这是她给她闺蜜买的礼物。这个时候你可以认为这个礼物属于女朋友闺蜜，女朋友闺蜜和女朋友有关联。你看这是不是可达？这个礼品盒（对象）和GC ROOT（女朋友）之间是不是有个引用链？那这个肯定就不是垃圾了。对吧。</p>
<h2 id="JVM-该怎么回收垃圾了？"><a href="#JVM-该怎么回收垃圾了？" class="headerlink" title="JVM 该怎么回收垃圾了？"></a>JVM 该怎么回收垃圾了？</h2><p>刚也说了，垃圾已经找出来了，但是现在就是要清理垃圾了。你把客厅的垃圾都扫出来了，总不可能就放在哪里不管了吧？</p>
<p>在 jvm 中有四个主要的垃圾收集算法：</p>
<ol>
<li>标记-清除算法；</li>
<li>复制算法；</li>
<li>标记-整理算法；</li>
<li>分代收集算法；</li>
</ol>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>先根据可达性分析标记出哪些需要进行回收，然后将对象进行回收。大致步骤：</p>
<ol>
<li>标记垃圾；</li>
<li>直接回收垃圾；</li>
</ol>
<p><img src="/images/qiniu/2020-04-06-18-26-50.png" alt="2020-04-06-18-26-50"></p>
<p>看图片就知道，实现的步骤很简单，就是标记，然后清除掉。这样的方式很简单暴力，但是也带来了问题，那就是不连续的内存段，导致空间浪费。空间浪费的原因就是它造成了很多碎片内存，你想啊，你要一个 3M 的连续内存空间，但是内存里面都是分散的 1M 的空间，你说气不气人？白白浪费了，不持家啊~~</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法的流程大致如下：</p>
<ol>
<li>标记哪些是可回收的，哪些是使用中的；</li>
<li>将使用中的对象复制到内存的另一半空闲中；</li>
<li>清理掉需要回收的原来的一半内存；</li>
</ol>
<p><img src="/images/qiniu/2020-04-06-18-21-37.png" alt="2020-04-06-18-21-37"></p>
<p>复制算法的思路很清晰，就是把一块内存劈成两半，然后一半内存满了，就把这一半内存中有用的全部移动到另一个内存空间，再把原来满的一半全部清了。这种算法其实很好啊，你看就解决了内存不足的问题（可以回收），也解决了内存碎片的问题（复制的时候是连续的）。就是有个不好，明明有 100M 内存，但是你就是只能用 50M，你说气人不气人。另外复制算法带来了一个隐藏的问题，如果使用的一半内存中有 90% 的对象都是需要用到的，那可是要复制 90% 的对象到另一半中啊。你说怎么办？看下面的另一个算法</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>如果复制的内容过多，那我们是不是可以不复制了？标记整理算法就可以这样。它的原理就是我把所有需要使用到的对象都往一边移动，然后移动到最后一个对象的时候，作为边界，把边界之后的全部删除掉，这样是不是就可以了？</p>
<p><img src="/images/qiniu/2020-04-06-18-43-10.png" alt="2020-04-06-18-43-10"></p>
<p>这样算法就是明显的使用的空间大了，但是如果是很多对象都存活着的话，那也是移动效率有点慢。</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法它其实是一种组合算法，我们可以看到上面的几个优缺点，标记清除有简单性，但是可能造成内存碎片；复制算法做到了内存的连续性，但是可能有大量复制（存货对象过多）而且内存利用率不太好；标记-整理算法看起来很不错，但是如果是只有少量的需要垃圾回收的对象了？那么移动每个对象就变成了很麻烦的操作。所以分代搜集算法就是在这种情况下产生的，既然其它算法都有好处，那我可不可以将一块大内存，划分为几块大小不一样的内存，然后每块内存里面采用不同的算法？这在虚拟机的实现过程中也是有这种考量的，比如 hotspot 虚拟机实现中就有下面的一个对象存活时间分析图：</p>
<p><img src="/images/qiniu/2020-04-06-21-08-37.png" alt="2020-04-06-21-08-37"></p>
<blockquote>
<p>图地址为：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#distribution_lifetimes">distribution_lifetimes</a></p>
</blockquote>
<p>可以看到如果以 x 轴为对象的生命周期，y 轴为对象内存分配空间。会发现很对的对象其实都是只有很短的生命周期，换通俗点说，就是很多对象可能就是朝生夕死；换人来说的话：吾朝闻道夕死可矣；换“对象(instance)”来说的话：活已经干完了，要杀要剐你看着办吧。总之你要知道，很多对象的生命周期都是很短的，所以如果不采用分代收集的话，那么对于一整块内存来说，最后做 GC 这个工作量会很大。</p>
<p>主流的虚拟机就开始想了个办法，既然一整块去收集集工作量大，那我可不可以让这个 GC 的时间提早？我把内存划分为几个区域，然后每个区域分代去回收内存是不是效率就高了？于是就有了我们现在的主流，根据对象的存活年龄来分代。</p>
<p><img src="/images/qiniu/2020-04-06-21-46-15.png" alt="2020-04-06-21-46-15"></p>
<p>对图中的几个区域做下说明：</p>
<p>virtual：在初始化的时候会预留一块内存区域，这个区域除非是必要时候，不然不会分配实际物理内存；<br>Eden 区：年轻代中的 eden 区，对象开始分配空间的主区域，young gc 的主区域；<br>s0：年轻代中的幸存者区域之一，结合我们说的复制算法，eden 区的内存复制到这里；<br>s1：年轻代中的幸存者区域之一，跟 s0 的作用一样；<br>Tenured：永久代/老年代，存放幸存者达到一定年龄的对象；</p>
<blockquote>
<p>空间比：Eden:s0:s1 = 8:1:1</p>
</blockquote>
<p>这里需要说明一下 s0,s1 两个区域，这两个区域的作用不仅仅是将 eden 区存活的幸存对象复制保存下来，他们自己本身也会进行 gc，比如 s0 里面满了，那么下次年轻代 gc (又叫minor gc)的时候，s0 中存活的对象复制到 s1 中；再下次年轻代 gc 的时候，s1 又把自己本身存活的对象复制到 s0 中，这样每经过一次 minor gc，对象的年龄就+1，达到我们设定的阈值比如 15，就会进入到永久代。</p>
<h2 id="GC-过程"><a href="#GC-过程" class="headerlink" title="GC 过程"></a>GC 过程</h2><h3 id="minor-GC"><a href="#minor-GC" class="headerlink" title="minor GC"></a>minor GC</h3><p>我们看下一个对象的从创建到最后升级到永久代的过程(多次的 minorGC)：</p>
<ol>
<li>先在 eden 区创建一个对象：</li>
</ol>
<p><img src="/images/qiniu/2020-04-06-22-09-02.png" alt="2020-04-06-22-09-02"></p>
<ol start="2">
<li>Eden 区要满了，准备触发 minorGC：</li>
</ol>
<p><img src="/images/qiniu/2020-04-06-22-09-53.png" alt="2020-04-06-22-09-53"></p>
<ol start="3">
<li>触发一次 minorGC 将 eden 区的一部分存活对象移动到 s0 中：</li>
</ol>
<p><img src="/images/qiniu/object-minor-gc-1.gif" alt="object-minor-gc-1"></p>
<ol start="4">
<li>触发下一次 minorGC，将其一定到另一个 s1 中：</li>
</ol>
<p><img src="/images/qiniu/object-minor-gc-2.gif" alt="object-minor-gc-2"></p>
<ol start="5">
<li>如果到了我们设定的阈值，就晋升到永久代：</li>
</ol>
<p><img src="/images/qiniu/object-minor-gc-3.gif" alt="object-minor-gc-3"></p>
<p>如果有一个对象需要大量的连续内存时，这种特殊情况下对象的创建不会在 Eden 区，而是直接在老年代。因为如果放在 eden 区，minorGC 进入到 s0、s1 会导致这块很快就空间满了，空间满了就会又开始 gc，那不是费时费力吗，所以直接放到老年代。</p>
<h3 id="Major-GC-Full-GC"><a href="#Major-GC-Full-GC" class="headerlink" title="Major GC(Full GC)"></a>Major GC(Full GC)</h3><p>上面讲的是 minorGC，那么我们可以想一下，如果在对象到了我们设定的阈值，需要进入永久代了，我们是不是应该要先检查下当前永久代代的空间是不是还够年轻代进行 minorGC？这个叫做空间分配保障。那么怎么保障？如果当前永久代剩余空间大于年轻代的总空间，那肯定没问题，你 minorGC 继续。如果发现当前空间小与年轻代总空间，虚拟机会去查一下HandlePromotionFailure是否允许担保。如果设置为允许，那么怎么办？虚拟机按照以前的 minorGC 晋升到永久代的平均大小，如果大，就 minorGC，如果小就进行 FullGC。</p>
<p>如果永久代也满了，那么 FullGC 肯定也会触发了。</p>
<p>FullGC 的过程是堆整个堆进行全量 GC，同时回收年轻代和永久代，会导致一个STW（Stop The World），很好理解啊，我都要进行全家大扫除了，你给我说，你还要继续嗑瓜子？？</p>
<p>好了，今天写到这里，前面讲了内存区域，今天讲了垃圾标识和常见的算法。明天继续写安全点和常见的几个垃圾收集器。之后再写 GC 日志分析，发生 OOM 线上怎么调试。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>查漏补缺 Java 系列 - JVM 基础概念</title>
    <url>/2021/04/04/what-is-jvm-when-we-talk-about-it/</url>
    <content><![CDATA[<h1 id="查漏补缺-Java-系列-JVM"><a href="#查漏补缺-Java-系列-JVM" class="headerlink" title="查漏补缺 Java 系列 - JVM"></a>查漏补缺 Java 系列 - JVM</h1><p>你知道 JVM 吗?作为Java开发人员，我想你肯定听过吧?那么你了解为什么需要 JVM 吗?它的作用是什么?给我带来了什么好处，又给我们带来了什么缺点了?接下来我们一起看看吧。</p>
<h2 id="JVM-的基础概念"><a href="#JVM-的基础概念" class="headerlink" title="JVM 的基础概念"></a>JVM 的基础概念</h2><p>什么是 JVM ? </p>
<p>JVM(Java Virtual Machine) 中文名称为 Java 虚拟机。它的作用是为 Java 提供跨平台运行的基础，也就是那句”一次编译，到处运行”的底层保证。 </p>
<p>我想你肯定在 windows，Linux，MacOS 上都有运行过 Java 程序，那么你想一想，在一台裸机上面(指新买的机器装上一个纯的干净的系统 OS)，你直接编写一个 Main。java 能运行起来么?运行一个 Main。java，我想你肯定经过这几个步骤:安装 jdk(jre) -&gt; 编写 Main。java -&gt; <code>javac Main。java</code>生成<code>main。claas</code>文件 -&gt; <code>java Main</code>;那你想过吗?为什么你要安装一个 jkd(jre)，为什么你要先用<code>javac</code>命令，生成一个<code>claas</code>文件，然后才能执行了?</p>
<p>你肯定有疑问。是的。我想跟你说的是其实 jvm 根本不知道你写的 java 文件里面的内容，一点都不知道。但是它认识你按照它的规范生成的 class 文件。然后它再将 class 文件翻译成机器识别的机器码。这样才能真正的运行你的程序了。也许这就是为什么很多人会说它是解释器吧。</p>
<span id="more"></span>
<h2 id="JVM-都含有什么"><a href="#JVM-都含有什么" class="headerlink" title="JVM 都含有什么?"></a>JVM 都含有什么?</h2><p>我们知道 java 代码要在 jvm 里面运行的话，上面的概念解释中也说了，它需要由 java 编译器生成 class 字节码文件，然后再由 jvm 将字节码 class 文件翻译成底层不同的平台所能识别的机器码。那么在读取到解释成为字节码的过程中，它肯定需要进行一些操作，它进行操作肯定也就避免不了要使用一些工具（或者我们称之为资源）。它要用到的资源就是内存。就像我们住在自己的房子里面一样，我们肯定会要定下来，哪里是我们的卧室，哪里是我们的厨房，哪里是我们的客厅，哪个地方是书房等等。JVM 也是一样。JVM 将它所管理的内存分为了几个运行时数据区域。那么 JVM 有哪几个区域呢？看 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5">Run-Time Data Areas</a> 总共是 5 个运行时数据区：程序计数器（PC register），Java 虚拟机栈（Java Virtual Machine Stacks），堆（Heap），方法区（Method Area），运行时常量池（Run-Time Constant Pool），本地方法栈（Native Method Stacks）。</p>
<ol>
<li><p>程序计数器（PC register）：线程私有；jvm 中每一个线程都会有的一块区域，如果是非本地方法（not native thread）的线程，会保存一个当前指令的执行地址；如果是本地方法的线程（native thread）,这个位置就为空（undefined）；这块的空间足够大，大到足够支持所有的指令地址和本地方法指针，所以这块不会出现 OOM 的时候。（原话：The Java Virtual Machine’s pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.）</p>
</li>
<li><p>Java 虚拟机栈（Java Virtual Machine Stacks）：线程私有；每个线程创建的时候同步创建这块区域与线程的生命周期相同；它的主要主要作用是用来存储<a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-2.html#jvms-2.6">栈帧</a>（Frame）；它存储局部变量，操作数栈，动态链接，方法调用，方法返回值等信息；Java 虚拟机栈的空间分配可以是不连续的一段内存空间；jvm 规范规定这块的空间可以是固定大小，也可以是动态的大小，由具体的虚拟机实现。在 Java 虚拟机栈中，如果一个运行中的线程请求比 jvm 允许的栈大小更大的空间，jvm 就会直接抛出<code>StackOverflowError</code>；如果是动态扩容机制，当本地内存不足的时候，会抛出<code>OutOfMemoryError</code>。</p>
</li>
<li><p>堆（Heap）：是一块线程共享的区域，在 java 虚拟机启动的时候就会被创建，主要作用是用来储存对象实例和数组。这块区域可以被垃圾回收器回收，如果需要的资源比垃圾回收期回收后释放出来的资源还要大，那它就会抛出<code>OutOfMemoryError</code>。实际上，这块区域可以设置为动态扩缩容，应该提供设置最大堆内存和最小堆内存的方法。这块区域的空间申请可以是不连续的空间。</p>
</li>
<li><p>方法区（Method Area）：方法区是一个线程共享区域，在 java 虚拟机启动的时候会被创建，主要用来存储每个类的结构，比如说类信息，常量，静态变量，方法和构造方法等。逻辑上它是堆（Heap）的一个区域，但是简单实现它可以不需要使用垃圾回收期回收它。如果需要动态调节它的大小，应该提供最大空间和最小空间的设定方法。如果方法区的内存不够分配了，应该要抛出<code>OutOfMemoryError</code>异常。</p>
</li>
<li><p>运行时常量池（Run-Time Constant Pool）：属于方法区的一部分，在类或者接口创建的时候生成，主要用来存储编译期间的各种字面量和符号引用。运行时常量池对于 Class 文件有动态性，不要求常量一定只有编译期才能产生，也可以在运行期加入新的常量，比如使用 String.intern（）方法。如果该区的空间不够，那么就会跟方法区一样抛出<code>OutOfMemoryError</code>异常。</p>
</li>
<li><p>本地方法栈（Native Method Stacks）：这个有点类似于 Java 虚拟机栈，虚拟机栈是为执行 Java 方法服务，本地方法栈则为调用 native 方法服务，也会抛出<code>StackOverflowError</code>,<code>OutOfMemoryError</code>异常。</p>
</li>
<li><p>直接内存/堆外内存：我在官网的介绍中其实并没有看到这个，但是我看书（《深入理解 Java 虚拟机上》）里面介绍，就一起放到这里了。这块的空间其实就是系统内存中除了分配给 jvm 那些数据区域的，剩下的内存。这块的空间受限于机器本身的内存总大小。这块的作用其实就类似于 NIO 中的 channel 直接操作 Native 函数库直接分配堆外内存。</p>
</li>
</ol>
<blockquote>
<p>ps 方法区很多人也叫永久代（permanent Generation），本质上两者并不等价，这只是 hotspot 虚拟机的一种具体实现而已，用永久代来实现方法区。书是基于 jdk1.7 的，1.8 中 PermGen 已经被去掉了<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html">whats-new-on-jdk-8</a>。</p>
</blockquote>
<p>现在你知道了上面定义的 6 个内存 jvm 运行区域，但是在各家的 jvm 虚拟机实现中有点不同。比如 HotSpot，其实我们可以看到只要有上面的规定的 6 个运行时区就行了，毕竟这是规范，具体实现肯定不同：</p>
<p><img src="/images/qiniu/2020-04-04-23-12-46.png" alt="2020-04-04-23-12-46"></p>
<p>了解这么多的内存区域，那么它是怎么识别一个对象是否应该被回收？怎么回收空间的了？用到了什么算法？<br>明天继续！</p>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/zhenghongcs/article/details/104628800">jvm</a></p>
<p><a href="https://docs.oracle.com/javase/specs/index.html">Java Language and Virtual Machine Specifications</a></p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html">gc 调优-官网文档</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS 到底是什么？CA 证书又是指什么？</title>
    <url>/2021/06/16/what-is-the-truely-about-https/</url>
    <content><![CDATA[<h1 id="HTTPS-到底是什么？CA-证书又是指什么？"><a href="#HTTPS-到底是什么？CA-证书又是指什么？" class="headerlink" title="HTTPS 到底是什么？CA 证书又是指什么？"></a>HTTPS 到底是什么？CA 证书又是指什么？</h1><p>https 相信很多人已经不陌生了，那么 https 到底是怎么一回事？我们通常说用 https 就要证书，那么证书和 CA 又是什么关系了？</p>
<!-- 这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题？-->
<h2 id="HTTPS-出现的背景"><a href="#HTTPS-出现的背景" class="headerlink" title="HTTPS 出现的背景"></a>HTTPS 出现的背景</h2><p>我们通常习惯于使用 http 进行数据通信，可以说如果这个世界是个和谐的世界，那么应该就没 http 的事了。不过林子大了，什么鸟都会有。我们在使用 http 的时候镜像面对的一个问题就是安全性。http 的报文传送都是已明文的方式传送，那么问题来了?我怎么知道这个到底是不是原始数据？如果有个中间人截获了然后篡改消息怎么办？基于这个问题，Netscape（开发 Firefox 的公司）搞了一个 SSL 协议。后来 SSL 发展到 v3 版本时，被标准化，这个时候就改名了，叫 TLS。于是乎，在 http 上 加了 SSL/TLS 就变成了我们都知道的 HTTPS。</p>
<!-- 这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off （要什么不要什么）是什么 -->
<h2 id="HTTPS-优势和劣势是什么？"><a href="#HTTPS-优势和劣势是什么？" class="headerlink" title="HTTPS 优势和劣势是什么？"></a>HTTPS 优势和劣势是什么？</h2><p>HTTPS 出现了之后，安全协议在 OSI 的分层中属于在 HTTP 之下，传输层之上。</p>
<p>HTTPS 带来的的优势有下面几点：</p>
<ol>
<li>数据加密与安全保护；</li>
<li>认证用户和服务器，可以确保数据正确发送到 客户机和服务器;</li>
<li>SEO 倾斜；</li>
</ol>
<p>HTTPS 的劣势也比较明显：</p>
<ol>
<li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长 </li>
<li>加解密会在服务端增加 CPU 的消耗 </li>
<li>证书费用 </li>
<li>相对意义上的安全（拥有 CA 根证书，也是可以攻击的）</li>
</ol>
<h2 id="这个技术适用的场景"><a href="#这个技术适用的场景" class="headerlink" title="这个技术适用的场景"></a>这个技术适用的场景</h2><p>https 适用于所有的网站。但是如果在一些不需要特别注意安全性，又需要快速访问的话，比如博客网站，静态资源这些，我们可以直接使用 http 而不用 https。在下面的一些场景中，最好还是使用 https:</p>
<ol>
<li>企业应用 </li>
<li>政务信息 </li>
<li>支付应用 </li>
<li>API接口</li>
</ol>
<h2 id="这个技术的组成部分和关键点（核心思想，核心组件）"><a href="#这个技术的组成部分和关键点（核心思想，核心组件）" class="headerlink" title="这个技术的组成部分和关键点（核心思想，核心组件）"></a>这个技术的组成部分和关键点（核心思想，核心组件）</h2><p>https 的关键在于对信息的加密。在传统的 http 的过程我们 AB 两点间的通信是这样的。</p>
<p><img src="/images/qiniu/2020-06-16-23-11-08.png" alt="2020-06-16-23-11-08"></p>
<p>A 直接发送数据给 B。好了。这个时候有个 C 出来了搞事情了：</p>
<p><img src="/images/qiniu/2020-06-16-23-16-06.png" alt="2020-06-16-23-16-06"></p>
<p>看原来好好的一个打招呼，变成了一个莫名其妙~~</p>
<p>那 AB 之间假设要防止 C 的截获并且篡改消息，怎么办？生活中也有这种场景，比如谍战片里面，卧底和接头人约定一个密码串，然后 A 用密码串加密，B 用密码串解密。</p>
<p><img src="/images/qiniu/2020-06-16-23-24-38.png" alt="2020-06-16-23-24-38"></p>
<p>这样只要 AB 都有一个密码本，那就可以加解密了。这也就是我们常说的“对称加密”。但是假如你们之间的这个密码本被 C 获取了呢?  C 获取了你们的密码本，它也不告诉 AB，那就跟我们上图一样了。它先解密 A 的数据，然后再篡改数据加密后再发给 B。你看这就危险了吧。</p>
<p>那这个时候我们又要想办法了。B 说这样不安全，这样吧，我用两个密码本，一个公开给你（公钥），一个我自己单独留着（私钥）。你发过来的消息用我的公钥加下密码，我用我的私钥解下密。A 说好，拿着 B 的公钥加密数据后发给了 B。这样一看，嗯，很不错，A 发给 B 的消息再也不会泄漏了。因为就算 C 获取了消息，它没有私钥也没法解密消息啊。A 也这样想，也是，但是你回给我的消息还是可能被截取到，那我这个 A 也搞个公钥和私钥，你发给我的消息，用我的公钥加密下。这样一看，很不错啊。A B 之间发送的消息再也不用担心被第三方知道了，因为 C 无法界面消息啊！</p>
<p><img src="/images/qiniu/2020-06-16-23-45-49.png" alt="2020-06-16-23-45-49"></p>
<p>如果 C 是个好人，那就到此了。可是如果 C 不甘心了？C 想，既然 A 的实际数据我不知道，那我就假装 B 来跟 A 套取数据。比如下面，毕竟 A 是无法判断到底谁是 B 的。如果想不明白，想想谍战片，你说你是好人，你就是好人吗？怎么证明？：</p>
<p><img src="/images/qiniu/2020-06-16-23-50-39.png" alt="2020-06-16-23-50-39"></p>
<p>那好吧。大家一看，不行啊。这的搞个中间人来确认 A 是 A，B 是 B，就像确认你是你妈的儿子一样！！那怎么搞了？你想想，你想要知道你们市的公安局合不合法，那肯定是省公安局说了算。你想要知道省公安局合不合法，那肯定是是国家公安局说了算。所以你只要信任国家公安局，那就可以信任国家公安局认可的下一级公安局，那就可以认可它下面的工具认可的下面的公安局… 中间人也一样，不过我们在通信中引入了一个专用术语 CA(Certificate Authority)证书认证机构。</p>
<h2 id="这个技术的底层原理和关键实现"><a href="#这个技术的底层原理和关键实现" class="headerlink" title="这个技术的底层原理和关键实现"></a>这个技术的底层原理和关键实现</h2><h2 id="已有的实现和它之间的对比"><a href="#已有的实现和它之间的对比" class="headerlink" title="已有的实现和它之间的对比"></a>已有的实现和它之间的对比</h2>]]></content>
      <categories>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>golang编译成Linux环境下的二进制文件</title>
    <url>/2019/03/31/windows-compile-golang-to-linux-running-script/</url>
    <content><![CDATA[<h1 id="golang编译成Linux环境下的二进制文件"><a href="#golang编译成Linux环境下的二进制文件" class="headerlink" title="golang编译成Linux环境下的二进制文件"></a>golang编译成Linux环境下的二进制文件</h1><p>最近需要将golang项目编译成Linux下可执行的脚本，手中只有windows笔记本，服务器上又各种网络限制。<br>于是干脆就再本地打成Linux二进制文件，然后传到服务器直接启动。</p>
<p>在本地上（win10）打开控制台，然后进入到项目根路径。之后设置当前几个值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED&#x3D;0</span><br><span class="line">SET GOOS&#x3D;linux </span><br><span class="line">SET GOARCH&#x3D;amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后使用<code>go build .</code>就可以了。 也算是异常简单。</p>
<p>如果在<code>*nix</code>平台:</p>
<p><code>export CGO_ENABLED=0 &amp;&amp; export GOOS=linux &amp;&amp; export GOARCH=amd64 &amp;&amp; go build .</code></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows使用sshkey连接GitHub</title>
    <url>/2018/07/17/windows-connect-github-with-sshkey/</url>
    <content><![CDATA[<h1 id="Windows使用sshkey连接GitHub"><a href="#Windows使用sshkey连接GitHub" class="headerlink" title="Windows使用sshkey连接GitHub"></a>Windows使用sshkey连接GitHub</h1><p>经常连接github上传东西，经常push的时候需要输入用户名和密码。下面是使用ssh-key免密的方式访问自己的github仓库。</p>
<p>首先在本地生成ssh-key:</p>
<p>进入到<code>~/</code>,用户根目录，查看<code>.ssh</code>文件夹是否有相关的公钥私钥<br>如果没有新生成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@yy.com&quot;</span><br></pre></td></tr></table></figure>

<p>之后再打开<code>~/.ssh/id_rsa.pub</code>拿到公钥内容，复制所有内容；</p>
<p>在github找到设置，add-sshkey，新建一个ssh-key。将内容粘贴进去。</p>
<p>之后再本地的git仓库下使用：</p>
<p><code>ssh -T git@github.com</code></p>
<p>进行验证。</p>
]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>自己用 Java 写一个阻塞队列(二)</title>
    <url>/2021/06/03/write-a-blockqueue-hand-by-hand-2/</url>
    <content><![CDATA[<h1 id="自己用-Java-写一个阻塞队列-二"><a href="#自己用-Java-写一个阻塞队列-二" class="headerlink" title="自己用 Java 写一个阻塞队列(二)"></a>自己用 Java 写一个阻塞队列(二)</h1><p>上一章 <a href="http://chenzhijun.top/2020/05/27/java-thread-lock-condition-blockqueue/">自己用 Java 写一个阻塞队列</a> 我们写了一个初始阻塞队列。过了几天再回头看。嗯，好像看出哪里不对劲了。尝试改了一下。</p>
<h2 id="原先队列实现的问题"><a href="#原先队列实现的问题" class="headerlink" title="原先队列实现的问题"></a>原先队列实现的问题</h2><p>我们说是队列，但是队列的特点是什么？先进先出！在上一个版本中，我们在出队列的时候用的是<code>size</code>值，也就是最后一个位置值。那么想想，我们这算队列么？这是栈啊。这是问题一。<br>另外我们知道 arraylist 其实其底层实现还是数组，那为啥我不直接用数组了？我基本上也不用 list 的功能啊。那这个地方就是第二个可以优化的地方了。<br>在第一个版本中为了运行正常，我把 size 的初始值定为 -1，我有点受不了，不行，这个地方我也要优化。<br>嗯，就优化这三个地方吧。</p>
<h2 id="优化问题-ArrayList"><a href="#优化问题-ArrayList" class="headerlink" title="优化问题 ArrayList"></a>优化问题 ArrayList</h2><p>其实际很简单，把 ArrayList 改为数组 Object[]。原先 add 和 get 的地方直接使用 Object[idx] 代替即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] objects = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">objects[size] = t;</span><br><span class="line">t = objects.[size];</span><br></pre></td></tr></table></figure>

<h2 id="优化入队和出队"><a href="#优化入队和出队" class="headerlink" title="优化入队和出队"></a>优化入队和出队</h2><p>队列的本质应该是先进先出的数据结构。这里用两个 idx 来代替，一个是入队索引，一个是出队索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> enqIdx = <span class="number">0</span>;<span class="comment">//入队的索引号</span></span><br><span class="line"><span class="keyword">int</span> deqIdx = <span class="number">0</span>;<span class="comment">//出队的索引号</span></span><br></pre></td></tr></table></figure>
<p>这里有个问题，就是当索引到了我们的数组大小的时候，要把索引重新开始计数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((enqIdx+<span class="number">1</span>)==objects.length)&#123;</span><br><span class="line">    enqIdx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((deqIdx+<span class="number">1</span>)==objects.length)&#123;</span><br><span class="line">    deqIdx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开始代码"><a href="#开始代码" class="headerlink" title="开始代码"></a>开始代码</h2><span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item15_Lock_Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockedQueue blockedQueue = <span class="keyword">new</span> BlockedQueue();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="string">&quot;producer-&quot;</span> + i) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot;,生产数字:&quot;</span> + blockedQueue.enq(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)));</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span> * <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j++ &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread(<span class="string">&quot;consumer-&quot;</span> + j) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot;,消费数字:&quot;</span> + blockedQueue.deq());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span> * <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockedQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Object[] objects = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;<span class="comment">//容量值，从 0 开始计算。</span></span><br><span class="line">    <span class="keyword">int</span> enqIdx = <span class="number">0</span>;<span class="comment">//入队的索引号</span></span><br><span class="line">    <span class="keyword">int</span> deqIdx = <span class="number">0</span>;<span class="comment">//出队的索引号</span></span><br><span class="line">    <span class="comment">//判断是否满了</span></span><br><span class="line">    Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="comment">//判断是否空的</span></span><br><span class="line">    Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function">Object <span class="title">enq</span><span class="params">(Object t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断队列是否已满</span></span><br><span class="line">            <span class="keyword">while</span> (size == objects.length) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不好意思，满了！！！&quot;</span>);</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            objects[deqIdx] = t;</span><br><span class="line">            <span class="comment">//如果当前入队是最后一个位置，那我们下次就要从 0 开始计算</span></span><br><span class="line">            <span class="keyword">if</span> ((deqIdx + <span class="number">1</span>) == objects.length) &#123;</span><br><span class="line">                deqIdx = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function">Object <span class="title">deq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        Object t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不好意思，空了~~&quot;</span>);</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t = objects[deqIdx];</span><br><span class="line">            <span class="comment">//如果当前已经是最后的一个索引并且已经出队了，那我们下次就要从 0 开始计算</span></span><br><span class="line">            <span class="keyword">if</span> ((deqIdx + <span class="number">1</span>) == objects.length) &#123;</span><br><span class="line">                deqIdx = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，看起来有点样子了。不再像之前的感觉了。 毕竟这个版本是正经的队列的先进先出了。而且看不惯的从 -1 计数也改了。其实有时候多加几个指针索引也挺好的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>自己用 Java 写一个阻塞队列</title>
    <url>/2021/05/27/write-a-blockqueue-hand-by-hand/</url>
    <content><![CDATA[<h1 id="自己用-Java-写一个阻塞队列"><a href="#自己用-Java-写一个阻塞队列" class="headerlink" title="自己用 Java 写一个阻塞队列"></a>自己用 Java 写一个阻塞队列</h1><p>Java 内置了很多数据结构，阻塞队列也有。最近在看 Java 中的并发包：<code>Lock</code>&amp;<code>Condition</code>。然后看到了有人说可以用他们实现阻塞队列，然后我想着，那我是不是也可以写一个阻塞队列？</p>
<h2 id="阻塞队列的特点"><a href="#阻塞队列的特点" class="headerlink" title="阻塞队列的特点"></a>阻塞队列的特点</h2><p>想着就想着先写一个，阻塞队列的特点：</p>
<ol>
<li>一个有限的存数据的队列；</li>
<li>入队的时候要判断队列是否已满；已满的时候，入队的线程要阻塞等待，直到队列有空位，被唤醒继续入队；</li>
<li>出队的时候要判断队列是否为空；为空的时候，获取队列数据的线程阻塞等待，直到队列有新数据的时候被唤醒继续执行；</li>
</ol>
<span id="more"></span>
<p>也就是说我们在对队列操作的时候有两个操作，一个入队，一个出队：</p>
<!-- ![](https://user-gold-cdn.xitu.io/2020/5/27/17256ca4352722e6?w=1108&h=1130&f=png&s=108675) -->
<p><img src="/images/qiniu/2020-05-27-23-39-24.png" alt="2020-05-27-23-39-24"></p>
<p>入队线程：<code>enq thread</code>; 出队线程 <code>deq thread</code>。两者在进行入队和出队的时候都会要先获取全局 lock。默认我们使用的是 size 来存储 list 的容量，入队的时候：size+1；出队的时候 size-1；然后我们用了两个 <code>condition</code> 来告诉当前入队线程和出队线程当前是应该等待，还是可以继续执行。当队列容量不够的时候，入队线程进入 <code>await</code>，否则就入队，并且唤醒出队的线程。出队的线程进入之后先判断队列是否为空，为空的时候就<code>await</code>，然后等地啊被唤醒。大致流程就是这样：</p>
<p>然后就写了下面的比较初级的代码。</p>
<p>v1 版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockedQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断是否满了</span></span><br><span class="line">    Condition full = lock.newCondition();</span><br><span class="line">    <span class="comment">//判断是否空的</span></span><br><span class="line">    Condition empty = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function">T <span class="title">enq</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断队列是否已满</span></span><br><span class="line">            <span class="keyword">while</span> (size &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不好意思，满了！！！&quot;</span>);</span><br><span class="line">                full.await();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(size, t);</span><br><span class="line">            size++;</span><br><span class="line">            empty.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function">T <span class="title">deq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不好意思，空了~~&quot;</span>);</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t = list.get(size);</span><br><span class="line">            size--;</span><br><span class="line">            full.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写了个<code>main</code>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBlockQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockedQueue&lt;Integer&gt; blockedQueue = <span class="keyword">new</span> BlockedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="string">&quot;producer-&quot;</span> + i) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot;,生产数字:&quot;</span> + blockedQueue.enq(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)));</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span> * <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j++ &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread(<span class="string">&quot;consumer-&quot;</span> + j) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot;,消费数字:&quot;</span> + blockedQueue.deq());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span> * <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">            <span class="comment">//System.out.println(blockedQueue.size);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就会发现一个报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;consumer-4&quot; java.lang.IndexOutOfBoundsException: Index: 10, Size: 10</span><br><span class="line">	at java.util.ArrayList.rangeCheck(ArrayList.java:657)</span><br><span class="line">	at java.util.ArrayList.get(ArrayList.java:433)</span><br><span class="line">	at me.chenzhijun.gk_multithread.BlockedQueue.deq(Item15_Lock_Condition.java:105)</span><br><span class="line">	at me.chenzhijun.gk_multithread.Item15_Lock_Condition$2.run(Item15_Lock_Condition.java:46)</span><br><span class="line">java.lang.IndexOutOfBoundsException: Index: 10, Size: 10</span><br><span class="line">	at java.util.ArrayList.rangeCheck(ArrayList.java:657)</span><br><span class="line">	at java.util.ArrayList.get(ArrayList.java:433)</span><br><span class="line">	at me.chenzhijun.gk_multithread.BlockedQueue.deq(Item15_Lock_Condition.java:105)</span><br><span class="line">	at me.chenzhijun.gk_multithread.Item15_Lock_Condition$2.run(Item15_Lock_Condition.java:46)</span><br><span class="line">Exception in thread &quot;consumer-6&quot; java.lang.IndexOutOfBoundsException: Index: 10, Size: 10</span><br><span class="line">	at java.util.ArrayList.rangeCheck(ArrayList.java:657)</span><br><span class="line">	at java.util.ArrayList.get(ArrayList.java:433)</span><br><span class="line">	at me.chenzhijun.gk_multithread.BlockedQueue.deq(Item15_Lock_Condition.java:105)</span><br><span class="line">	at me.chenzhijun.gk_multithread.Item15_Lock_Condition$2.run(Item15_Lock_Condition.java:46)</span><br></pre></td></tr></table></figure>

<p>当时看到这个报错，真的是一脸懵逼，我代码看起来好像没有错误啊。那是哪里的原因，顺着代码一行行读，主要是发现数组越界：10。是不是因为我们<code>size++</code>比如第 10 个 Thread 将 size 加到了 10，但是我们的 arrayList 最大也就为 9。那好像是会出现是问题哦，代码越界判断的习惯真的要注意。然后改了下代码v2版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockedQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//改为了 -1 然后在入队的时候先加1</span></span><br><span class="line">    <span class="keyword">int</span> size = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//判断是否满了</span></span><br><span class="line">    Condition full = lock.newCondition();</span><br><span class="line">    <span class="comment">//判断是否空的</span></span><br><span class="line">    Condition empty = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function">T <span class="title">enq</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断队列是否已满</span></span><br><span class="line">            <span class="keyword">while</span> (size &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不好意思，满了！！！&quot;</span>);</span><br><span class="line">                full.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先加一，再往队列加数据。</span></span><br><span class="line">            size++;</span><br><span class="line">            list.add(size, t);</span><br><span class="line">            empty.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function">T <span class="title">deq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line"></span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不好意思，空了~~&quot;</span>);</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t = list.get(size);</span><br><span class="line">            size--;</span><br><span class="line">            full.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再运行 <code>main</code> 方法就发现正常了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">producer-1,生产数字:8</span><br><span class="line">producer-14,生产数字:7</span><br><span class="line">producer-14,生产数字:6</span><br><span class="line">consumer-7,消费数字:6</span><br><span class="line">consumer-7,消费数字:7</span><br><span class="line">producer-16,生产数字:1</span><br><span class="line">producer-25,生产数字:6</span><br><span class="line">consumer-24,消费数字:6</span><br><span class="line">producer-11,生产数字:5</span><br><span class="line">producer-7,生产数字:6</span><br><span class="line">consumer-17,消费数字:6</span><br><span class="line">consumer-17,消费数字:5</span><br><span class="line">consumer-16,消费数字:1</span><br><span class="line">consumer-21,消费数字:8</span><br><span class="line">不好意思，空了~~</span><br><span class="line">不好意思，空了~~</span><br></pre></td></tr></table></figure>

<p>这样改了之后看起来好像是可以了。但总觉得哪里不对，可又说不出哪里的问题。</p>
]]></content>
  </entry>
  <entry>
    <title>初级排序算法</title>
    <url>/2018/03/09/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="初级排序算法"><a href="#初级排序算法" class="headerlink" title="初级排序算法"></a>初级排序算法</h1><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>首先我们约定几个工具方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    比较a是否小于b，如果a&lt;b返回true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    交换数组中i，j的值的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i]=arr[j];</span><br><span class="line">    arr[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的思想是在一堆无序数字中，首先找出最小的数字，然后与数组第一个元素交换，然后再在剩下的元素中找最小的数字，与第二个交换。这样以此类推，直到整个排序完成。这个就是选择排序。选择排序的思想就是一直选择最小的那个值。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">选择排序，在传入前请判断arr是否为null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(less(arr[j],arr[i]))&#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(arr,i,min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>选择排序的特点，我们可以看到，选择排序每次都是从开始位置，一直到最后的位置，而且每次都需要遍历。所以输入的值关系并没有影响它，比如你输入“1,2,3,4”和“4，1，3,2”所需要的时间是相等的，因为它每次都会起始位置开始比较。数据移动是固定的，跟待比较的值呈线性关系。输入N个值，移动N次。另外有一点，如果一次遍历下来最小值是它本身，那么它还是会和自己做一次交换。<br>选择排序的时间复杂度怎么计算了？我们可以看到比较次数为：(n-1)+(n-2)+(n-3)+(n-4)+…+3+2+1，也就是任意i的位置都需要进行一次交换和（n-i-1）次比较。可以由公式得出为 $ (n-1)+(n-2)+(n-3)+(n-4)+…+3+2+1 ~ N^2/2 $</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>如果你喜欢打牌，那么你肯定就知道插入排序就是怎么样了。比如你抓牌的时候会将抓到的牌按照大小顺序来排列，当你手上的牌是一个已好的顺序时候，下次抓出的牌你会将它插入到相应的位置。这就是插入排序的原理了。在实际中，我们用数组的方式来表示的话，当插入的已有的顺序中间的时间，那么其它位置的牌将需要全部移动一个位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为什么从1开始？，第0个位置相当于抓的第一张牌，做基础对比的。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">// i之前的数据，可以看作是已经排好序了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(less(arr[j],arr[j-<span class="number">1</span>]))&#123;</span><br><span class="line">                exchange(arr,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序如果是以下集中情况将会很有效：</p>
<ol>
<li>数组中每个元素的位置离他们最终元素的位置都不远；</li>
<li>数组中只有几个元素的位置不正确；</li>
<li>一个有序的大数组接一个小数组。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker swarm 入门</title>
    <url>/2017/11/29/docker-swarm-guide/</url>
    <content><![CDATA[<p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。</p>
<h2 id="1-Swarm-认识"><a href="#1-Swarm-认识" class="headerlink" title="1. Swarm 认识"></a>1. Swarm 认识</h2><p>Swarm 是目前 Docker 官方唯一指定（绑定）的集群管理工具。Docker 1.12  内嵌了 swarm mode 集群管理模式。</p>
<p>为了方便演示跨主机网络，我们需要用到一个工具——Docker Machine，这个工具与 Docker Compose、Docker Swarm 并称 Docker 三剑客，下面我们来看看如何安装 Docker Machine：</p>
<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;machine&#x2F;releases&#x2F;download&#x2F;v0.9.0-rc2&#x2F;docker-machine-&#96;uname -s&#96;-&#96;uname -m&#96; &gt;&#x2F;tmp&#x2F;docker-machine &amp;&amp;</span><br><span class="line">    chmod +x &#x2F;tmp&#x2F;docker-machine &amp;&amp;</span><br><span class="line">    sudo cp &#x2F;tmp&#x2F;docker-machine &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine</span><br></pre></td></tr></table></figure>

<p>安装过程和 Docker Compose 非常类似。现在 Docker 三剑客已经全部到齐了。<br>在开始之前，我们需要了解一些基本概念，有关集群的 Docker 命令如下：</p>
<ul>
<li>docker swarm：集群管理，子命令有 init, join,join-token, leave, update</li>
<li>docker node：节点管理，子命令有 demote, inspect,ls, promote, rm, ps, update</li>
<li>docker service：服务管理，子命令有 create, inspect, ps, ls ,rm , scale, update</li>
<li>docker stack/deploy：试验特性，用于多应用部署，等正式版加进来再说。</li>
</ul>
<hr>
<h2 id="2-创建集群"><a href="#2-创建集群" class="headerlink" title="2. 创建集群"></a>2. 创建集群</h2><p>首先使用 Docker Machine 创建一个虚拟机作为 manger 节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox manager1                                    </span><br><span class="line">Running pre-create checks...</span><br><span class="line">(manager1) Unable to get the latest Boot2Docker ISO release version:  Get https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;boot2docker&#x2F;boot2docker&#x2F;releases&#x2F;latest: dial tcp: lookup api.github.com on [::1]:53: server misbehaving</span><br><span class="line">Creating machine...</span><br><span class="line">(manager1) Unable to get the latest Boot2Docker ISO release version:  Get https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;boot2docker&#x2F;boot2docker&#x2F;releases&#x2F;latest: dial tcp: lookup api.github.com on [::1]:53: server misbehaving</span><br><span class="line">(manager1) Copying &#x2F;home&#x2F;zuolan&#x2F;.docker&#x2F;machine&#x2F;cache&#x2F;boot2docker.iso to &#x2F;home&#x2F;zuolan&#x2F;.docker&#x2F;machine&#x2F;machines&#x2F;manager1&#x2F;boot2docker.iso...</span><br><span class="line">(manager1) Creating VirtualBox VM...</span><br><span class="line">(manager1) Creating SSH key...</span><br><span class="line">(manager1) Starting the VM...</span><br><span class="line">(manager1) Check network to re-create if needed...</span><br><span class="line">(manager1) Found a new host-only adapter: &quot;vboxnet0&quot;</span><br><span class="line">(manager1) Waiting for an IP...</span><br><span class="line">Waiting for machine to be running, this may take a few minutes...</span><br><span class="line">Detecting operating system of created instance...</span><br><span class="line">Waiting for SSH to be available...</span><br><span class="line">Detecting the provisioner...</span><br><span class="line">Provisioning with boot2docker...</span><br><span class="line">Copying certs to the local machine directory...</span><br><span class="line">Copying certs to the remote machine...</span><br><span class="line">Setting Docker configuration on the remote daemon...</span><br><span class="line">Checking connection to Docker...</span><br><span class="line">Docker is up and running!</span><br><span class="line">To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env manager1</span><br></pre></td></tr></table></figure>

<p>查看虚拟机的环境变量等信息，包括虚拟机的 IP 地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  docker-machine env manager1</span><br><span class="line">export DOCKER_TLS_VERIFY&#x3D;&quot;1&quot;</span><br><span class="line">export DOCKER_HOST&#x3D;&quot;tcp:&#x2F;&#x2F;192.168.99.100:2376&quot;</span><br><span class="line">export DOCKER_CERT_PATH&#x3D;&quot;&#x2F;home&#x2F;zuolan&#x2F;.docker&#x2F;machine&#x2F;machines&#x2F;manager1&quot;</span><br><span class="line">export DOCKER_MACHINE_NAME&#x3D;&quot;manager1&quot;</span><br><span class="line"># Run this command to configure your shell: </span><br><span class="line"># eval $(docker-machine env manager1)</span><br></pre></td></tr></table></figure>

<p>然后再创建一个节点作为 work 节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox worker1</span><br></pre></td></tr></table></figure>

<p>现在我们有了两个虚拟主机，使用 Machine 的命令可以查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ls                             </span><br><span class="line">NAME     ACTIVE   DRIVER       STATE    URL                        SWARM  DOCKER   ERRORS</span><br><span class="line">manager1   -      virtualbox   Running  tcp:&#x2F;&#x2F;192.168.99.100:2376         v1.12.3   </span><br><span class="line">worker1    -      virtualbox   Running  tcp:&#x2F;&#x2F;192.168.99.101:2376         v1.12.3</span><br></pre></td></tr></table></figure>

<p>但是目前这两台虚拟主机并没有什么联系，为了把它们联系起来，我们需要 Swarm 登场了。<br>因为我们使用的是 Docker Machine 创建的虚拟机，因此可以使用 docker-machine ssh 命令来操作虚拟机，在实际生产环境中，并不需要像下面那样操作，只需要执行 docker swarm 即可。</p>
<p>把 manager1 加入集群：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm init --listen-addr 192.168.99.100:2377 --advertise-addr 192.168.99.100</span><br><span class="line">Swarm initialized: current node (23lkbq7uovqsg550qfzup59t6) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.</span><br></pre></td></tr></table></figure>

<p>用 –listen-addr 指定监听的 ip 与端口，实际的 Swarm 命令格式如下，本例使用 Docker Machine 来连接虚拟机而已：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker swarm init --listen-addr &lt;MANAGER-IP&gt;:&lt;PORT&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，再把 work1 加入集群中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh worker1 docker swarm join --token \</span><br><span class="line">    SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure>

<p>上面 join 命令中可以添加 –listen-addr $WORKER1_IP:2377 作为监听准备，因为有时候可能会遇到把一个 work 节点提升为 manger 节点的可能，当然本例子没有这个打算就不添加这个参数了。</p>
<blockquote>
<p>注意：如果你在新建集群时遇到双网卡情况，可以指定使用哪个 IP，例如上面的例子会有可能遇到下面的错误。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm init --listen-addr $MANAGER1_IP:2377</span><br><span class="line">Error response from daemon: could not choose an IP address to advertise since this system has multiple addresses on different interfaces (10.0.2.15 on eth0 and 192.168.99.100 on eth1) - specify one with --advertise-addr</span><br><span class="line">exit status 1</span><br></pre></td></tr></table></figure>

<p>发生错误的原因是因为有两个 IP 地址，而 Swarm 不知道用户想使用哪个，因此要指定 IP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm init --advertise-addr 192.168.99.100 --listen-addr 192.168.99.100:2377 </span><br><span class="line">Swarm initialized: current node (ahvwxicunjd0z8g0eeosjztjx) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.</span><br></pre></td></tr></table></figure>

<p>集群初始化成功。</p>
<p>现在我们新建了一个有两个节点的“集群”，现在进入其中一个管理节点使用 docker node 命令来查看节点信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker node ls</span><br><span class="line">ID                       HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS</span><br><span class="line">23lkbq7uovqsg550qfzup59t6 *  manager1    Ready      Active         Leader</span><br><span class="line">dqb3fim8zvcob8sycri3hy98a    worker1     Ready      Active</span><br></pre></td></tr></table></figure>

<p>现在每个节点都归属于 Swarm，并都处在了待机状态。Manager1 是领导者，work1 是工人。</p>
<p>现在，我们继续新建虚拟机 manger2、worker2、worker3，现在已经有五个虚拟机了，使用 docker-machine ls 来查看虚拟机：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME     ACTIVE    DRIVER       STATE     URL                         SWARM   DOCKER    ERRORS</span><br><span class="line">manager1   -       virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.100:2376           v1.12.3   </span><br><span class="line">manager2   -       virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.105:2376           v1.12.3   </span><br><span class="line">worker1    -       virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.102:2376           v1.12.3   </span><br><span class="line">worker2    -       virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.103:2376           v1.12.3   </span><br><span class="line">worker3    -       virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.104:2376           v1.12.3</span><br></pre></td></tr></table></figure>

<p>然后我们把剩余的虚拟机也加到集群中。</p>
<ul>
<li><p>添加 worker2 到集群中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh worker2 docker swarm join \</span><br><span class="line">  --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">  192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure></li>
<li><p>添加 worker3 到集群中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh worker3 docker swarm join \</span><br><span class="line">  --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">  192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure></li>
<li><p>添加 manager2 到集群中：<br>先从 manager1 中获取 manager 的 token：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm join-token manager</span><br><span class="line">To add a manager to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">  docker swarm join \</span><br><span class="line">  --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</span><br><span class="line">192.168.99.100:2377</span><br></pre></td></tr></table></figure>

<p>然后添加 manager2 到集群中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh manager2 docker swarm join \</span><br><span class="line">  --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</span><br><span class="line">  192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure></li>
</ul>
<p>现在再来查看集群信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh manager2 docker node ls</span><br><span class="line">ID                            HOSTNAME   STATUS   AVAILABILITY   MANAGER STATUS</span><br><span class="line">16w80jnqy2k30yez4wbbaz1l8     worker1     Ready     Active        </span><br><span class="line">2gkwhzakejj72n5xoxruet71z     worker2     Ready     Active        </span><br><span class="line">35kutfyn1ratch55fn7j3fs4x     worker3     Ready     Active        </span><br><span class="line">a9r21g5iq1u6h31myprfwl8ln *   manager2    Ready     Active        Reachable</span><br><span class="line">dpo7snxbz2a0dxvx6mf19p35z     manager1    Ready     Active        Leader</span><br></pre></td></tr></table></figure>

<h2 id="3-建立跨主机网络"><a href="#3-建立跨主机网络" class="headerlink" title="3. 建立跨主机网络"></a>3. 建立跨主机网络</h2><p>为了演示更清晰，下面我们把宿主机也加入到集群之中，这样我们使用 Docker 命令操作会清晰很多。<br>直接在本地执行加入集群命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker swarm join \           </span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure>

<p>现在我们有三台 manager，三台 worker。其中一台是宿主机，五台虚拟机。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                          HOSTNAME    STATUS    AVAILABILITY  MANAGER STATUS</span><br><span class="line">6z2rpk1t4xucffzlr2rpqb8u3    worker3     Ready     Active        </span><br><span class="line">7qbr0xd747qena4awx8bx101s *  user-pc     Ready     Active         Reachable</span><br><span class="line">9v93sav79jqrg0c7051rcxxev    manager2    Ready     Active         Reachable</span><br><span class="line">a1ner3zxj3ubsiw4l3p28wrkj    worker1     Ready     Active        </span><br><span class="line">a5w7h8j83i11qqi4vlu948mad    worker2     Ready     Active        </span><br><span class="line">d4h7vuekklpd6189fcudpfy18    manager1    Ready     Active          Leader</span><br></pre></td></tr></table></figure>

<p>查看网络状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID         NAME            DRIVER          SCOPE</span><br><span class="line">764ff31881e5        bridge          bridge          local                  </span><br><span class="line">fbd9a977aa03        host            host            local               </span><br><span class="line">6p6xlousvsy2        ingress         overlay         swarm            </span><br><span class="line">e81af24d643d        none            null            local</span><br></pre></td></tr></table></figure>

<p>可以看到在 swarm 上默认已有一个名为 ingress 的 overlay 网络, 默认在 swarm 里使用，本例子中会创建一个新的 overlay 网络。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker network create --driver overlay swarm_test</span><br><span class="line">4dm8cy9y5delvs5vd0ghdd89s</span><br><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID         NAME                DRIVER              SCOPE</span><br><span class="line">764ff31881e5        bridge              bridge              local</span><br><span class="line">fbd9a977aa03        host                host                local</span><br><span class="line">6p6xlousvsy2        ingress             overlay             swarm</span><br><span class="line">e81af24d643d        none                null                local</span><br><span class="line">4dm8cy9y5del        swarm_test          overlay             swarm</span><br></pre></td></tr></table></figure>

<p>这样一个跨主机网络就搭建好了，但是现在这个网络只是处于待机状态，下一小节我们会在这个网络上部署应用。</p>
<h2 id="4-在跨主机网络上部署应用"><a href="#4-在跨主机网络上部署应用" class="headerlink" title="4. 在跨主机网络上部署应用"></a>4. 在跨主机网络上部署应用</h2><p>首先我们上面创建的节点都是没有镜像的，因此我们要逐一 pull 镜像到节点中，这里我们使用前面搭建的私有仓库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker pull reg.example.com&#x2F;library&#x2F;nginx:alpine     </span><br><span class="line">alpine: Pulling from library&#x2F;nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com&#x2F;library&#x2F;nginx:alpine</span><br><span class="line">$ docker-machine ssh manager2 docker pull reg.example.com&#x2F;library&#x2F;nginx:alpine</span><br><span class="line">alpine: Pulling from library&#x2F;nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com&#x2F;library&#x2F;nginx:alpine</span><br><span class="line">$ docker-machine ssh worker1 docker pull reg.example.com&#x2F;library&#x2F;nginx:alpine </span><br><span class="line">alpine: Pulling from library&#x2F;nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com&#x2F;library&#x2F;nginx:alpine</span><br><span class="line">$ docker-machine ssh worker2 docker pull reg.example.com&#x2F;library&#x2F;nginx:alpine</span><br><span class="line">alpine: Pulling from library&#x2F;nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com&#x2F;library&#x2F;nginx:alpine</span><br><span class="line">$ docker-machine ssh worker3 docker pull reg.example.com&#x2F;library&#x2F;nginx:alpine</span><br><span class="line">alpine: Pulling from library&#x2F;nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com&#x2F;library&#x2F;nginx:alpine</span><br></pre></td></tr></table></figure>

<p>上面使用 docker pull 分别在五个虚拟机节点拉取 nginx:alpine 镜像。接下来我们要在五个节点部署一组 Nginx 服务。</p>
<p>部署的服务使用 swarm_test 跨主机网络。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service create --replicas 2 --name helloworld --network&#x3D;swarm_test nginx:alpine</span><br><span class="line">5gz0h2s5agh2d2libvzq6bhgs</span><br></pre></td></tr></table></figure>

<p>查看服务状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service ls</span><br><span class="line">ID            NAME        REPLICAS  IMAGE         COMMAND</span><br><span class="line">5gz0h2s5agh2  helloworld  0&#x2F;2       nginx:alpine</span><br></pre></td></tr></table></figure>

<p>查看 helloworld 服务详情（为了方便阅读，已调整输出内容）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID          NAME          IMAGE         NODE      DESIRED STATE   CURRENT STATE              ERROR</span><br><span class="line">ay081uome3   helloworld.1  nginx:alpine  manager1  Running         Preparing 2 seconds ago  </span><br><span class="line">16cvore0c96  helloworld.2  nginx:alpine  worker2   Running         Preparing 2 seconds ago</span><br></pre></td></tr></table></figure>

<p>可以看到两个实例分别运行在两个节点上。</p>
<p>进入两个节点，查看服务状态（为了方便阅读，已调整输出内容）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND         CREATED        STATUS         PORTS            NAMES</span><br><span class="line">119f787622c2   nginx:alpine  &quot;nginx -g ...&quot;   4 minutes ago  Up 4 minutes   80&#x2F;tcp, 443&#x2F;tcp  hello ...</span><br><span class="line">$ docker-machine ssh worker2 docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND         CREATED         STATUS        PORTS             NAMES</span><br><span class="line">5db707401a06   nginx:alpine  &quot;nginx -g ...&quot;   4 minutes ago   Up 4 minutes  80&#x2F;tcp, 443&#x2F;tcp   hello ...</span><br></pre></td></tr></table></figure>

<p>上面输出做了调整，实际的 NAMES 值为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helloworld.1.ay081uome3eejeg4mspa8pdlx</span><br><span class="line">helloworld.2.16cvore0c96rby1vp0sny3mvt</span><br></pre></td></tr></table></figure>

<p>记住上面这两个实例的名称。现在我们来看这两个跨主机的容器是否能互通：<br>首先使用 Machine 进入 manager1 节点，然后使用 docker exec -i 命令进入 helloworld.1 容器中 ping 运行在 worker2 节点的 helloworld.2 容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-machine ssh manager1 docker <span class="built_in">exec</span> -i helloworld.1.ay081uome3eejeg4mspa8pdlx \</span></span><br><span class="line"><span class="bash">    ping helloworld.2.16cvore0c96rby1vp0sny3mvt</span></span><br><span class="line">PING helloworld.2.16cvore0c96rby1vp0sny3mvt (10.0.0.4): 56 data bytes</span><br><span class="line">64 bytes from 10.0.0.4: seq=0 ttl=64 time=0.591 ms</span><br><span class="line">64 bytes from 10.0.0.4: seq=1 ttl=64 time=0.594 ms</span><br><span class="line">64 bytes from 10.0.0.4: seq=2 ttl=64 time=0.624 ms</span><br><span class="line">64 bytes from 10.0.0.4: seq=3 ttl=64 time=0.612 ms</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>然后使用 Machine 进入 worker2 节点，然后使用 docker exec -i 命令进入 helloworld.2 容器中 ping 运行在 manager1 节点的 helloworld.1 容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-machine ssh worker2 docker <span class="built_in">exec</span> -i helloworld.2.16cvore0c96rby1vp0sny3mvt \</span></span><br><span class="line"><span class="bash">    ping helloworld.1.ay081uome3eejeg4mspa8pdlx</span> </span><br><span class="line">PING helloworld.1.ay081uome3eejeg4mspa8pdlx (10.0.0.3): 56 data bytes</span><br><span class="line">64 bytes from 10.0.0.3: seq=0 ttl=64 time=0.466 ms</span><br><span class="line">64 bytes from 10.0.0.3: seq=1 ttl=64 time=0.465 ms</span><br><span class="line">64 bytes from 10.0.0.3: seq=2 ttl=64 time=0.548 ms</span><br><span class="line">64 bytes from 10.0.0.3: seq=3 ttl=64 time=0.689 ms</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>可以看到这两个跨主机的服务集群里面各个容器是可以互相连接的。</p>
<p>为了体现 Swarm 集群的优势，我们可以使用虚拟机的 ping 命令来测试对方虚拟机内的容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh worker2 ping helloworld.1.ay081uome3eejeg4mspa8pdlx</span><br><span class="line">PING helloworld.1.ay081uome3eejeg4mspa8pdlx (221.179.46.190): 56 data bytes</span><br><span class="line">64 bytes from 221.179.46.190: seq&#x3D;0 ttl&#x3D;63 time&#x3D;48.651 ms</span><br><span class="line">64 bytes from 221.179.46.190: seq&#x3D;1 ttl&#x3D;63 time&#x3D;63.239 ms</span><br><span class="line">64 bytes from 221.179.46.190: seq&#x3D;2 ttl&#x3D;63 time&#x3D;47.686 ms</span><br><span class="line">64 bytes from 221.179.46.190: seq&#x3D;3 ttl&#x3D;63 time&#x3D;61.232 ms</span><br><span class="line">^C</span><br><span class="line">$ docker-machine ssh manager1 ping helloworld.2.16cvore0c96rby1vp0sny3mvt</span><br><span class="line">PING helloworld.2.16cvore0c96rby1vp0sny3mvt (221.179.46.194): 56 data bytes</span><br><span class="line">64 bytes from 221.179.46.194: seq&#x3D;0 ttl&#x3D;63 time&#x3D;30.150 ms</span><br><span class="line">64 bytes from 221.179.46.194: seq&#x3D;1 ttl&#x3D;63 time&#x3D;54.455 ms</span><br><span class="line">64 bytes from 221.179.46.194: seq&#x3D;2 ttl&#x3D;63 time&#x3D;73.862 ms</span><br><span class="line">64 bytes from 221.179.46.194: seq&#x3D;3 ttl&#x3D;63 time&#x3D;53.171 ms</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>上面我们使用了虚拟机内部的 ping 去测试容器的延迟，可以看到延迟明显比集群内部的 ping 值要高。</p>
<h2 id="5-Swarm-集群负载"><a href="#5-Swarm-集群负载" class="headerlink" title="5. Swarm 集群负载"></a>5. Swarm 集群负载</h2><p>现在我们已经学会了 Swarm 集群的部署方法，现在来搭建一个可访问的 Nginx 集群吧。体验最新版的 Swarm 所提供的自动服务发现与集群负载功能。<br>首先删掉上一节我们启动的 helloworld 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service rm helloworld                                 </span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>

<p>然后在新建一个服务，提供端口映射参数，使得外界可以访问这些 Nginx 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service create --replicas 2 --name helloworld -p 7080:80 --network&#x3D;swarm_test nginx:alpine</span><br><span class="line">9gfziifbii7a6zdqt56kocyun</span><br></pre></td></tr></table></figure>

<p>查看服务运行状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service ls                                                                                </span><br><span class="line">ID           NAME         REPLICAS     IMAGE           COMMAND</span><br><span class="line">9gfziifbii7a  helloworld     2&#x2F;2        nginx:alpine</span><br></pre></td></tr></table></figure>

<p>不知你有没有发现，虽然我们使用 –replicas 参数的值都是一样的，但是上一节中获取服务状态时，REPLICAS 返回的是 0/2，现在的 REPLICAS 返回的是 2/2。<br>同样使用 docker service ps 查看服务详细状态时（下面输出已经手动调整为更易读的格式），可以看到实例的 CURRENT STATE 中是 Running 状态的，而上一节中的 CURRENT STATE 中全部是处于 Preparing 状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID          NAME      IMAGE     NODE    DESIRED STATE   CURRENT STATE    ERROR</span><br><span class="line">9ikr3agyi...   helloworld.1  nginx:alpine  user-pc    Running         Running 13 seconds ago  </span><br><span class="line">7acmhj0u...   helloworld.2  nginx:alpine  worker2    Running         Running 6 seconds ago</span><br></pre></td></tr></table></figure>

<p>这就涉及到 Swarm 内置的发现机制了，目前 Docker 1.12 中 Swarm 已经内置了服务发现工具，我们不再需要像以前使用 Etcd 或者 Consul 这些工具来配置服务发现。对于一个容器来说如果没有外部通信但又是运行中的状态会被服务发现工具认为是 Preparing 状态，本小节例子中因为映射了端口，因此有了 Running 状态。<br>现在我们来看 Swarm 另一个有趣的功能，当我们杀死其中一个节点时，会发生什么。<br>首先 kill 掉 worker2 的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh worker2 docker kill helloworld.2.7acmhj0udzusv1d7lu2tbuhu4</span><br><span class="line">helloworld.2.7acmhj0udzusv1d7lu2tbuhu4</span><br></pre></td></tr></table></figure>

<p>稍等几秒，再来看服务状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID         NAME          IMAGE     NODE   DESIRED STATE  CURRENT STATE   ERROR</span><br><span class="line">9ikr3agyi...  helloworld.1     nginx:alpine  zuolan-pc  Running       Running 19 minutes ago  </span><br><span class="line">8f866igpl...  helloworld.2     nginx:alpine  manager1  Running       Running 4 seconds ago   </span><br><span class="line">7acmhj0u...   \_ helloworld.2  nginx:alpine  worker2   Shutdown       Failed 11 seconds ago  ...exit...</span><br><span class="line">$ docker service ls           </span><br><span class="line">ID            NAME        REPLICAS  IMAGE         COMMAND</span><br><span class="line">9gfziifbii7a  helloworld  2&#x2F;2       nginx:alpine</span><br></pre></td></tr></table></figure>

<p>可以看到即使我们 kill 掉其中一个实例，Swarm 也会迅速把停止的容器撤下来，同时在节点中启动一个新的实例顶上来。这样服务依旧还是两个实例在运行。<br>此时如果你想添加更多实例可以使用 scale 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service scale helloworld&#x3D;3</span><br><span class="line">helloworld scaled to 3</span><br></pre></td></tr></table></figure>

<p>查看服务详情，可以看到有三个实例启动了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID         NAME        IMAGE      NODE   DESIRED STATE  CURRENT STATE    ERROR</span><br><span class="line">9ikr3agyi...  helloworld.1    nginx:alpine  user-pc   Running        Running 30 minutes ago  8f866igpl...  helloworld.2    nginx:alpine  manager1  Running        Running 11 minutes ago  7acmhj0u...  \_ helloworld.2  nginx:alpine  worker2   Shutdown       Failed 11 minutes ago   exit137</span><br><span class="line">1vexr1jm...  helloworld.3    nginx:alpine   worker2   Running       Running 4 seconds ago</span><br></pre></td></tr></table></figure>

<p>现在如果想减少实例数量，一样可以使用 scale 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service scale helloworld&#x3D;2</span><br><span class="line">helloworld scaled to 2</span><br></pre></td></tr></table></figure>

<hr>
<p>至此，Swarm的主要用法都已经介绍完了，主要讲述了 Swarm 集群网络的创建与部署。介绍了 Swarm 的常规应用，包括 Swarm 的服务发现、负载均衡等，然后使用 Swarm 来配置跨主机容器网络，并在上面部署应用。</p>
<blockquote>
<p>简书上看到这篇文章，简直太棒了。原文：<a href="http://www.jianshu.com/p/9eb9995884a5">左蓝 - Docker Swarm 入门</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Harbor  镜像仓库安装与 Helm Chart 管理</title>
    <url>/2022/12/26/harbor-install-and-trouble-shooting/</url>
    <content><![CDATA[<h1 id="Harbor-镜像仓库安装与-Helm-Chart-管理"><a href="#Harbor-镜像仓库安装与-Helm-Chart-管理" class="headerlink" title="Harbor  镜像仓库安装与 Helm Chart 管理"></a>Harbor  镜像仓库安装与 Helm Chart 管理</h1><p><a href="https://goharbor.io/">Harbor</a> 是一款非常优秀的企业级开源镜像仓库管理器。Harbor 是基于 Docker Registry之上带有用户权限控制，镜像扫描，镜像签名的款工具。用起来很方便，我们公司目前在测试和生产都在使用。从去年 10 月到今天，除去一次 ceph 集群扩容，没有发生一次事故，一直运行很稳定；本文将记录一下我们的使用方式和遇到的一些问题解决方式。</p>
<h2 id="Harbor-资源准备"><a href="#Harbor-资源准备" class="headerlink" title="Harbor 资源准备"></a>Harbor 资源准备</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Harbor 1.7.6 版本</span><br><span class="line">Redis 4.0</span><br><span class="line">Postgres 10.6</span><br><span class="line">Docker 1.13.1</span><br><span class="line">docker-compose 1.18.0</span><br><span class="line">Ceph 12</span><br><span class="line"></span><br><span class="line">haproxy 机器 2 台</span><br><span class="line">VIP 1 个</span><br><span class="line">Harbor 主机 2 台</span><br></pre></td></tr></table></figure>

<p>公司目前的 harbor 是基于 1.76 搭建的高可用方案，证书的问题，我们是公网使用第三方证书。内网使用自签名的证书；在我这里，我在 harbor 的搭建中采用的是内部 http，外部挂 F5。架构图如下：</p>
<p><img src="/images/qiniu/2020-04-26-21-15-43.png" alt="2020-04-26-21-15-43"></p>
<p>生产上我们用 F5 替代 Haproxy。</p>
<p>我们在 Haproxy/F5 层将 https 转成 http 再转发给内部 harbor。</p>
<span id="more"></span>
<h3 id="下载-harbor-并进行配置"><a href="#下载-harbor-并进行配置" class="headerlink" title="下载 harbor 并进行配置"></a>下载 harbor 并进行配置</h3><p>直接去github release 下载 1.7.6 的版本（现在最新为 1.10）。下载之后解压，修改里面<code>harbor.cfg</code>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Configuration file of Harbor</span><br><span class="line"></span><br><span class="line">#This attribute is for migrator to detect the version of the .cfg file, DO NOT MODIFY!</span><br><span class="line">_version &#x3D; 1.7.0</span><br><span class="line">#The IP address or hostname to access admin UI and registry service.</span><br><span class="line">#DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.</span><br><span class="line">#DO NOT comment out this line, modify the value of &quot;hostname&quot; directly, or the installation will fail.</span><br><span class="line">hostname &#x3D; harbor.chenzhijun.top</span><br><span class="line"></span><br><span class="line">#The protocol for accessing the UI and token&#x2F;notification service, by default it is http.</span><br><span class="line">#It can be set to https if ssl is enabled on nginx.</span><br><span class="line">ui_url_protocol &#x3D; http</span><br><span class="line"></span><br><span class="line">#Maximum number of job workers in job service</span><br><span class="line">max_job_workers &#x3D; 10</span><br><span class="line"></span><br><span class="line">#Determine whether or not to generate certificate for the registry&#39;s token.</span><br><span class="line">#If the value is on, the prepare script creates new root cert and private key</span><br><span class="line">#for generating token to access the registry. If the value is off the default key&#x2F;cert will be used.</span><br><span class="line">#This flag also controls the creation of the notary signer&#39;s cert.</span><br><span class="line">#这里我选择的是 off，开 notary 的话必须指定https，如果不开 notary 的话，可以不用管。</span><br><span class="line">customize_crt &#x3D; off</span><br><span class="line"></span><br><span class="line">#The path of cert and key files for nginx, they are applied only the protocol is set to https</span><br><span class="line">ssl_cert &#x3D; &#x2F;data&#x2F;cert&#x2F;server.crt</span><br><span class="line">ssl_cert_key &#x3D; &#x2F;data&#x2F;cert&#x2F;server.key</span><br><span class="line"></span><br><span class="line">#The path of secretkey storage</span><br><span class="line">secretkey_path &#x3D; &#x2F;data</span><br><span class="line"></span><br><span class="line">#Admiral&#39;s url, comment this attribute, or set its value to NA when Harbor is standalone</span><br><span class="line">admiral_url &#x3D; NA</span><br><span class="line"></span><br><span class="line">#Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated.</span><br><span class="line">log_rotate_count &#x3D; 50</span><br><span class="line">#Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes.</span><br><span class="line">#If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G</span><br><span class="line">#are all valid.</span><br><span class="line">log_rotate_size &#x3D; 200M</span><br><span class="line"></span><br><span class="line">#Config http proxy for Clair, e.g. http:&#x2F;&#x2F;my.proxy.com:3128</span><br><span class="line">#Clair doesn&#39;t need to connect to harbor internal components via http proxy.</span><br><span class="line">http_proxy &#x3D;</span><br><span class="line">https_proxy &#x3D;</span><br><span class="line">no_proxy &#x3D; 127.0.0.1,localhost,core,registry</span><br><span class="line"></span><br><span class="line">#NOTES: The properties between BEGIN INITIAL PROPERTIES and END INITIAL PROPERTIES</span><br><span class="line">#only take effect in the first boot, the subsequent changes of these properties</span><br><span class="line">#should be performed on web ui</span><br><span class="line"></span><br><span class="line">#************************BEGIN INITIAL PROPERTIES************************</span><br><span class="line"></span><br><span class="line">#Email account settings for sending out password resetting emails.</span><br><span class="line"></span><br><span class="line">#Email server uses the given username and password to authenticate on TLS connections to host and act as identity.</span><br><span class="line">#Identity left blank to act as username.</span><br><span class="line">email_identity &#x3D;</span><br><span class="line"></span><br><span class="line">email_server &#x3D; smtp.mydomain.com</span><br><span class="line">email_server_port &#x3D; 25</span><br><span class="line">email_username &#x3D; sample_admin@mydomain.com</span><br><span class="line">email_password &#x3D; abc</span><br><span class="line">email_from &#x3D; admin &lt;sample_admin@mydomain.com&gt;</span><br><span class="line">email_ssl &#x3D; false</span><br><span class="line">email_insecure &#x3D; false</span><br><span class="line"></span><br><span class="line">##The initial password of Harbor admin, only works for the first time when Harbor starts.</span><br><span class="line">#It has no effect after the first launch of Harbor.</span><br><span class="line">#Change the admin password from UI after launching Harbor.</span><br><span class="line">harbor_admin_password &#x3D; Harbor12345</span><br><span class="line"></span><br><span class="line">##By default the auth mode is db_auth, i.e. the credentials are stored in a local database.</span><br><span class="line">#Set it to ldap_auth if you want to verify a user&#39;s credentials against an LDAP server.</span><br><span class="line">auth_mode &#x3D; db_auth</span><br><span class="line"></span><br><span class="line">#The url for an ldap endpoint.</span><br><span class="line">ldap_url &#x3D; ldaps:&#x2F;&#x2F;ldap.mydomain.com</span><br><span class="line"></span><br><span class="line">#A user&#39;s DN who has the permission to search the LDAP&#x2F;AD server.</span><br><span class="line">#If your LDAP&#x2F;AD server does not support anonymous search, you should configure this DN and ldap_search_pwd.</span><br><span class="line">#ldap_searchdn &#x3D; uid&#x3D;searchuser,ou&#x3D;people,dc&#x3D;mydomain,dc&#x3D;com</span><br><span class="line"></span><br><span class="line">#the password of the ldap_searchdn</span><br><span class="line">#ldap_search_pwd &#x3D; password</span><br><span class="line"></span><br><span class="line">#The base DN from which to look up a user in LDAP&#x2F;AD</span><br><span class="line">ldap_basedn &#x3D; ou&#x3D;people,dc&#x3D;mydomain,dc&#x3D;com</span><br><span class="line"></span><br><span class="line">#Search filter for LDAP&#x2F;AD, make sure the syntax of the filter is correct.</span><br><span class="line">#ldap_filter &#x3D; (objectClass&#x3D;person)</span><br><span class="line"></span><br><span class="line"># The attribute used in a search to match a user, it could be uid, cn, email, sAMAccountName or other attributes depending on your LDAP&#x2F;AD</span><br><span class="line">ldap_uid &#x3D; uid</span><br><span class="line"></span><br><span class="line">#the scope to search for users, 0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE</span><br><span class="line">ldap_scope &#x3D; 2</span><br><span class="line"></span><br><span class="line">#Timeout (in seconds)  when connecting to an LDAP Server. The default value (and most reasonable) is 5 seconds.</span><br><span class="line">ldap_timeout &#x3D; 5</span><br><span class="line"></span><br><span class="line">#Verify certificate from LDAP server</span><br><span class="line">ldap_verify_cert &#x3D; true</span><br><span class="line"></span><br><span class="line">#The base dn from which to lookup a group in LDAP&#x2F;AD</span><br><span class="line">ldap_group_basedn &#x3D; ou&#x3D;group,dc&#x3D;mydomain,dc&#x3D;com</span><br><span class="line"></span><br><span class="line">#filter to search LDAP&#x2F;AD group</span><br><span class="line">ldap_group_filter &#x3D; objectclass&#x3D;group</span><br><span class="line"></span><br><span class="line">#The attribute used to name a LDAP&#x2F;AD group, it could be cn, name</span><br><span class="line">ldap_group_gid &#x3D; cn</span><br><span class="line"></span><br><span class="line">#The scope to search for ldap groups. 0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE</span><br><span class="line">ldap_group_scope &#x3D; 2</span><br><span class="line"></span><br><span class="line">#Turn on or off the self-registration feature</span><br><span class="line"># 是否允许自注册</span><br><span class="line">self_registration &#x3D; on</span><br><span class="line"></span><br><span class="line">#The expiration time (in minute) of token created by token service, default is 30 minutes</span><br><span class="line">token_expiration &#x3D; 30</span><br><span class="line"></span><br><span class="line">#The flag to control what users have permission to create projects</span><br><span class="line">#The default value &quot;everyone&quot; allows everyone to creates a project.</span><br><span class="line">#Set to &quot;adminonly&quot; so that only admin user can create project.</span><br><span class="line">project_creation_restriction &#x3D; everyone</span><br><span class="line"></span><br><span class="line">#************************END INITIAL PROPERTIES************************</span><br><span class="line"></span><br><span class="line">#######Harbor DB configuration section#######</span><br><span class="line"></span><br><span class="line">#The address of the Harbor database. Only need to change when using external db.</span><br><span class="line">#db的主机</span><br><span class="line">db_host &#x3D; 172.88.14.88</span><br><span class="line"></span><br><span class="line">#The password for the root user of Harbor DB. Change this before any production use.</span><br><span class="line">db_password &#x3D; 123456</span><br><span class="line"></span><br><span class="line">#The port of Harbor database host</span><br><span class="line">db_port &#x3D; 5432</span><br><span class="line"></span><br><span class="line">#The user name of Harbor database</span><br><span class="line">db_user &#x3D; postgres</span><br><span class="line"></span><br><span class="line">##### End of Harbor DB configuration#######</span><br><span class="line"></span><br><span class="line">##########Redis server configuration.############</span><br><span class="line"></span><br><span class="line">#Redis connection address</span><br><span class="line">redis_host &#x3D; 172.88.14.88</span><br><span class="line"></span><br><span class="line">#Redis connection port</span><br><span class="line">redis_port &#x3D; 6379</span><br><span class="line"></span><br><span class="line">#Redis connection password</span><br><span class="line">redis_password &#x3D;</span><br><span class="line"></span><br><span class="line">#Redis connection db index</span><br><span class="line">#db_index 1,2,3 is for registry, jobservice and chartmuseum.</span><br><span class="line">#db_index 0 is for UI, it&#39;s unchangeable</span><br><span class="line">redis_db_index &#x3D; 1,2,3</span><br><span class="line"></span><br><span class="line">########## End of Redis server configuration ############</span><br><span class="line"></span><br><span class="line">##########Clair DB configuration############</span><br><span class="line"></span><br><span class="line">#Clair DB host address. Only change it when using an exteral DB.</span><br><span class="line"></span><br><span class="line">clair_db_host &#x3D; 172.88.14.88</span><br><span class="line">#The password of the Clair&#39;s postgres database. Only effective when Harbor is deployed with Clair.</span><br><span class="line">#Please update it before deployment. Subsequent update will cause Clair&#39;s API server and Harbor unable to access Clair&#39;s database.</span><br><span class="line">clair_db_password &#x3D; 123456</span><br><span class="line">#Clair DB connect port</span><br><span class="line">clair_db_port &#x3D; 5432</span><br><span class="line">#Clair DB username</span><br><span class="line">clair_db_username &#x3D; postgres</span><br><span class="line">#Clair default database</span><br><span class="line">clair_db &#x3D; postgres</span><br><span class="line"></span><br><span class="line">#The interval of clair updaters, the unit is hour, set to 0 to disable the updaters.</span><br><span class="line">clair_updaters_interval &#x3D; 12</span><br><span class="line"></span><br><span class="line">##########End of Clair DB configuration############</span><br><span class="line"></span><br><span class="line">#The following attributes only need to be set when auth mode is uaa_auth</span><br><span class="line">uaa_endpoint &#x3D; uaa.mydomain.org</span><br><span class="line">uaa_clientid &#x3D; id</span><br><span class="line">uaa_clientsecret &#x3D; secret</span><br><span class="line">uaa_verify_cert &#x3D; true</span><br><span class="line">uaa_ca_cert &#x3D; &#x2F;path&#x2F;to&#x2F;ca.pem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Harbor Storage settings ###</span><br><span class="line">#Please be aware that the following storage settings will be applied to both docker registry and helm chart repository.</span><br><span class="line">#registry_storage_provider can be: filesystem, s3, gcs, azure, etc.</span><br><span class="line">#registry_storage_provider_name &#x3D; filesystem</span><br><span class="line">registry_storage_provider_name &#x3D; s3</span><br><span class="line"></span><br><span class="line">#registry_storage_provider_config is a comma separated &quot;key: value&quot; pairs, e.g. &quot;key1: value, key2: value2&quot;.</span><br><span class="line">#To avoid duplicated configurations, both docker registry and chart repository follow the same storage configuration specifications of docker registry.</span><br><span class="line">#Refer to https:&#x2F;&#x2F;docs.docker.com&#x2F;registry&#x2F;configuration&#x2F;#storage for all available configuration.</span><br><span class="line"></span><br><span class="line">#registry_storage_provider_config &#x3D;</span><br><span class="line">#配置ceph 存储</span><br><span class="line">registry_storage_provider_config &#x3D; bucket: f4gkewos23fdsf8fnfhG, region: default, accesskey: QaidfneuhgfE2dife, secretkey: qyIJDFNGIDNDKF8f2r3G5QSw, regionendpoint: http:&#x2F;&#x2F;ceph.chenzhijun.top, rootdirectory: &#x2F;harbor-registry&#x2F;di</span><br><span class="line"></span><br><span class="line">#registry_custom_ca_bundle is the path to the custom root ca certificate, which will be injected into the truststore</span><br><span class="line">#of registry&#39;s and chart repository&#39;s containers.  This is usually needed when the user hosts a internal storage with self signed certificate.</span><br><span class="line">registry_custom_ca_bundle &#x3D;</span><br><span class="line"></span><br><span class="line">#If reload_config&#x3D;true, all settings which present in harbor.cfg take effect after prepare and restart harbor, it overwrites exsiting settings.</span><br><span class="line">#reload_config&#x3D;true</span><br><span class="line">#Regular expression to match skipped environment variables</span><br><span class="line">#skip_reload_env_pattern&#x3D;(^EMAIL.*)|(^LDAP.*)</span><br></pre></td></tr></table></figure>

<p>配置好 cfg 文件后，我们开始我们的操作。</p>
<ol start="0">
<li><p>申请或安装 ceph，ceph 版本为 12；</p>
</li>
<li><p>安装 pg 数据库(生产应为高可用)：</p>
</li>
</ol>
<p><code>docker run --name pg -e POSTGRES_PASSWORD=123456 -p 5432:5432 -d postgres:10.6</code></p>
<ol start="2">
<li>安装 redis（生产因为高可用）：</li>
</ol>
<p><code>docker run --name redis -p 6379:6379 -d redis</code></p>
<ol start="3">
<li>安装 harbor：</li>
</ol>
<p><code>./install.sh --with-clair --with-chartmuseum</code></p>
<p>这里除了 notaty 必须要有个 https 外，其他的你都可以装。clair 是镜像扫描工具；chartmuseum 是 helm chart ；<br>你需要在两台机器都启动，并且保持cfg 文件一致。</p>
<ol start="4">
<li>配置 haproxy(F5)</li>
</ol>
<p>如果在 F5 做 https 转 http，那haproxy 就正常启动并将后段指向 harbor 地址就可以了。如果是让 https 做证书认证，那么就按照配置就好。我这边有在 F5 做解证书，贴一份 haproxy 的配置吧<code>haproxy.cfg</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">  daemon</span><br><span class="line">  log  127.0.0.1 local0 info</span><br><span class="line">  maxconn  20000</span><br><span class="line">  pidfile  &#x2F;app&#x2F;haproxy&#x2F;run&#x2F;haproxy.pid</span><br><span class="line">  stats  socket &#x2F;app&#x2F;haproxy&#x2F;lib&#x2F;haproxy&#x2F;stats</span><br><span class="line">  tune.bufsize  131072</span><br><span class="line">  user mwop</span><br><span class="line">  group mwop</span><br><span class="line">  tune.ssl.default-dh-param 2048</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">  log  global</span><br><span class="line">  maxconn  10000</span><br><span class="line">  mode  http</span><br><span class="line">  option  dontlog-normal</span><br><span class="line">  option  http-server-close</span><br><span class="line">  retries  3</span><br><span class="line">  #stats  enable</span><br><span class="line">  timeout  http-request 100s</span><br><span class="line">  timeout  queue 1m</span><br><span class="line">  timeout  connect 10s</span><br><span class="line">  timeout  client 1m</span><br><span class="line">  timeout  server 30m</span><br><span class="line">  timeout  check 10s</span><br><span class="line"></span><br><span class="line">listen Stats</span><br><span class="line">  bind 0.0.0.0:10000</span><br><span class="line">  mode http</span><br><span class="line">  stats enable</span><br><span class="line">  stats uri &#x2F;</span><br><span class="line">  stats refresh 5s</span><br><span class="line">  stats show-node</span><br><span class="line">  stats show-legends</span><br><span class="line">  stats hide-version</span><br><span class="line"></span><br><span class="line">listen app1</span><br><span class="line">    bind :80</span><br><span class="line">    balance     roundrobin</span><br><span class="line">    mode tcp</span><br><span class="line">    server s1  172.0.0.1:80   weight 1</span><br><span class="line">    server s2  172.0.0.2:80   weight 1</span><br><span class="line">    </span><br><span class="line">listen app2</span><br><span class="line">    bind :443 </span><br><span class="line">    balance     roundrobin</span><br><span class="line">    mode tcp</span><br><span class="line">    server s1  172.0.0.1:443   weight 1</span><br><span class="line">    server s2  172.0.0.2:443   weight 1</span><br></pre></td></tr></table></figure>

<p>访问<code>harbor.chenzhijun.top</code>就可以了。</p>
<p><img src="/images/qiniu/2020-04-26-21-43-00.png" alt="2020-04-26-21-43-00"></p>
<h3 id="https-问题-1-docker-login-failed"><a href="#https-问题-1-docker-login-failed" class="headerlink" title="https 问题 1 : docker login failed"></a>https 问题 1 : docker login failed</h3><p>安装完之后，你可能会遇到一些问题，比如在你直接 docker login 出现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error response from daemon: Get https:&#x2F;&#x2F;harbor.chenzhijun.top&#x2F;v2&#x2F;: Get http:&#x2F;&#x2F;harbor.chenzhijun.top&#x2F;service&#x2F;token?account&#x3D;admin&amp;client_id&#x3D;docker&amp;offline_token&#x3D;true&amp;service&#x3D;harbor-registry: dial tcp 100.77.53.130:80: getsockopt: connection refused</span><br></pre></td></tr></table></figure>

<p>你在页面登陆可以，当是你用 docker login却有问题。你可以<code>curl -X GET -I &quot;https://harbor.chenzhijun.top/v2/&quot;</code>看一下是否返回了一个 http 的请求。如果是的话，修改一个参数：<code>sed -i &quot;s/realm: http/realm: https/g&quot; common/config/registry/config.yml</code>;在<code>common/config/registry/config.yml</code>中修改返回值为 https：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auth:</span></span><br><span class="line">  <span class="attr">token:</span></span><br><span class="line">    <span class="attr">issuer:</span> <span class="string">harbor-token-issuer</span></span><br><span class="line">    <span class="attr">realm:</span> <span class="string">https://harbor.chenzhijun.top/service/token</span> <span class="comment">#就是这里要返回 https 而不是 http</span></span><br><span class="line">    <span class="attr">rootcertbundle:</span> <span class="string">/etc/registry/root.crt</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">harbor-registry</span></span><br></pre></td></tr></table></figure>
<p>这个地方改不是特别好改，我是在<code>install.sh</code>在 docker-compose启动之前加入的这个 sed 命令；</p>
<p><img src="/images/qiniu/2020-04-26-22-00-25.png" alt="2020-04-26-22-00-25"></p>
<p>然后再 curl 一下看是不是返回 https 的结果了。如果是就可以了。</p>
<h3 id="https-问题2-docker-push-出现-unkown-blob"><a href="#https-问题2-docker-push-出现-unkown-blob" class="headerlink" title="https 问题2 : docker push 出现 unkown blob"></a>https 问题2 : docker push 出现 unkown blob</h3><p>因为我们的架构是：域名 –&gt; dns解析到 –&gt; F5 VIP –&gt; haproxy –&gt; Harbor docker-compose;</p>
<p>在这个过程中，出现了一个问题。域名到到 F5是 https，而后面的 Harbor 接到的 http；所以在 docker login 成功。在 docker push 的时候出现了问题 <code>unkown blob</code>；这个问题的原因就是在反向代理中 harbor 的 nginx 代理用的还是 https 方式：<a href="https://github.com/goharbor/harbor/blob/release-1.7.0/docs/installation_guide.md#Troubleshooting">Harbor Troubleshooting</a>。修改<code>common/templates/nginx/nginx.http.conf</code>中的<code>proxy_set_header X-Forwarded-Proto $scheme;</code>把这行注释掉就可以了。</p>
<p>另外就是要注意 pg 的权限问题。</p>
<h3 id="https-问题3-docker-push-出现-unauthorized-authentication-required"><a href="#https-问题3-docker-push-出现-unauthorized-authentication-required" class="headerlink" title="https 问题3: docker push 出现 unauthorized: authentication required"></a>https 问题3: docker push 出现 unauthorized: authentication required</h3><p>这是一个很诡异的问题，找了我两个小时；现象是harbor 的页面能登陆，并且页面一切功能正常；直接使用 docker login 也是没有问题，但是在 push 镜像的时候出现，unauthorized: authentication required;明明已经登陆了，也没有问题，但是不知道为啥还是会报错。这个问题在我这里是由于 haproxy 的配置出现的问题。harbor push 镜像的过程是从 harbor 服务获取一个 token，然后再去访问 registry 的存储来存储数据，如果是是本地存储，那么会访问 80 端口。我的配置中将 haproxy 的 80 端口转了 redirect，所以导致认证失败。附上一段在 haproxy 段做证书解析而后端 harbor 为 http 的 haproxy 的服务配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frontend harbor</span><br><span class="line">  bind *:80</span><br><span class="line">  bind *:443 ssl crt &#x2F;data&#x2F;harbor&#x2F;harbor&#x2F;chenzhijun.top.pem</span><br><span class="line">  reqadd X-Forwarded-Proto:\ https</span><br><span class="line">  default_backend  harbor-backend</span><br><span class="line"></span><br><span class="line">backend harbor-backend</span><br><span class="line">  balance  source</span><br><span class="line">  mode  http</span><br><span class="line">  timeout  client 3h</span><br><span class="line">  timeout  server 3h</span><br><span class="line">  server server1 10.1.1.2:80  check inter 2000 fall 3</span><br></pre></td></tr></table></figure>

<p>如果还是有问题，可以在<code>/var/log/harbor</code>目录下查看相关的 log 日志。也可以查看系统日志：<code>/var/log/message</code>来定位问题。</p>
<p>我们也安装了 <code>/install.sh --with-clair --with-chartmuseum</code> clair 和 chartmuseum，这两个工具，clair 的主要目的是扫描 CVE 漏洞，所以是不是需要链接一下外网更新一下；chartmuseum 是一个 helm chart 管理器;</p>
<p><img src="/images/qiniu/2020-04-26-22-15-03.png" alt="2020-04-26-22-15-03"></p>
<p><img src="/images/qiniu/2020-04-26-22-16-24.png" alt="2020-04-26-22-16-24"></p>
<h2 id="升级问题"><a href="#升级问题" class="headerlink" title="升级问题"></a>升级问题</h2><p>最近尝试在本地进行了一次 1.7 升级到 1.8，其实还好啊，就是 cfg 文件变成了 yml 文件，其他的还是一样。并且有迁移工具：<br><a href="https://github.com/goharbor/harbor/blob/release-1.8.0/docs/migration_guide.md">https://github.com/goharbor/harbor/blob/release-1.8.0/docs/migration_guide.md</a></p>
<p>迁移工具使用方式：</p>
<p><code>docker run -it --rm -v /data/harbor/harbor/harbor.cfg:/harbor-migration/harbor-cfg/harbor.cfg -v /data/harbor/harbor/harbor.yml:/harbor-migration/harbor-cfg-out/harbor.yml harbor.uat.x.com/goharbor/harbor-migrator:v1.8.3 --cfg up</code></p>
<p>然后就停掉原来的 1.7 使用新的 1.8 的安装包启动就可以了。</p>
<p>迁移前一定要进行数据备份，一定要备份。</p>
<h2 id="helm-使用"><a href="#helm-使用" class="headerlink" title="helm 使用"></a>helm 使用</h2><p>helm 在 v3 之后（我只用了 v3）其实特别好用。在 github 上下载 helm 的安装包，然后把 helm 放到 /usr/local/bin 下面就可以直接执行 helm 命令了。当然前提是要本机有 kubectl，并且本地有 kubeconfig 文件<code>~/.kube/config</code>。这样我们就能愉快的使用 helm 了。那我们怎么使用 harbor 来管理我们的 helm chart 了？</p>
<p><code>helm repo add --username readonly --password Read2019 myharbor http://harbor.chenzhijun.top/chartrepo/helm-repo</code></p>
<p><code>http://harbor.chenzhijun.top/chartrepo/</code> 这一段是固定的，<code>helm-repo</code>是 harbor 中的 project 名。然后你将一个 chart 包导入：</p>
<p><img src="/images/qiniu/2020-04-26-22-25-53.png" alt="2020-04-26-22-25-53"></p>
<p><code>helm search repo myharbor</code></p>
<p><code>helm repo update</code></p>
<p><code>helm install myharbor/consul --gernerate-name</code></p>
<p>好了，就是这么简单粗暴。</p>
]]></content>
      <categories>
        <category>Harbor</category>
      </categories>
      <tags>
        <tag>Harbor</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK-HashMap解析</title>
    <url>/2018/02/06/jdk-util-hashmap/</url>
    <content><![CDATA[<h1 id="JDK-HashMap解析"><a href="#JDK-HashMap解析" class="headerlink" title="JDK-HashMap解析"></a>JDK-HashMap解析</h1><h2 id="jdk-类介绍"><a href="#jdk-类介绍" class="headerlink" title="jdk 类介绍"></a>jdk 类介绍</h2><p>HashMap 是一个继承Map接口并且是使用哈希表的实现。提供了所有的map操作，并且允许null建和null值。除了非同步方式和允许null键值，它大致上可以等同于<code>Hashtable</code>。影响HashMap表现的有两个原因：初始容量和加载因子。</p>
<p>capacity：容量指的是hash表中的总容量。初始容量在第一次创建hashmap的时候就已经创建好了。<br>load factor: 加载因子，是测量capacity在hash表达到了多满的时候可以自动增长。</p>
<p>当键值对达到了加载因子的量并且超过了当前的capacity，hash表就会重新进行hash（意思是内部数据结构将重建），目的是为了将hash表能够达到差不多两倍的容量。</p>
<p>通常的规则是，默认的加载因子为0.75，它可以在时间和空间上做一个非常好的平衡。如果设置自定义capacity，map里面可能存在多少键值队就需要作为一个考虑因素，以达到最小的rehash操作。如果初始capacity在设置capacity之后还能存下更多的键值对，那么就不会出现rehash操作。</p>
<p>如果事先能大致确认map的容量是多少，那么给map定一个初始化大小是非常可行的，会比让它自己增长更有效率。在hash表中如果出现太多的相同的key拥有相同的hashCode()会降低效率，如果需要改善这种关系，如果键是可以比较的，类可以使用key的比较顺序来进行改善。</p>
<p>HashMap的实现是非线程安全的。在多线程的环境下，必须在外部上进行同步控制。如果外部没有控制，那么需要将map进行包装，也就是使用Collections.synchronizedMap(map)方法，最好是在一开始创建map的时候就进行包装。<br>map的iterators方法是fail-fast的。在iterator创建之后，如果map的结构被修改了，除了iterator的remove方法，iterator会抛出ConcurrentModificationException异常。所以在多线程环境下进行修改，iterator会快速的返回失败。不过也得注意在非同步环境下，迭代器的fail-fast不能得到保证。迭代器抛出这个异常一个非常好的功能，但是不应该依赖它来写程序，如果出现异常那么就应该说明程序有bug。</p>
<p>jdk的源码里面，介绍的非常详细。真的很详细。</p>
<span id="more"></span>

<h2 id="分块介绍"><a href="#分块介绍" class="headerlink" title="分块介绍"></a>分块介绍</h2><p>之前说过map是非线程安全的，这节就单纯的聊一下非线程安全下的map。</p>
<p>一个类我们从哪里来看它了？其实我也不知道，那就干脆从我们使用一个对象开始。我们是先创建对象，给对象设置值，然后使用对象的方法。</p>
<h3 id="创建map"><a href="#创建map" class="headerlink" title="创建map"></a>创建map</h3><p>通常在创建map的时候我们会使用对象的构造方法，如果有对象有属性，可能还会有带参数的构造方法。所以在创建map之前我们先了解下map有哪些属性？</p>
<p>通过idea我截取了一个图，在jdk8中是</p>
<p><img src="/images/qiniu/2018-02-06-14-54-11.png" alt="2018-02-06-14-54-11"></p>
<p>在jdk7中：<br><img src="/images/qiniu/2018-02-06-15-00-27.png" alt="2018-02-06-15-00-27"></p>
<p>可以看到，map对象里面有一些属性，根据这些属性的定义我们可以猜到大致的意思。</p>
<p><code>DEFAULT_INITIAL_CAPCITY = 1&lt;&lt;4</code>：默认容量大小，1左移4位，16。记住默认的大小必须是2的幂。<br><code>MAXIMUM_CAPACITY = 1&lt;&lt;30</code>：最大的容量<br><code>DEFAULT_LOAD_FACTOR</code>:加载因子，默认0.75<br><code>Entry&lt;?,?&gt;[] EMPTY_TABLE</code>： 空表<br><code>Entry&lt;K,V&gt;[] table</code>：长度为2的幂方，并且必要的时候可以改变大小，默认为空表。注意到这个字段是<code>transient</code><br><code>size</code>: 实际map中键值对的数量<br><code>threshold</code>：下一次表重构的极限值<br><code>modCount</code>：hash表结构修改一次就增加一次，包括增加减少键值对，内部数据结构重构。主要用来在迭代器中fail-fast</p>
<p>大致的参数就这些了。</p>
<p>然后我们看到构造方法，如下图：</p>
<p><img src="/images/qiniu/2018-02-06-15-22-02.png" alt="2018-02-06-15-22-02"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你看构造函数带有Map的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line"></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现，同样的它也在里面调用带两个参数的构造方法，所以我认为，这个带两个参数的构造方法可以算作是基本方法，其实想想这算不算代码复用？如果我们可以在平常的开发中开发出了基础方法，那么是否也可以像这样进行包装使用？</p>
<p>这三个构造方法其实只是包装了一层而已，当然map构造方法进行了一些其它的操作，所以我们需要再看下里面的基础构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，我们的map里面，在使用的时候至少需要进行两个属性设置：<code>initialCapacity</code>初始容量和<code>loadFactor</code>加载因子。</p>
<p>可以看到代码的严谨性：在初始化的时候进行了参数可用性校验，平常我写方法的时候，偶尔会忘记这个，不过最后我会根据sonar扫描一次代码提交。哈哈sonar这点还是可以做到的。</p>
<p>在这个构造方法里面init()是一个空方法。</p>
<p>在map的构造方法里面后面还有两个操作，一个是inflateTable，一个是putAllForCreate。其实可以想到，用map的构造方法是有数据的，不同于其它三个，其它三个都是无数据的。所以我们只需要构建一个map出来就好了。而map的构造方法拥有数据所以在构建map之后我们需要将数据填充到新的map中。一个是扩容的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">            ? MAXIMUM_CAPACITY</span><br><span class="line">            : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inflates the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后的设置初始值就不详细说了。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="常用方法put-key-value"><a href="#常用方法put-key-value" class="headerlink" title="常用方法put(key,value)"></a>常用方法put(key,value)</h4><p>这个方法是从Map接口中继承过来的，我们大致猜测一下，map如果插入了一个键值对，插入之前我们是不是需要先判断一下容量？是不是还需要有个地方存入这个值？在哪里存这个键值对？：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对表容量进行判断</span></span><br><span class="line">     <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">         inflateTable(threshold);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//key的空值处理</span></span><br><span class="line">     <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">     <span class="comment">//对key进行hash计算</span></span><br><span class="line">     <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">     <span class="comment">//hash表中的位置i</span></span><br><span class="line">     <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">     <span class="comment">//在i的位置找到值，</span></span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">         </span><br><span class="line">         Object k;</span><br><span class="line">         <span class="comment">//条件1：判断当前key的hash与i位置的hash是否一致</span></span><br><span class="line">         <span class="comment">//条件2：判断key是否是i位置(entry)的key相等的</span></span><br><span class="line">         <span class="comment">//条件3：判断key是否和i位置(entry)的key内容相等</span></span><br><span class="line">         <span class="comment">//条件1&amp;&amp;（条件2||条件3）</span></span><br><span class="line">         <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">             <span class="comment">//说明找到了hash的key，将新值替换旧值</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             e.value = value;</span><br><span class="line">             e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//map数据结构修改，+1</span></span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="comment">//没有在i的位置找到值，说明这个是新的key，加入到entry</span></span><br><span class="line">     addEntry(hash, key, value, i);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们再代码中就可以看到之前的问题了，不过代码实现中还做了null值的处理。下面我们一个个来看：</p>
<p>扩容处理：inflateTable(threshold); 这个在上面构造map的时候讲过了。 </p>
<p>空值处理：putForNullKey(value);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从table的0位置开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//找到null的key，替换值</span></span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里的的操作是从0位置开始查找的。也就是从一开始遍历，这种情况下可以想到一个O(n)的时间复杂度。所以，如果是1.7，null键最好不要存在。</p>
<p>在代码中可以看到存键值对的地方是Entry，关于Entry我们现在只需要知道它是一个单链表的数据结构就好了，之后我们专门讲解一下Entry和hash。</p>
<p>讲完1.7。我们看看1.8中的put方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断是否是空表</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//空表，重构表</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果原始表中不存在数据，直接新建一个节点，p为表中key的数据节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//原始表中存在数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//找到了key节点hash的值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是一个TreeNode</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果节点存在，修改节点里面的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//size+1之后的大小大于极限值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk1.8中的put方法，实现好像有些优化。加入了TreeNode，之后这块我补上，整体的流程是和1.7一致的。</p>
<h4 id="常用方法get-key"><a href="#常用方法get-key" class="headerlink" title="常用方法get(key)"></a>常用方法get(key)</h4><p>该方法在1.7中的实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断null，如果是null遍历循环找出值</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">//找到存了key的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是空表，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">//循环遍历找到值，从hash值开始找</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.7中还是很好理解的，这里主要是hash值计算，之后我们重点讲解。</p>
<p>在1.8中，get方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//表不为空</span></span><br><span class="line">    <span class="comment">//表的内容长度不为0</span></span><br><span class="line">    <span class="comment">//在(n-1)&amp;hash的位置不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个位置?为什么判断第一个位置，是和node的数据结构有关系么？是不是加入的时候都是加入第一个位置？</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到8中总是计算判断第一个node，为什么？之后了解清楚了再来详细解析</p>
<h4 id="常用方法containsKey-Object-containsValue-Object"><a href="#常用方法containsKey-Object-containsValue-Object" class="headerlink" title="常用方法containsKey(Object),containsValue(Object)"></a>常用方法containsKey(Object),containsValue(Object)</h4><p>containsKey(Object)的源码中我们可以看到也是调用了getEntry方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>containsValue(Object)的源码中我们可以看到，基本类似，也是循环链表，然后获取到值之后比较value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="常用方法keySet-values-entrySet"><a href="#常用方法keySet-values-entrySet" class="headerlink" title="常用方法keySet(),values(),entrySet()"></a>常用方法keySet(),values(),entrySet()</h4><p>这几个方法是指代的键,值遍历，以及键值对遍历。</p>
<h4 id="常用方法size-，内部方法resize"><a href="#常用方法size-，内部方法resize" class="headerlink" title="常用方法size()，内部方法resize()"></a>常用方法size()，内部方法resize()</h4><p>这里就需要主要注意resize()方法是default的，也就是同一个包下面才可以调用。</p>
<p>size()方法就是为了获取到map里面真实的实例数量，返回的是size属性。</p>
<p>resize()方法在每次达到极限界值的时候会自动调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取原始表的容量值</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//原表容量值等于最大值，可以直接返回了。</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新表</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">//填充新表数据</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    <span class="comment">//替换旧表内容</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Entry-hash-hashCode-size-capacity-threshold"><a href="#Entry-hash-hashCode-size-capacity-threshold" class="headerlink" title="Entry,hash,hashCode(),size,capacity,threshold"></a>Entry,hash,hashCode(),size,capacity,threshold</h4><p>前面我们讲过一些常用的方法，put，get，size等，这些方法其实都是有一定关联的，put前是不是应该先判断容量是否够？不够该怎样，够该怎样。其实就是这样，就像流程图一样，只不过在具体的实现上面我们会有不同的方式。使用不同的数据结构来做优化。</p>
<p>这里我们需要讲一下Entry，hash，hashCode(),size,capacity,threshold他们代表的意义，以及作用。</p>
<p>如果说map是存储键值对，那么键是怎么存？值又是怎么存？两者怎么关联起来了？回过头我们思考这些问题，最好的方式就是看看put方法是怎么运作的：</p>
<p>jdk1.7:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 判断空表，然后扩容</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断nullkey</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点。这里计算了key的hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieve object hash code and applies a supplemental hash function to the</span></span><br><span class="line"><span class="comment"> * result hash, which defends against poor quality hash functions.  This is</span></span><br><span class="line"><span class="comment"> * critical because HashMap uses power-of-two length hash tables, that</span></span><br><span class="line"><span class="comment"> * otherwise encounter collisions for hashCodes that do not differ</span></span><br><span class="line"><span class="comment"> * in lower bits. Note: Null keys always map to hash 0, thus index 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 获取hash 值，对于hash结果进行重写，主要是为了防止低质量的hash计算方法，hashmap使用2的幂方长度的hash表，在低位容易遇到同样的hashcode冲突 </span></span><br><span class="line"><span class="comment"> Null 为key的hash是0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上它使用的是的是<code>Entry[] table</code> 数组，而Entry是一个链表的形式。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashCode方法是一个本地方法，hash算法实在key的hashCode上计算的，这里有两篇文章，感觉很好，我就不敢多说了：<br><a href="http://www.cnblogs.com/xiongpq/p/6175702.html%EF%BC%8Chttp://blog.csdn.net/fjse51/article/details/53811465%EF%BC%9B">http://www.cnblogs.com/xiongpq/p/6175702.html，http://blog.csdn.net/fjse51/article/details/53811465；</a></p>
<p>size是指的map实际中存在了多少键值对，也就是实际的实例；</p>
<p>capacity是指这个map的总容量；</p>
<p>threshold是一个极限值，当达到了size达到了极限值的时候就会自动扩容(2的幂次方)，threshold的计算为capacity*load factor。</p>
<p>在jdk8中感觉变化太大了，下次要单独讲讲jdk8。另外还需要讲解一下在多线程下的map该怎么操作。</p>
<h2 id="疑问待解决"><a href="#疑问待解决" class="headerlink" title="疑问待解决"></a>疑问待解决</h2><p>1：在put的时候，如果是重复键，再第二次的时候就只是替换了，那么entry链表有什么用？为什么这么设计？</p>
<p>2：hash的计算方式？hashCode计算方式，什么是hashCode？那些位运算是怎么做的？</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库索引优化实例</title>
    <url>/2018/03/23/mysql-optimization-index/</url>
    <content><![CDATA[<h1 id="数据库索引优化实例"><a href="#数据库索引优化实例" class="headerlink" title="数据库索引优化实例"></a>数据库索引优化实例</h1><p>索引对于查找小表或者需要处理表中大部分或全部行的大型表的查询不太重要，适合的才是最好的。</p>
<h2 id="数据库索引的操作"><a href="#数据库索引的操作" class="headerlink" title="数据库索引的操作"></a>数据库索引的操作</h2><ol>
<li>快速找到匹配where条件的行结果；</li>
<li>如果有多个索引，MySQL通常会使用能检索除最少结果行的索引；</li>
<li>如果有多列索引，优化器可以使用索引的最左边的前缀来查找行；比如有col1,col2,col3三列索引，那么你就可以使用(col1)，（col1,col2）,(col1,col2,col3)三个索引；</li>
<li>如果有多表连接join的语句，mysql会将varchar(10)和char(10)看成同一个类型并且有效的使用索引；两个表使用的字符要一样比如utf8,和latin，就不行；</li>
<li>在查找最小值和最大值的时候，优化器会先优化你是否在where条件中有常量值；</li>
<li>索引排序会使用最左边的索引列前缀；</li>
<li>在某些情况下，可以优化查询来检索值，而不必咨询数据行</li>
</ol>
<h2 id="主键与外键优化"><a href="#主键与外键优化" class="headerlink" title="主键与外键优化"></a>主键与外键优化</h2><p>主键索引的查询优化得益于主键不能为NULL值。表的数据在物理存储上就被组织为基于主键列或多列进行快速查找和排序。如果你的表很大又非常重要，然而却没有声明主键，或者组合主键，那么你需要新建一个新的列使用auto-increment来作为主键。</p>
<p>外键优化，如果有一个大表，有许多列，可以考虑将表的列进行拆分成小表，并且用外键关联。每个小表都有主键，这样可以让查找数据更加快速，而需要数据的时候也可以是使用join关联查询。由于数据是分散的，查询可以有更少的I/O,并且会使用更少的缓存。因为相关的列在磁盘中存储在一块。</p>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>建立一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">    id         <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_name  <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    first_name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX name (last_name,first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们有组合索引name，在索引查询中使用最左列查询是会使用索引的。也就是如下面的列子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Widenius&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Widenius&#x27;</span> <span class="keyword">AND</span> first_name<span class="operator">=</span><span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Widenius&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> (first_name<span class="operator">=</span><span class="string">&#x27;Michael&#x27;</span> <span class="keyword">OR</span> first_name<span class="operator">=</span><span class="string">&#x27;Monty&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Widenius&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> first_name <span class="operator">&gt;=</span><span class="string">&#x27;M&#x27;</span> <span class="keyword">AND</span> first_name <span class="operator">&lt;</span> <span class="string">&#x27;N&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>即只要有最左侧的索引列，那么索引就会生效。但是如果是单独使用的<code>first_name</code>，那么索引将不会生效，如下面的示例：</p>
<span id="more"></span>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> first_name<span class="operator">=</span><span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test</span><br><span class="line">  <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Widenius&#x27;</span> <span class="keyword">OR</span> first_name<span class="operator">=</span><span class="string">&#x27;Michael&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果是first_name,last_name两个列都建立索引，那么查询的时候如果两列都有建立单独的索引，那么优化器可能会使用能排除最大结果的那个索引。如果是联合索引，那么只要带有最左侧的索引列，那么优化器就会工作。比如如果有索引(col1,col2,col3)，下面的语句只会有前面两个可以用索引下面两个不会用到索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col1<span class="operator">=</span>val1;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col1<span class="operator">=</span>val1 <span class="keyword">AND</span> col2<span class="operator">=</span>val2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col2<span class="operator">=</span>val2;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col2<span class="operator">=</span>val2 <span class="keyword">AND</span> col3<span class="operator">=</span>val3;</span><br></pre></td></tr></table></figure>

<h3 id="索引扩展的使用"><a href="#索引扩展的使用" class="headerlink" title="索引扩展的使用"></a>索引扩展的使用</h3><p>如果表的主键是一个组合索引，并且还声明了另一个索引。那么innodb会自动建立一个次索引，这个次索引包含了两个组合主键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">  i1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  i2 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  d <span class="type">DATE</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (i1, i2),</span><br><span class="line">  INDEX k_d (d)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure>

<p>主键是一个组合主键，并且还有一个索引<code>k_d</code>；数据库还会在内部生成一个次索引（d,i1,i2）；优化器可以扩展次索引为ref,range,index_merge，可以在join和排序优化，和最大最小值优化；<br>The optimizer can use extended secondary indexes for ref, range, and index_merge index access, for loose index scans, for join and sorting optimization, and for MIN()/MAX() optimization.</p>
<p>考虑下面一个示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1998-01-01&#x27;</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;1999-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&#x27;2000-01-01&#x27;</span>), (<span class="number">1</span>, <span class="number">4</span>, <span class="string">&#x27;2001-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="number">5</span>, <span class="string">&#x27;2002-01-01&#x27;</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;1998-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&#x27;1999-01-01&#x27;</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;2000-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>, <span class="string">&#x27;2001-01-01&#x27;</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="string">&#x27;2002-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&#x27;1998-01-01&#x27;</span>), (<span class="number">3</span>, <span class="number">2</span>, <span class="string">&#x27;1999-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;2000-01-01&#x27;</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;2001-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;2002-01-01&#x27;</span>), (<span class="number">4</span>, <span class="number">1</span>, <span class="string">&#x27;1998-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">2</span>, <span class="string">&#x27;1999-01-01&#x27;</span>), (<span class="number">4</span>, <span class="number">3</span>, <span class="string">&#x27;2000-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">4</span>, <span class="string">&#x27;2001-01-01&#x27;</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;2002-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">1</span>, <span class="string">&#x27;1998-01-01&#x27;</span>), (<span class="number">5</span>, <span class="number">2</span>, <span class="string">&#x27;1999-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">3</span>, <span class="string">&#x27;2000-01-01&#x27;</span>), (<span class="number">5</span>, <span class="number">4</span>, <span class="string">&#x27;2001-01-01&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;2002-01-01&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>执行执行计划：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> i1 <span class="operator">=</span> <span class="number">3</span> <span class="keyword">AND</span> d <span class="operator">=</span> <span class="string">&#x27;2000-01-01&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/qiniu/2018-03-23-18-54-12.png" alt="2018-03-23-18-54-12"></p>
<p>如果是多表查询就像下面这样：</p>
<p><img src="/images/qiniu/2018-03-23-19-30-04.png" alt="2018-03-23-19-30-04"></p>
<p>如果要关闭优化器：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;use_index_extensions=off&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="执行计划-EXPLAIN"><a href="#执行计划-EXPLAIN" class="headerlink" title="执行计划 - EXPLAIN"></a>执行计划 - EXPLAIN</h3><p><code>EXPLAIN</code>语句提供你MySQL是怎么执行语句的过程。EXPLAIN可以在<code>SELECT</code>,<code>DELETE</code>,<code>INSERT</code>,<code>REPLACE</code>,<code>UPDATE</code>语句上使用，返回他们的执行计划。也就是这些语句是按照何种方式执行会返回表记录。EXPLAIN的执行计划可以使用<code>SHOW WARNINGS</code>来返回更多的扩展信息。</p>
<h4 id="执行计划输出的列信息"><a href="#执行计划输出的列信息" class="headerlink" title="执行计划输出的列信息"></a>执行计划输出的列信息</h4><table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">SELECT标识码</td>
</tr>
<tr>
<td align="center">select_type</td>
<td align="center">SELECT类型</td>
</tr>
<tr>
<td align="center">table</td>
<td align="center">表明</td>
</tr>
<tr>
<td align="center">partitions</td>
<td align="center">匹配分区</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">获取类型（access_type）</td>
</tr>
<tr>
<td align="center">possible_keys</td>
<td align="center">可选择的索引</td>
</tr>
<tr>
<td align="center">key</td>
<td align="center">实际执行语句时候选择的索引</td>
</tr>
<tr>
<td align="center">key_len</td>
<td align="center">选择的key的长度</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">The columns compared to the index</td>
</tr>
<tr>
<td align="center">rows</td>
<td align="center">预计会有多少行被查询到</td>
</tr>
<tr>
<td align="center">filtered</td>
<td align="center">Percentage of rows filtered by table condition</td>
</tr>
<tr>
<td align="center">extra</td>
<td align="center">扩展信息</td>
</tr>
</tbody></table>
<p>其中<code>select_type</code>可以是下面这些值：</p>
<table>
<thead>
<tr>
<th align="center">select_type 值</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIMPLE</td>
<td align="center">简单查询（不使用union或者子查询）</td>
</tr>
<tr>
<td align="center">PRIMARY</td>
<td align="center">最常用的查询类型</td>
</tr>
<tr>
<td align="center">UNION</td>
<td align="center">联合查询(Second or later SELECT statement in a UNION)</td>
</tr>
<tr>
<td align="center">DEPENDENT_UNION</td>
<td align="center">依赖外部的联合查询（Second or later SELECT statement in a UNION, dependent on outer query）</td>
</tr>
<tr>
<td align="center">UNION RESULT</td>
<td align="center">UNION的结果</td>
</tr>
<tr>
<td align="center">SUBQUERY</td>
<td align="center">子查询</td>
</tr>
<tr>
<td align="center">DEPENDENT SUBQUERY</td>
<td align="center">依赖外部的子查询</td>
</tr>
<tr>
<td align="center">DERIVED</td>
<td align="center">Derived table SELECT (subquery in FROM clause)</td>
</tr>
<tr>
<td align="center">MATERIALIZED</td>
<td align="center">Materialized subquery</td>
</tr>
<tr>
<td align="center">UNCACHEABLE SUBQUERY</td>
<td align="center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td align="center">UNCACHEABLE UNION</td>
<td align="center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<p>其中<code>type</code> 可以是下面这些值，如果执行计划是全表扫描，那么最好是进行优化，以下表格从最优到最慢排序：</p>
<table>
<thead>
<tr>
<th align="center">type值</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">system</td>
<td align="center">表只有一行数据（系统表），特殊的const类型</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">表查询出来的结果最多只有一行，适用于主键查询和唯一索引查询</td>
</tr>
<tr>
<td align="center">eq_ref</td>
<td align="center">唯一索引行，常用于join查询中主键查询和非null唯一索引。第二个表只会匹配第一个表中的一行数据，一对一的关系</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">一对多关系，前一个表的一行数据可以匹配另一个表的多行数据</td>
</tr>
<tr>
<td align="center">fulltext</td>
<td align="center">全文本扫描</td>
</tr>
<tr>
<td align="center">ref_or_null</td>
<td align="center">类似ref，不过会处理null值</td>
</tr>
<tr>
<td align="center">index_merge</td>
<td align="center">This join type indicates that the Index Merge optimization is used. In this case, the <code>key</code> column in the output row contains a list of indexes used, and <code>key_len</code> contains a list of the longest key parts for the indexes used.</td>
</tr>
<tr>
<td align="center">unique_subquery</td>
<td align="center">替换eq_ref在in的子查询中的类型（value IN (SELECT primary_key FROM single_table WHERE some_expr)）</td>
</tr>
<tr>
<td align="center">index_subquery</td>
<td align="center">类似unique_subquery，替换在in查询中，但是它是使用在非唯一索引的子查询中(value IN (SELECT key_column FROM single_table WHERE some_expr))</td>
</tr>
<tr>
<td align="center">range</td>
<td align="center">范围搜索，使用索引查找行结果。在这个查询中key列是指那个索引被用到，key_len是指被用到的最长的key。ref列是NULL</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">同ALL一样会扫描全表不过是以索引扫描。在这个类型中只有单索引会出现这种类型。另外注意两点注意:1.If the index is a covering index for the queries and can be used to satisfy all data required from the table, only the index tree is scanned. In this case, the Extra column says Using index. An index-only scan usually is faster than ALL because the size of the index usually is smaller than the table data. 2. A full table scan is performed using reads from the index to look up data rows in index order. <code>Uses index</code> does not appear in the <code>Extra</code> column</td>
</tr>
<tr>
<td align="center">ALL</td>
<td align="center">全表扫描，需要避免</td>
</tr>
</tbody></table>
<p>其中<code>ref</code>的含义为：</p>
<p>ref列显示哪些列或常量与key列中命名的索引相比较，以便从表中选择数据。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>外部银行卡表，除了主键，没有其它的索引：</p>
<p><img src="/images/qiniu/2018-03-23-20-20-21.png" alt="2018-03-23-20-20-21"></p>
<p>第一次使用查询语句执行计划：</p>
<p><img src="/images/qiniu/2018-03-23-20-22-25.png" alt="2018-03-23-20-22-25"></p>
<p>然后我们增加索引一个索引列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `cncsen`.`bank_card_info` </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX `card_no_UNIQUE` (`card_no` <span class="keyword">ASC</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/qiniu/2018-03-23-20-23-59.png" alt="2018-03-23-20-23-59"></p>
<p>再次执行刚刚的执行计划：</p>
<p><img src="/images/qiniu/2018-03-23-20-25-31.png" alt="2018-03-23-20-25-31"></p>
<p>加入索引后很明显我们由全表扫描变成了范围扫描，试想如果该表数据很大，那么这种优化是有意义的。所以Explain还是很有作用的</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html">How MySQL Uses Indexes</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">EXPLAIN Output Format</a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>摘抄了一个gitchat的文章：</p>
<h3 id="MySQL索引优化规则"><a href="#MySQL索引优化规则" class="headerlink" title="MySQL索引优化规则"></a>MySQL索引优化规则</h3><p>可以通过以下规则对 MySQL 索引进行优化。</p>
<ol>
<li>前导模糊查询不能使用索引。</li>
</ol>
<p>例如下面 SQL 语句不能使用索引。<br>select * fromdoc where title like ‘%XX’</p>
<p>而非前导模糊查询则可以使用索引，如下面的 SQL 语句。<br>select * fromdoc where title like ‘XX%’</p>
<p>页面搜索严禁左模糊或者全模糊，如果需要可以用搜索引擎来解决。</p>
<ol start="2">
<li>union、in、or 都能够命中索引，建议使用 in。</li>
</ol>
<p>union：能够命中索引。<br>示例代码如下：<br>select * fromdoc where status=1</p>
<p>unionall</p>
<p>select * fromdoc where status=2</p>
<p>直接告诉 MySQL 怎么做，MySQL 耗费的 CPU 最少，但是一般不这么写 SQL。<br>in：能够命中索引。</p>
<p>示例代码如下：<br>select * fromdoc where status in (1, 2)</p>
<p>查询优化耗费的 CPU 比 union all 多，但可以忽略不计，一般情况下建议使用 in<br>or：新版的 MySQL 能够命中索引。</p>
<p>示例代码如下：<br>select * fromdoc where status = 1 or status = 2</p>
<p>查询优化耗费的 CPU 比 in 多，不建议频繁用 or。</p>
<ol start="3">
<li>负向条件查询不能使用索引，可以优化为 in 查询。</li>
</ol>
<p>负向条件有：!=、&lt;&gt;、not in、not exists、not like 等。</p>
<p>例如下面代码：<br>select * fromdoc where status != 1 and status != 2</p>
<p>可以优化为 in 查询：<br>select * fromdoc where status in (0,3,4)</p>
<ol start="4">
<li>联合索引最左前缀原则（又叫最左侧查询）</li>
</ol>
<p>如果在(a,b,c)三个字段上建立联合索引，那么它能够加快 a | (a,b) | (a,b,c) 三组查询速度。</p>
<p>例如登录业务需求，代码如下。<br>selectuid, login_time from user where login_name=? andpasswd=?</p>
<p>可以建立(login_name, passwd)的联合索引。</p>
<p>因为业务上几乎没有 passwd 的单条件查询需求，而有很多 login_name 的单条件查询需求，所以可以建立(login_name, passwd)的联合索引，而不是(passwd, login_name)。<br>建联合索引的时候，区分度最高的字段在最左边。<br>如果建立了(a,b)联合索引，就不必再单独建立 a 索引。同理，如果建立了(a,b,c)联合索引，就不必再单独建立 a、(a,b) 索引。<br>存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如     where a&gt;? and b=?，那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。<br>最左侧查询需求，并不是指 SQL 语句的 where 顺序要和联合索引一致。</p>
<p>下面的 SQL 语句也可以命中 (login_name, passwd) 这个联合索引。<br>selectuid, login_time from user where passwd=? andlogin_name=?</p>
<p>但还是建议 where 后的顺序和联合索引一致，养成好习惯。</p>
<ol start="5">
<li>范围列可以用到索引（联合索引必须是最左前缀）。</li>
</ol>
<p>范围条件有：&lt;、&lt;=、&gt;、&gt;=、between等。<br>范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。</p>
<p>假如有联合索引 (empno、title、fromdate)，那么下面的 SQL 中 emp_no 可以用到索引，而 title 和 from_date 则使用不到索引。<br>select * fromemployees.titles where emp_no &lt; 10010’ and title=’Senior Engineer’and from_date between ‘1986-01-01’ and ‘1986-12-31’</p>
<ol start="6">
<li>把计算放到业务层而不是数据库层。</li>
</ol>
<p>在字段上进行计算不能命中索引。</p>
<p>例如下面的 SQL 语句。<br>select * fromdoc where YEAR(create_time) &lt;= ‘2016’</p>
<p>即使 date 上建立了索引，也会全表扫描，可优化为值计算，如下：<br>select * fromdoc where create_time &lt;= ‘2016-01-01’</p>
<p>把计算放到业务层。</p>
<p>这样做不仅可以节省数据库的 CPU，还可以起到查询缓存优化效果。</p>
<p>比如下面的 SQL 语句：<br>select * fromorder where date &lt; = CURDATE()</p>
<p>可以优化为：<br>select * fromorder where date &lt; = ‘2018-01-2412:00:00’</p>
<p>优化后的 SQL 释放了数据库的 CPU 多次调用，传入的 SQL 相同，才可以利用查询缓存。</p>
<ol start="7">
<li>强制类型转换会全表扫描</li>
</ol>
<p>如果 phone 字段是 varchar 类型，则下面的 SQL 不能命中索引。<br> select * fromuser where phone=13800001234</p>
<p>可以优化为：<br>select * fromuser where phone=’13800001234’</p>
<ol start="8">
<li>更新十分频繁、数据区分度不高的字段上不宜建立索引。</li>
</ol>
<p>更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。<br>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。<br>一般区分度在80%以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))/count(*) 来计算。</p>
<ol start="9">
<li>利用覆盖索引来进行查询操作，避免回表。</li>
</ol>
<p>被查询的列，数据能从索引中取得，而不用通过行定位符 row-locator 再到 row 上获取，即“被查询列要被所建的索引覆盖”，这能够加速查询速度。</p>
<p>例如登录业务需求，代码如下。<br>selectuid, login_time from user where login_name=? andpasswd=?</p>
<p>可以建立(login_name, passwd, login_time)的联合索引，由于 login_time 已经建立在索引中了，被查询的 uid 和 login_time 就不用去 row 上获取数据了，从而加速查询。</p>
<ol start="10">
<li>如果有 order by、group by 的场景，请注意利用索引的有序性。</li>
</ol>
<p>order     by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现     file_sort 的情况，影响查询性能。<br>例如对于语句 where a=? and b=? order by     c，可以建立联合索引(a,b,c)。<br>如果索引中有范围查找，那么索引有序性无法利用，如 WHERE     a&gt;10 ORDER BY b;，索引(a,b)无法排序。</p>
<ol start="11">
<li>使用短索引（又叫前缀索引）来优化索引。</li>
</ol>
<p>前缀索引，就是用列的前缀代替整个列作为索引 key，当前缀长度合适时，可以做到既使得前缀索引的区分度接近全列索引，同时因为索引 key 变短而减少了索引文件的大小和维护开销，可以使用 count(distinct left(列名, 索引长度))/count(*) 来计算前缀索引的区分度。</p>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于 ORDER BY 和 GROUP BY 操作，也不能用于覆盖索引（Covering Index，即当索引本身包含查询所需全部数据时，不再访问数据文件本身），很多时候没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p>
<p>例如对于下面的 SQL 语句：<br>SELEC * FROM employees.employees WHERE first_name=’Eric’AND last_name=’Anido’;</p>
<p>我们可以建立索引：(firstname, lastname(4))。</p>
<ol start="12">
<li>建立索引的列，不允许为 null。</li>
</ol>
<p>单列索引不存 null 值，复合索引不存全为 null 的值，如果列允许为 null，可能会得到“不符合预期”的结果集，所以，请使用 not null 约束以及默认值。</p>
<ol start="13">
<li>利用延迟关联或者子查询优化超多分页场景。</li>
</ol>
<p>MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</p>
<p>示例如下，先快速定位需要获取的 id 段，然后再关联:<br>selecta.* from 表1 a,(select id from 表1 where 条件 limit100000,20 ) b where a.id=b.id</p>
<ol start="14">
<li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</li>
</ol>
<p>不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p>
<ol start="15">
<li>超过三个表最好不要 join。</li>
</ol>
<p>需要 join 的字段，数据类型必须一致，多表关联查询时，保证被关联的字段需要有索引。</p>
<ol start="16">
<li>如果明确知道只有一条结果返回，limit 1 能够提高效率。</li>
</ol>
<p>比如如下 SQL 语句：<br>select * from user where login_name=?</p>
<p>可以优化为：<br>select * from user where login_name=? limit 1</p>
<p>自己明确知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动。</p>
<ol start="17">
<li>SQL 性能优化 explain 中的 type：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。</li>
</ol>
<p>consts：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。<br>ref：使用普通的索引（Normal Index）。<br>range：对索引进行范围检索。<br>当 type=index 时，索引物理文件全扫，速度非常慢。</p>
<ol start="18">
<li><p>单表索引建议控制在5个以内。</p>
</li>
<li><p>单索引字段数不允许超过5个。</p>
</li>
</ol>
<p>字段超过5个时，实际已经起不到有效过滤数据的作用了。</p>
<ol start="20">
<li>创建索引时避免以下错误观念</li>
</ol>
<p>索引越多越好，认为一个查询就需要建一个索引。<br>宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度。<br>抵制惟一索引，认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。<br>过早优化，在不了解系统的情况下就开始优化。</p>
<h4 id="问题详解"><a href="#问题详解" class="headerlink" title="问题详解"></a>问题详解</h4><p>这部分，我将列出平时会遇到的一些问题，并给予解答。</p>
<ol>
<li>请问如下三条 SQL 该如何建立索引？</li>
</ol>
<p>where a=1and b=1</p>
<p>where b=1</p>
<p>where b=1order by time desc</p>
<p>MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引吗？<br>回答：             </p>
<p>第一问：建议建立两个索引，即 idxab(a,b) 和 idxbtime(b,time)。<br>第二问：MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，对于上面的第一条 SQL，如果建立索引为 idxba(b,a) 也是可以用到索引的，不过建议 where 后的字段顺序和联合索引保持一致，养成好习惯。</p>
<ol start="2">
<li>假如有联合索引(empno、title、fromdate)，下面的 SQL 是否可以用到索引，如果可以的话，会使用几个列？</li>
</ol>
<p>select * fromemployees.titles where emp_no between ‘10001’ and’10010’ and title=’Senior Engineer’ and from_date between ‘1986-01-01’and ‘1986-12-31’</p>
<p>回答：可以使用索引，可以用到索引全部三个列，这个 SQL 看起来是用了两个范围查询，但作用于 empno 上的“between”实际上相当于“in”，也就是说 empno 实际是多值精确匹配，在 MySQL 中要谨慎地区分多值匹配和范围匹配，否则会对 MySQL 的行为产生困惑。</p>
<ol start="3">
<li>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？</li>
</ol>
<p>回答：不是，因为索引虽然加快了查询速度，但索引也是有代价的。索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担。另外，MySQL 在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，另一种是数据的区分度比较低，可以使用 count(distinct(列名))/count(*) 来计算区分度。</p>
<ol start="4">
<li>主键和聚集索引的关系？</li>
</ol>
<p>回答：在 MySQL 中，InnoDB 引擎表是（聚集）索引组织表（Clustered IndexOrganize Table)，它会先按照主键进行聚集，如果没有定义主键，InnoDB 会试着使用唯一的非空索引来代替，如果没有这种索引，InnoDB 就会定义隐藏的主键然后在上面进行聚集。由此可见，在 InnoDB 表中，主键必然是聚集索引，而聚集索引则未必是主键。MyISAM 引擎表是堆组织表（Heap Organize Table)，它没有聚集索引的概念。</p>
<ol start="5">
<li>一个6亿的表 a，一个3亿的表 b，通过外键 tid 关联，如何最快的查询出满足条件的第50000到第50200中的这200条数据记录？</li>
</ol>
<p>回答：方法一：如果 a 表 tid 是自增长，并且是连续的，b表的id为索引。SQL语句如下。<br>select * froma,b where a.tid = b.id and a.tid&gt;500000 limit200;</p>
<p>方法二：如果 a 表的 tid 不是连续的，那么就需要使用覆盖索引，tid 要么是主键，要么是辅助索引，b 表 id 也需要有索引。SQL语句如下。<br>select * fromb, (select tid from a limit 50000,200) awhere b.id = a.tid;</p>
<ol start="6">
<li>假如建立联合索引(a,b,c)，下列语句是否可以使用索引，如果可以，使用了那几列？（考察联合索引最左前缀原则）</li>
</ol>
<p>where a= 3</p>
<p>答：是，使用了 a 列。<br>where a= 3 and b = 5</p>
<p>答：是，使用了 a，b 列。<br>where a = 3 and c = 4 and b = 5</p>
<p>答：是，使用了 a，b，c 列。<br>where b= 3</p>
<p>答：否。<br>where a= 3 and c = 4</p>
<p>答：是，使用了 a 列。<br>where a = 3 and b &gt; 10 andc = 7</p>
<p>答：是，使用了 a，b 列。<br>where a = 3 and b like ‘xx%’ andc = 7</p>
<p>答：是，使用了 a，b 列。</p>
<ol start="7">
<li>文章表的表结构如下：</li>
</ol>
<p>CREATE TABLEIF NOT EXISTS <code>article</code> (<code>id</code>int(10) unsigned NOT NULLAUTO_INCREMENT,</p>
<p><code>author_id</code>int(10) unsignedNOT NULL,</p>
<p><code>category_id</code>int(10) unsigned NOT NULL,</p>
<p><code>views</code>int(10) unsignedNOT NULL,</p>
<p><code>comments</code>int(10) unsignedNOT NULL,</p>
<p><code>title</code>varbinary(255) NOT NULL,</p>
<p><code>content</code>text NOTNULL,</p>
<p>PRIMARY KEY (<code>id</code>)</p>
<p>);</p>
<p>下面语句应该如何建立索引？<br>select author_id, title, content from <code>article</code></p>
<p>where category_id = 1 and comments &gt; 1</p>
<p>order byviews desc limit 1;</p>
<p>回答：<br>没有联合索引时，explain显示，如下图所示：</p>
<p>创建 idxcategoryidcommentsviews(category_id,comments, views) 联合索引时，explain显示，如下图所示：</p>
<p>创建 idxcategoryidviews(categoryid,views) 联合索引，explain 显示，如下图所示：<br>由此可见，可以创建 idxcategoryidviews(categoryid,views) 联合索引。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS 服务器搭建</title>
    <url>/2018/06/09/self-dns-server-install/</url>
    <content><![CDATA[<h1 id="搭建公司内部DNS服务器"><a href="#搭建公司内部DNS服务器" class="headerlink" title="搭建公司内部DNS服务器"></a>搭建公司内部DNS服务器</h1><p>平常有很多时候可能会通过改hosts文件的方式来访问自定义的某个域名，但仅限于单机而已。如果能用dns解析的方式来统一管理那将会很方便。</p>
<h2 id="搭建-DNS-服务器"><a href="#搭建-DNS-服务器" class="headerlink" title="搭建 DNS 服务器"></a>搭建 DNS 服务器</h2><p>实验基于centos7实践。切换到root用户（以下所有操作都在root下执行）：</p>
<ol>
<li>安装软件：</li>
</ol>
<p>我们使用dns软件 bind9 系列安装包。</p>
<p><code>yum -y install bind*</code></p>
<p>安装后的部分日志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Installed:</span><br><span class="line">  bind.x86_64 32:9.9.4-61.el7               bind-chroot.x86_64 32:9.9.4-61.el7        bind-devel.x86_64 32:9.9.4-61.el7       </span><br><span class="line">  bind-dyndb-ldap.x86_64 0:11.1-4.el7       bind-libs.x86_64 32:9.9.4-61.el7          bind-lite-devel.x86_64 32:9.9.4-61.el7  </span><br><span class="line">  bind-pkcs11.x86_64 32:9.9.4-61.el7        bind-pkcs11-devel.x86_64 32:9.9.4-61.el7  bind-pkcs11-libs.x86_64 32:9.9.4-61.el7 </span><br><span class="line">  bind-pkcs11-utils.x86_64 32:9.9.4-61.el7  bind-sdb.x86_64 32:9.9.4-61.el7           bind-sdb-chroot.x86_64 32:9.9.4-61.el7  </span><br><span class="line">  bind-utils.x86_64 32:9.9.4-61.el7        </span><br><span class="line"></span><br><span class="line">Dependency Installed:</span><br><span class="line">  postgresql-libs.x86_64 0:9.2.23-3.el7_4                                                                                      </span><br><span class="line"></span><br><span class="line">Updated:</span><br><span class="line">  bind-libs-lite.x86_64 32:9.9.4-61.el7                           bind-license.noarch 32:9.9.4-61.el7       </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="2">
<li>备份主配置文件：</li>
</ol>
<p>  <code>cp /etc/named.conf /etc/name.conf.bak.$(date &#39;+%Y-%m-%d&#39;)</code></p>
<ol start="3">
<li>修改主配置文件：<code>vi /etc/named.conf</code></li>
</ol>
<p>  修改两处为<code>any</code>：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  options &#123;</span><br><span class="line">	listen-on port 53 &#123; any; &#125;; &#x2F;&#x2F; 修改此处为any</span><br><span class="line">	listen-on-v6 port 53 &#123; ::1; &#125;;</span><br><span class="line">	directory 	&quot;&#x2F;var&#x2F;named&quot;;</span><br><span class="line">	dump-file 	&quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;cache_dump.db&quot;;</span><br><span class="line">	statistics-file &quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;named_stats.txt&quot;;</span><br><span class="line">	memstatistics-file &quot;&#x2F;var&#x2F;named&#x2F;data&#x2F;named_mem_stats.txt&quot;;</span><br><span class="line">	allow-query     &#123; any; &#125;; &#x2F;&#x2F;修改此处为any</span><br><span class="line">	&#x2F;&#x2F;forwarders &#123;</span><br><span class="line">		</span><br><span class="line">	&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* </span><br><span class="line">	 - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.</span><br><span class="line">	 - If you are building a RECURSIVE (caching) DNS server, you need to enable </span><br><span class="line">	   recursion. </span><br><span class="line">	 - If your recursive DNS server has a public IP address, you MUST enable access </span><br><span class="line">	   control to limit queries to your legitimate users. Failing to do so will</span><br><span class="line">	   cause your server to become part of large scale DNS amplification </span><br><span class="line">	   attacks. Implementing BCP38 within your network would greatly</span><br><span class="line">	   reduce such attack surface </span><br><span class="line">	*&#x2F;</span><br><span class="line">	recursion yes;</span><br><span class="line"></span><br><span class="line">	dnssec-enable yes;</span><br><span class="line">	dnssec-validation no; &#x2F;&#x2F;修改这里ping通外网</span><br><span class="line"></span><br><span class="line">	&#x2F;* Path to ISC DLV key *&#x2F;</span><br><span class="line">	bindkeys-file &quot;&#x2F;etc&#x2F;named.iscdlv.key&quot;;</span><br><span class="line"></span><br><span class="line">	managed-keys-directory &quot;&#x2F;var&#x2F;named&#x2F;dynamic&quot;;</span><br><span class="line"></span><br><span class="line">	pid-file &quot;&#x2F;run&#x2F;named&#x2F;named.pid&quot;;</span><br><span class="line">	session-keyfile &quot;&#x2F;run&#x2F;named&#x2F;session.key&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">logging &#123;</span><br><span class="line">        channel default_debug &#123;</span><br><span class="line">                file &quot;data&#x2F;named.run&quot;;</span><br><span class="line">                severity dynamic;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone &quot;.&quot; IN &#123;</span><br><span class="line">	type hint;</span><br><span class="line">	file &quot;named.ca&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">include &quot;&#x2F;etc&#x2F;named.rfc1912.zones&quot;;</span><br><span class="line">include &quot;&#x2F;etc&#x2F;named.root.key&quot;;</span><br></pre></td></tr></table></figure>

<h1 id="自定义域名配置"><a href="#自定义域名配置" class="headerlink" title="自定义域名配置"></a>自定义域名配置</h1><p>现在安装后基本的dns服务器之后，我们就开始自定义个域名来进行解析:</p>
<p><code>vi named.rfc1912.zones</code></p>
<p>增加一个需要解析的主域名比如：<code>cococzj.com</code>;(公网肯定没有这个域名)</p>
<p>增加下面的文件到文件<code>named.rfc1912.zones</code>的最后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zone &quot;cococzj.com&quot; IN &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;cococzj.com.zone&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="增加域名配置"><a href="#增加域名配置" class="headerlink" title="增加域名配置"></a>增加域名配置</h1><p>上面定义了<code>cococzj.com.zone</code>的文件，现在增加配置：<code>vi /var/named/cococzj.com.zone</code></p>
<p>增加下面的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$TTL 86400</span><br><span class="line">@       IN SOA          ns.cococzj.com. root (</span><br><span class="line">                                        1       ; serial</span><br><span class="line">                                        1D      ; refresh</span><br><span class="line">                                        1H      ; retry</span><br><span class="line">                                        1W      ; expire</span><br><span class="line">                                        0 )     ; minimum  </span><br><span class="line"></span><br><span class="line">@       IN      NS      ns.cococzj.com.</span><br><span class="line">ns      IN      A       10.62.12.24</span><br><span class="line">www     IN      A       10.62.14.80</span><br><span class="line">ttt     IN      A       10.62.12.3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ns 对应的ip地址必须为dns服务器搭建的IP地址，也就是dns安装的机器的ip地址。</p>
<p><code>ns      IN      A       10.62.12.24</code>  ==&gt; <code>ns      IN      A       your_dns_server_ip</code></p>
<p><code>www     IN      A       10.62.14.80</code> 代表将<code>www.cococzj.com</code>解析到<code>10.62.14.80</code>服务器上。</p>
<h1 id="修改zone文件权限"><a href="#修改zone文件权限" class="headerlink" title="修改zone文件权限"></a>修改zone文件权限</h1><p><code>chown .named /var/named/cococzj.com.zone</code></p>
<h1 id="检查配置文件"><a href="#检查配置文件" class="headerlink" title="检查配置文件"></a>检查配置文件</h1><p><code>named-checkconf</code> 检查主配置文件是否配置正确，没有输出表明是正确的:</p>
<p><code>named-checkzone</code> 检查zone文件配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">named-checkzone &quot;cococzj.com&quot; /var/named/cococzj.com.zone</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">zone cococzj.com/IN: loaded serial 1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h1 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h1><p>可以先ping一下服务域名再重启：<br><code>systemctl restart named.service</code></p>
<h1 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h1><ol>
<li>先ping试一下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@k8s-dev-yw-1 etc]# ping www.cococzj.com</span><br><span class="line">ping: www.cococzj.com: Name or service not known</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>增加dns服务地址；<code>vi /etc/resolv.conf</code>，在文件中新建：</li>
</ol>
<p><code>nameserver 10.62.12.2</code></p>
<p>再一次ping：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s-dev-yw-1 etc]# vi /etc/resolv.conf</span><br><span class="line">[root@k8s-dev-yw-1 etc]# ping www.cococzj.com</span><br><span class="line">PING www.cococzj.com (10.62.14.80) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.62.14.80 (10.62.14.80): icmp_seq=1 ttl=63 time=0.501 ms</span><br><span class="line">64 bytes from 10.62.14.80 (10.62.14.80): icmp_seq=2 ttl=63 time=0.466 ms</span><br><span class="line">64 bytes from 10.62.14.80 (10.62.14.80): icmp_seq=3 ttl=63 time=0.509 ms</span><br><span class="line">^C</span><br><span class="line">--- www.cococzj.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2001ms</span><br><span class="line">rtt min/avg/max/mdev = 0.466/0.492/0.509/0.018 ms</span><br></pre></td></tr></table></figure>

<h1 id="新增一个域名"><a href="#新增一个域名" class="headerlink" title="新增一个域名"></a>新增一个域名</h1><ol>
<li><code>vi named.rfc1912.zones</code>在文件中新增：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zone &quot;your_website.com&quot; IN &#123;</span><br><span class="line">        type master;</span><br><span class="line">        file &quot;your_website.com.zone&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>复制一份之前配置好的配置<code>cp /var/named/cococzj.com.zone /var/named/your_website.com.zone</code></p>
</li>
<li><p>编辑配置文件 <code>vi /var/named/your_website.com.zone</code>将<code>cococzj</code>改为<code>your_website</code>，然后修改相应的ip和</p>
</li>
<li><p>检查配置文件：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@k8s-dev-yw-1 etc]# named-checkzone &quot;cmrrancher.com&quot; &#x2F;var&#x2F;named&#x2F;chenzhijunrancher.com.zone</span><br><span class="line">zone cmrrancher.com&#x2F;IN: loaded serial 1</span><br><span class="line">OK</span><br><span class="line">[root@k8s-dev-yw-1 etc]# named-checkconf</span><br><span class="line">[root@k8s-dev-yw-1 etc]# </span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>重载服务<br><code>systemctl reload named.service</code></p>
</li>
<li><p>测试：<code>ping www.chenzhijunrancher.com</code></p>
</li>
</ol>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@qianyi-monitor-3 etc]# yum install -y bind*</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">http:&#x2F;&#x2F;10.0.0.5&#x2F;centos&#x2F;7&#x2F;cloud&#x2F;x86_64&#x2F;openstack-newton&#x2F;repodata&#x2F;repomd.xml: [Errno 14] HTTP Error 404 - Not Found</span><br><span class="line">Trying other mirror.</span><br><span class="line">To address this issue please refer to the below knowledge base article </span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;access.redhat.com&#x2F;articles&#x2F;1320623</span><br><span class="line"></span><br><span class="line">If above article doesn&#39;t help to resolve this issue please create a bug on https:&#x2F;&#x2F;bugs.centos.org&#x2F;</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;10.0.0.5&#x2F;centos&#x2F;7&#x2F;docker&#x2F;x86_64&#x2F;repodata&#x2F;repomd.xml: [Errno 14] HTTP Error 404 - Not Found</span><br><span class="line">Trying other mirror.</span><br><span class="line">dockerrepo                                                                                                                                          | 2.9 kB  00:00:00     </span><br><span class="line">http:&#x2F;&#x2F;10.0.0.5&#x2F;centos&#x2F;7&#x2F;latest&#x2F;x86_64&#x2F;repodata&#x2F;repomd.xml: [Errno 14] HTTP Error 404 - Not Found</span><br><span class="line">Trying other mirror.</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Resolving Dependencies</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package bind.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">--&gt; Processing Dependency: libGeoIP.so.1()(64bit) for package: 32:bind-9.9.4-61.el7.x86_64</span><br><span class="line">---&gt; Package bind-chroot.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">---&gt; Package bind-devel.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">---&gt; Package bind-dyndb-ldap.x86_64 0:11.1-4.el7 will be installed</span><br><span class="line">---&gt; Package bind-libs.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">---&gt; Package bind-libs-lite.x86_64 32:9.9.4-29.el7 will be updated</span><br><span class="line">---&gt; Package bind-libs-lite.x86_64 32:9.9.4-61.el7 will be an update</span><br><span class="line">---&gt; Package bind-license.noarch 32:9.9.4-29.el7 will be updated</span><br><span class="line">---&gt; Package bind-license.noarch 32:9.9.4-61.el7 will be an update</span><br><span class="line">---&gt; Package bind-lite-devel.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">---&gt; Package bind-pkcs11.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">---&gt; Package bind-pkcs11-devel.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">---&gt; Package bind-pkcs11-libs.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">---&gt; Package bind-pkcs11-utils.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">---&gt; Package bind-sdb.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">--&gt; Processing Dependency: libpq.so.5()(64bit) for package: 32:bind-sdb-9.9.4-61.el7.x86_64</span><br><span class="line">---&gt; Package bind-sdb-chroot.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">---&gt; Package bind-utils.x86_64 32:9.9.4-61.el7 will be installed</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package GeoIP.x86_64 0:1.5.0-11.el7 will be installed</span><br><span class="line">---&gt; Package postgresql-libs.x86_64 0:9.2.23-3.el7_4 will be installed</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> Package                                        Arch                                Version                                        Repository                         Size</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Installing:</span><br><span class="line"> bind                                           x86_64                              32:9.9.4-61.el7                                base                              1.8 M</span><br><span class="line"> bind-chroot                                    x86_64                              32:9.9.4-61.el7                                base                               87 k</span><br><span class="line"> bind-devel                                     x86_64                              32:9.9.4-61.el7                                base                              399 k</span><br><span class="line"> bind-dyndb-ldap                                x86_64                              11.1-4.el7                                     base                              122 k</span><br><span class="line"> bind-libs                                      x86_64                              32:9.9.4-61.el7                                base                              1.0 M</span><br><span class="line"> bind-lite-devel                                x86_64                              32:9.9.4-61.el7                                base                              308 k</span><br><span class="line"> bind-pkcs11                                    x86_64                              32:9.9.4-61.el7                                base                              298 k</span><br><span class="line"> bind-pkcs11-devel                              x86_64                              32:9.9.4-61.el7                                base                              105 k</span><br><span class="line"> bind-pkcs11-libs                               x86_64                              32:9.9.4-61.el7                                base                              1.1 M</span><br><span class="line"> bind-pkcs11-utils                              x86_64                              32:9.9.4-61.el7                                base                              198 k</span><br><span class="line"> bind-sdb                                       x86_64                              32:9.9.4-61.el7                                base                              353 k</span><br><span class="line"> bind-sdb-chroot                                x86_64                              32:9.9.4-61.el7                                base                               87 k</span><br><span class="line"> bind-utils                                     x86_64                              32:9.9.4-61.el7                                base                              204 k</span><br><span class="line">Updating:</span><br><span class="line"> bind-libs-lite                                 x86_64                              32:9.9.4-61.el7                                base                              734 k</span><br><span class="line"> bind-license                                   noarch                              32:9.9.4-61.el7                                base                               85 k</span><br><span class="line">Installing for dependencies:</span><br><span class="line"> GeoIP                                          x86_64                              1.5.0-11.el7                                   base                              1.1 M</span><br><span class="line"> postgresql-libs                                x86_64                              9.2.23-3.el7_4                                 base                              234 k</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Install  13 Packages (+2 Dependent packages)</span><br><span class="line">Upgrade   2 Packages</span><br><span class="line"></span><br><span class="line">Total download size: 8.1 M</span><br><span class="line">Downloading packages:</span><br><span class="line">Delta RPMs disabled because &#x2F;usr&#x2F;bin&#x2F;applydeltarpm not installed.</span><br><span class="line">(1&#x2F;17): bind-9.9.4-61.el7.x86_64.rpm                                                                                                                | 1.8 MB  00:00:00     </span><br><span class="line">(2&#x2F;17): GeoIP-1.5.0-11.el7.x86_64.rpm                                                                                                               | 1.1 MB  00:00:00     </span><br><span class="line">(3&#x2F;17): bind-chroot-9.9.4-61.el7.x86_64.rpm                                                                                                         |  87 kB  00:00:00     </span><br><span class="line">(4&#x2F;17): bind-devel-9.9.4-61.el7.x86_64.rpm                                                                                                          | 399 kB  00:00:00     </span><br><span class="line">(5&#x2F;17): bind-dyndb-ldap-11.1-4.el7.x86_64.rpm                                                                                                       | 122 kB  00:00:00     </span><br><span class="line">(6&#x2F;17): bind-libs-lite-9.9.4-61.el7.x86_64.rpm                                                                                                      | 734 kB  00:00:00     </span><br><span class="line">(7&#x2F;17): bind-libs-9.9.4-61.el7.x86_64.rpm                                                                                                           | 1.0 MB  00:00:00     </span><br><span class="line">(8&#x2F;17): bind-license-9.9.4-61.el7.noarch.rpm                                                                                                        |  85 kB  00:00:00     </span><br><span class="line">(9&#x2F;17): bind-lite-devel-9.9.4-61.el7.x86_64.rpm                                                                                                     | 308 kB  00:00:00     </span><br><span class="line">(10&#x2F;17): bind-pkcs11-9.9.4-61.el7.x86_64.rpm                                                                                                        | 298 kB  00:00:00     </span><br><span class="line">(11&#x2F;17): bind-pkcs11-devel-9.9.4-61.el7.x86_64.rpm                                                                                                  | 105 kB  00:00:00     </span><br><span class="line">(12&#x2F;17): bind-pkcs11-utils-9.9.4-61.el7.x86_64.rpm                                                                                                  | 198 kB  00:00:00     </span><br><span class="line">(13&#x2F;17): bind-pkcs11-libs-9.9.4-61.el7.x86_64.rpm                                                                                                   | 1.1 MB  00:00:00     </span><br><span class="line">(14&#x2F;17): bind-sdb-9.9.4-61.el7.x86_64.rpm                                                                                                           | 353 kB  00:00:00     </span><br><span class="line">(15&#x2F;17): bind-sdb-chroot-9.9.4-61.el7.x86_64.rpm                                                                                                    |  87 kB  00:00:00     </span><br><span class="line">(16&#x2F;17): bind-utils-9.9.4-61.el7.x86_64.rpm                                                                                                         | 204 kB  00:00:00     </span><br><span class="line">(17&#x2F;17): postgresql-libs-9.2.23-3.el7_4.x86_64.rpm                                                                                                  | 234 kB  00:00:00     </span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">Total                                                                                                                                       12 MB&#x2F;s | 8.1 MB  00:00:00     </span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  Installing : GeoIP-1.5.0-11.el7.x86_64                                                                                                                              1&#x2F;19 </span><br><span class="line">  Updating   : 32:bind-license-9.9.4-61.el7.noarch                                                                                                                    2&#x2F;19 </span><br><span class="line">  Installing : 32:bind-libs-9.9.4-61.el7.x86_64                                                                                                                       3&#x2F;19 </span><br><span class="line">  Installing : 32:bind-9.9.4-61.el7.x86_64                                                                                                                            4&#x2F;19 </span><br><span class="line">  Installing : 32:bind-pkcs11-libs-9.9.4-61.el7.x86_64                                                                                                                5&#x2F;19 </span><br><span class="line">  Updating   : 32:bind-libs-lite-9.9.4-61.el7.x86_64                                                                                                                  6&#x2F;19 </span><br><span class="line">  Installing : postgresql-libs-9.2.23-3.el7_4.x86_64                                                                                                                  7&#x2F;19 </span><br><span class="line">  Installing : 32:bind-sdb-9.9.4-61.el7.x86_64                                                                                                                        8&#x2F;19 </span><br><span class="line">  Installing : 32:bind-sdb-chroot-9.9.4-61.el7.x86_64                                                                                                                 9&#x2F;19 </span><br><span class="line">  Installing : 32:bind-lite-devel-9.9.4-61.el7.x86_64                                                                                                                10&#x2F;19 </span><br><span class="line">  Installing : 32:bind-pkcs11-devel-9.9.4-61.el7.x86_64                                                                                                              11&#x2F;19 </span><br><span class="line">  Installing : 32:bind-pkcs11-9.9.4-61.el7.x86_64                                                                                                                    12&#x2F;19 </span><br><span class="line">  Installing : 32:bind-pkcs11-utils-9.9.4-61.el7.x86_64                                                                                                              13&#x2F;19 </span><br><span class="line">  Installing : 32:bind-chroot-9.9.4-61.el7.x86_64                                                                                                                    14&#x2F;19 </span><br><span class="line">  Installing : bind-dyndb-ldap-11.1-4.el7.x86_64                                                                                                                     15&#x2F;19 </span><br><span class="line">Enabling SELinux boolean named_write_master_zones</span><br><span class="line">setsebool:  SELinux is disabled.</span><br><span class="line">  Installing : 32:bind-devel-9.9.4-61.el7.x86_64                                                                                                                     16&#x2F;19 </span><br><span class="line">  Installing : 32:bind-utils-9.9.4-61.el7.x86_64                                                                                                                     17&#x2F;19 </span><br><span class="line">  Cleanup    : 32:bind-libs-lite-9.9.4-29.el7.x86_64                                                                                                                 18&#x2F;19 </span><br><span class="line">  Cleanup    : 32:bind-license-9.9.4-29.el7.noarch                                                                                                                   19&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-pkcs11-devel-9.9.4-61.el7.x86_64                                                                                                               1&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-pkcs11-9.9.4-61.el7.x86_64                                                                                                                     2&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-chroot-9.9.4-61.el7.x86_64                                                                                                                     3&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-sdb-9.9.4-61.el7.x86_64                                                                                                                        4&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-9.9.4-61.el7.x86_64                                                                                                                            5&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-devel-9.9.4-61.el7.x86_64                                                                                                                      6&#x2F;19 </span><br><span class="line">  Verifying  : GeoIP-1.5.0-11.el7.x86_64                                                                                                                              7&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-pkcs11-libs-9.9.4-61.el7.x86_64                                                                                                                8&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-lite-devel-9.9.4-61.el7.x86_64                                                                                                                 9&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-libs-9.9.4-61.el7.x86_64                                                                                                                      10&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-pkcs11-utils-9.9.4-61.el7.x86_64                                                                                                              11&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-libs-lite-9.9.4-61.el7.x86_64                                                                                                                 12&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-utils-9.9.4-61.el7.x86_64                                                                                                                     13&#x2F;19 </span><br><span class="line">  Verifying  : bind-dyndb-ldap-11.1-4.el7.x86_64                                                                                                                     14&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-license-9.9.4-61.el7.noarch                                                                                                                   15&#x2F;19 </span><br><span class="line">  Verifying  : postgresql-libs-9.2.23-3.el7_4.x86_64                                                                                                                 16&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-sdb-chroot-9.9.4-61.el7.x86_64                                                                                                                17&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-libs-lite-9.9.4-29.el7.x86_64                                                                                                                 18&#x2F;19 </span><br><span class="line">  Verifying  : 32:bind-license-9.9.4-29.el7.noarch                                                                                                                   19&#x2F;19 </span><br><span class="line"></span><br><span class="line">Installed:</span><br><span class="line">  bind.x86_64 32:9.9.4-61.el7                bind-chroot.x86_64 32:9.9.4-61.el7          bind-devel.x86_64 32:9.9.4-61.el7     bind-dyndb-ldap.x86_64 0:11.1-4.el7        </span><br><span class="line">  bind-libs.x86_64 32:9.9.4-61.el7           bind-lite-devel.x86_64 32:9.9.4-61.el7      bind-pkcs11.x86_64 32:9.9.4-61.el7    bind-pkcs11-devel.x86_64 32:9.9.4-61.el7   </span><br><span class="line">  bind-pkcs11-libs.x86_64 32:9.9.4-61.el7    bind-pkcs11-utils.x86_64 32:9.9.4-61.el7    bind-sdb.x86_64 32:9.9.4-61.el7       bind-sdb-chroot.x86_64 32:9.9.4-61.el7     </span><br><span class="line">  bind-utils.x86_64 32:9.9.4-61.el7         </span><br><span class="line"></span><br><span class="line">Dependency Installed:</span><br><span class="line">  GeoIP.x86_64 0:1.5.0-11.el7                                                    postgresql-libs.x86_64 0:9.2.23-3.el7_4                                                   </span><br><span class="line"></span><br><span class="line">Updated:</span><br><span class="line">  bind-libs-lite.x86_64 32:9.9.4-61.el7                                                 bind-license.noarch 32:9.9.4-61.el7                                                </span><br><span class="line"></span><br><span class="line">Complete!</span><br></pre></td></tr></table></figure>

<p>两个重要的配置文件：</p>
<p>/etc/named.rfc1912.zones ： 定义域</p>
<p>/var/named ：域的详细配置</p>
<p>之后记得要将文件的权限复制给named这个用户和组。</p>
<p>上面的配置可以连接到本地的定义的域名，但是无法ping通百度等。所以一般需要再配置文件中增加<code>forwarders</code>，当本地没有找到定义的域之后会在<code>forwarders</code>中定义的继续查找。打开forwarders之后记得修改<code>dnssec-validation no;</code>这样之后再ping 外网的域名就可以了。</p>
]]></content>
  </entry>
</search>
